function ___$insertStyle(css) {
    if (!css) {
        return;
    }
    if (typeof window === 'undefined') {
        return;
    }

    var style = document.createElement('style');

    style.setAttribute('type', 'text/css');
    style.innerHTML = css;
    document.head.appendChild(style);
    return css;
}

import React from 'react';

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }

    return obj;
}

function _extends() {
    _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target;
    };

    return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }

    return keys;
}

function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }

    return target;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };

    return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
}

function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
    }

    return _assertThisInitialized(self);
}

function createCommonjsModule(fn, module) {
    return module = {
        exports: {}
    }, fn(module, module.exports), module.exports;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
    return function() {
        return arg;
    };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function() {
    return this;
};
emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
};

var emptyFunction_1 = emptyFunction;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
    validateFormat = function validateFormat(format) {
        if (format === undefined) {
            throw new Error('invariant requires an error message argument');
        }
    };
}

function invariant(condition, format, a, b, c, d, e, f) {
    validateFormat(format);

    if (!condition) {
        var error;
        if (format === undefined) {
            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
            var args = [a, b, c, d, e, f];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function() {
                return args[argIndex++];
            }));
            error.name = 'Invariant Violation';
        }

        error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
    }
}

var invariant_1 = invariant;

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction_1;

if (process.env.NODE_ENV !== 'production') {
    var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };

    warning = function warning(condition, format) {
        if (format === undefined) {
            throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }

        if (format.indexOf('Failed Composite propType: ') === 0) {
            return; // Ignore CompositeComponent proptype check.
        }

        if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                args[_key2 - 2] = arguments[_key2];
            }

            printWarning.apply(undefined, [format].concat(args));
        }
    };
}

var warning_1 = warning;

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
    if (val === null || val === undefined) {
        throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
}

function shouldUseNative() {
    try {
        if (!Object.assign) {
            return false;
        }

        // Detect buggy property enumeration order in older V8 versions.

        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
        test1[5] = 'de';
        if (Object.getOwnPropertyNames(test1)[0] === '5') {
            return false;
        }

        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {};
        for (var i = 0; i < 10; i++) {
            test2['_' + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join('') !== '0123456789') {
            return false;
        }

        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {};
        'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join('') !==
            'abcdefghijklmnopqrst') {
            return false;
        }

        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}

var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;

    for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);

        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
            }
        }

        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                }
            }
        }
    }

    return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret;

if (process.env.NODE_ENV !== 'production') {
    var invariant$1 = invariant_1;
    var warning$1 = warning_1;
    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
    var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if (process.env.NODE_ENV !== 'production') {
        for (var typeSpecName in typeSpecs) {
            if (typeSpecs.hasOwnProperty(typeSpecName)) {
                var error;
                // Prop type validation may throw. In case they do, we don't want to
                // fail the render phase where it didn't fail before. So we log it.
                // After these have been cleaned up, we'll let them throw.
                try {
                    // This is intentionally an invariant that gets caught. It's the same
                    // behavior as without this statement except with a better message.
                    invariant$1(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
                } catch (ex) {
                    error = ex;
                }
                warning$1(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    // Only monitor this failure once because there tends to be a lot of the
                    // same error.
                    loggedTypeFailures[error.message] = true;

                    var stack = getStack ? getStack() : '';

                    warning$1(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
                }
            }
        }
    }
}

var checkPropTypes_1 = checkPropTypes;

var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */
    function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === 'function') {
            return iteratorFn;
        }
    }

    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */

    var ANONYMOUS = '<<anonymous>>';

    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
        array: createPrimitiveTypeChecker('array'),
        bool: createPrimitiveTypeChecker('boolean'),
        func: createPrimitiveTypeChecker('function'),
        number: createPrimitiveTypeChecker('number'),
        object: createPrimitiveTypeChecker('object'),
        string: createPrimitiveTypeChecker('string'),
        symbol: createPrimitiveTypeChecker('symbol'),

        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker,
    };

    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */
    /*eslint-disable no-self-compare*/
    function is(x, y) {
        // SameValue algorithm
        if (x === y) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return x !== 0 || 1 / x === 1 / y;
        } else {
            // Step 6.a: NaN == NaN
            return x !== x && y !== y;
        }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */
    function PropTypeError(message) {
        this.message = message;
        this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
        if (process.env.NODE_ENV !== 'production') {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
        }

        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;

            if (secret !== ReactPropTypesSecret_1) {
                if (throwOnDirectAccess) {
                    // New behavior only for users of `prop-types` package
                    invariant_1(
                        false,
                        'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                        'Use `PropTypes.checkPropTypes()` to call them. ' +
                        'Read more at http://fb.me/use-check-prop-types'
                    );
                } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
                    // Old behavior for people using React.PropTypes
                    var cacheKey = componentName + ':' + propName;
                    if (!manualPropTypeCallCache[cacheKey] &&
                        // Avoid spamming the console because they are often not actionable except for lib authors
                        manualPropTypeWarningCount < 3
                    ) {
                        warning_1(
                            false,
                            'You are manually calling a React.PropTypes validation ' +
                            'function for the `%s` prop on `%s`. This is deprecated ' +
                            'and will throw in the standalone `prop-types` package. ' +
                            'You may be seeing this warning due to a third-party PropTypes ' +
                            'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
                            propFullName,
                            componentName
                        );
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                    }
                }
            }
            if (props[propName] == null) {
                if (isRequired) {
                    if (props[propName] === null) {
                        return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                    }
                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                }
                return null;
            } else {
                return validate(props, propName, componentName, location, propFullName);
            }
        }

        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);

        return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);

                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunction_1.thatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
            }
            for (var i = 0; i < propValue.length; i++) {
                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
                if (error instanceof Error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
            process.env.NODE_ENV !== 'production' ? warning_1(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
            return emptyFunction_1.thatReturnsNull;
        }

        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
                if (is(propValue, expectedValues[i])) {
                    return null;
                }
            }

            var valuesString = JSON.stringify(expectedValues);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
        }
        return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
            }
            for (var key in propValue) {
                if (propValue.hasOwnProperty(key)) {
                    var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
                    if (error instanceof Error) {
                        return error;
                    }
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
            process.env.NODE_ENV !== 'production' ? warning_1(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
            return emptyFunction_1.thatReturnsNull;
        }

        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== 'function') {
                warning_1(
                    false,
                    'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
                    'received %s at index %s.',
                    getPostfixForTypeWarning(checker),
                    i
                );
                return emptyFunction_1.thatReturnsNull;
            }
        }

        function validate(props, propName, componentName, location, propFullName) {
            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                var checker = arrayOfTypeCheckers[i];
                if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
                    return null;
                }
            }

            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
        }
        return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            for (var key in shapeTypes) {
                var checker = shapeTypes[key];
                if (!checker) {
                    continue;
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            // We need to check all keys in case some are required but missing from
            // props.
            var allKeys = objectAssign({}, props[propName], shapeTypes);
            for (var key in allKeys) {
                var checker = shapeTypes[key];
                if (!checker) {
                    return new PropTypeError(
                        'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
                        '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
                        '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
                    );
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
                if (error) {
                    return error;
                }
            }
            return null;
        }

        return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
        switch (typeof propValue) {
            case 'number':
            case 'string':
            case 'undefined':
                return true;
            case 'boolean':
                return !propValue;
            case 'object':
                if (Array.isArray(propValue)) {
                    return propValue.every(isNode);
                }
                if (propValue === null || isValidElement(propValue)) {
                    return true;
                }

                var iteratorFn = getIteratorFn(propValue);
                if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) {
                        while (!(step = iterator.next()).done) {
                            if (!isNode(step.value)) {
                                return false;
                            }
                        }
                    } else {
                        // Iterator will provide entry [k,v] tuples rather than values.
                        while (!(step = iterator.next()).done) {
                            var entry = step.value;
                            if (entry) {
                                if (!isNode(entry[1])) {
                                    return false;
                                }
                            }
                        }
                    }
                } else {
                    return false;
                }

                return true;
            default:
                return false;
        }
    }

    function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === 'symbol') {
            return true;
        }

        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue['@@toStringTag'] === 'Symbol') {
            return true;
        }

        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
            return true;
        }

        return false;
    }

    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
            return 'array';
        }
        if (propValue instanceof RegExp) {
            // Old webkits (at least until Android 4.0) return 'function' rather than
            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
            // passes PropTypes.object.
            return 'object';
        }
        if (isSymbol(propType, propValue)) {
            return 'symbol';
        }
        return propType;
    }

    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
        if (typeof propValue === 'undefined' || propValue === null) {
            return '' + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === 'object') {
            if (propValue instanceof Date) {
                return 'date';
            } else if (propValue instanceof RegExp) {
                return 'regexp';
            }
        }
        return propType;
    }

    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
            case 'array':
            case 'object':
                return 'an ' + type;
            case 'boolean':
            case 'date':
            case 'regexp':
                return 'a ' + type;
            default:
                return type;
        }
    }

    // Returns class name of the object, if any.
    function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
        }
        return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes_1;
    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
};

var factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret_1) {
            // It is still safe when called from React.
            return;
        }
        invariant_1(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use PropTypes.checkPropTypes() to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
        );
    }
    shim.isRequired = shim;

    function getShim() {
        return shim;
    } // Important!
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
    var ReactPropTypes = {
        array: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,

        any: shim,
        arrayOf: getShim,
        element: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim
    };

    ReactPropTypes.checkPropTypes = emptyFunction_1;
    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
};

var propTypes = createCommonjsModule(function(module) {
    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    if (process.env.NODE_ENV !== 'production') {
        var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
                Symbol.for &&
                Symbol.for('react.element')) ||
            0xeac7;

        var isValidElement = function(object) {
            return typeof object === 'object' &&
                object !== null &&
                object.$$typeof === REACT_ELEMENT_TYPE;
        };

        // By explicitly using `prop-types` you are opting into new development behavior.
        // http://fb.me/prop-types-in-prod
        var throwOnDirectAccess = true;
        module.exports = factoryWithTypeCheckers(isValidElement, throwOnDirectAccess);
    } else {
        // By explicitly using `prop-types` you are opting into new production behavior.
        // http://fb.me/prop-types-in-prod
        module.exports = factoryWithThrowingShims();
    }
});

var CONSTANT = {
    GLOBAL: {
        HIDE: "__react_tooltip_hide_event",
        REBUILD: "__react_tooltip_rebuild_event",
        SHOW: "__react_tooltip_show_event"
    }
};

/**
 * Static methods for react-tooltip
 */

var dispatchGlobalEvent = function dispatchGlobalEvent(eventName, opts) {
    // Compatible with IE
    // @see http://stackoverflow.com/questions/26596123/internet-explorer-9-10-11-event-constructor-doesnt-work
    var event;

    if (typeof window.CustomEvent === "function") {
        event = new window.CustomEvent(eventName, {
            detail: opts
        });
    } else {
        event = document.createEvent("Event");
        event.initEvent(eventName, false, true);
        event.detail = opts;
    }

    window.dispatchEvent(event);
};

function staticMethods(target) {
    /**
     * Hide all tooltip
     * @trigger ReactTooltip.hide()
     */
    target.hide = function(target) {
        dispatchGlobalEvent(CONSTANT.GLOBAL.HIDE, {
            target: target
        });
    };
    /**
     * Rebuild all tooltip
     * @trigger ReactTooltip.rebuild()
     */


    target.rebuild = function() {
        dispatchGlobalEvent(CONSTANT.GLOBAL.REBUILD);
    };
    /**
     * Show specific tooltip
     * @trigger ReactTooltip.show()
     */


    target.show = function(target) {
        dispatchGlobalEvent(CONSTANT.GLOBAL.SHOW, {
            target: target
        });
    };

    target.prototype.globalRebuild = function() {
        if (this.mount) {
            this.unbindListener();
            this.bindListener();
        }
    };

    target.prototype.globalShow = function(event) {
        if (this.mount) {
            // Create a fake event, specific show will limit the type to `solid`
            // only `float` type cares e.clientX e.clientY
            var e = {
                currentTarget: event.detail.target
            };
            this.showTooltip(e, true);
        }
    };

    target.prototype.globalHide = function(event) {
        if (this.mount) {
            var hasTarget = event && event.detail && event.detail.target && true || false;
            this.hideTooltip({
                currentTarget: hasTarget && event.detail.target
            }, hasTarget);
        }
    };
}

/**
 * Events that should be bound to the window
 */
function windowListener(target) {
    target.prototype.bindWindowEvents = function(resizeHide) {
        // ReactTooltip.hide
        window.removeEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide);
        window.addEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide, false); // ReactTooltip.rebuild

        window.removeEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild);
        window.addEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild, false); // ReactTooltip.show

        window.removeEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow);
        window.addEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow, false); // Resize

        if (resizeHide) {
            window.removeEventListener("resize", this.onWindowResize);
            window.addEventListener("resize", this.onWindowResize, false);
        }
    };

    target.prototype.unbindWindowEvents = function() {
        window.removeEventListener(CONSTANT.GLOBAL.HIDE, this.globalHide);
        window.removeEventListener(CONSTANT.GLOBAL.REBUILD, this.globalRebuild);
        window.removeEventListener(CONSTANT.GLOBAL.SHOW, this.globalShow);
        window.removeEventListener("resize", this.onWindowResize);
    };
    /**
     * invoked by resize event of window
     */


    target.prototype.onWindowResize = function() {
        if (!this.mount) return;
        this.hideTooltip();
    };
}

/**
 * Custom events to control showing and hiding of tooltip
 *
 * @attributes
 * - `event` {String}
 * - `eventOff` {String}
 */
var checkStatus = function checkStatus(dataEventOff, e) {
    var show = this.state.show;
    var id = this.props.id;
    var isCapture = this.isCapture(e.currentTarget);
    var currentItem = e.currentTarget.getAttribute("currentItem");
    if (!isCapture) e.stopPropagation();

    if (show && currentItem === "true") {
        if (!dataEventOff) this.hideTooltip(e);
    } else {
        e.currentTarget.setAttribute("currentItem", "true");
        setUntargetItems(e.currentTarget, this.getTargetArray(id));
        this.showTooltip(e);
    }
};

var setUntargetItems = function setUntargetItems(currentTarget, targetArray) {
    for (var i = 0; i < targetArray.length; i++) {
        if (currentTarget !== targetArray[i]) {
            targetArray[i].setAttribute("currentItem", "false");
        } else {
            targetArray[i].setAttribute("currentItem", "true");
        }
    }
};

var customListeners = {
    id: "9b69f92e-d3fe-498b-b1b4-c5e63a51b0cf",
    set: function set(target, event, listener) {
        if (this.id in target) {
            var map = target[this.id];
            map[event] = listener;
        } else {
            // this is workaround for WeakMap, which is not supported in older browsers, such as IE
            Object.defineProperty(target, this.id, {
                configurable: true,
                value: _defineProperty({}, event, listener)
            });
        }
    },
    get: function get(target, event) {
        var map = target[this.id];

        if (map !== undefined) {
            return map[event];
        }
    }
};

function customEvent(target) {
    target.prototype.isCustomEvent = function(ele) {
        var event = this.state.event;
        return event || !!ele.getAttribute("data-event");
    };
    /* Bind listener for custom event */


    target.prototype.customBindListener = function(ele) {
        var _this = this;

        var _this$state = this.state,
            event = _this$state.event,
            eventOff = _this$state.eventOff;
        var dataEvent = ele.getAttribute("data-event") || event;
        var dataEventOff = ele.getAttribute("data-event-off") || eventOff;
        dataEvent.split(" ").forEach(function(event) {
            ele.removeEventListener(event, customListeners.get(ele, event));
            var customListener = checkStatus.bind(_this, dataEventOff);
            customListeners.set(ele, event, customListener);
            ele.addEventListener(event, customListener, false);
        });

        if (dataEventOff) {
            dataEventOff.split(" ").forEach(function(event) {
                ele.removeEventListener(event, _this.hideTooltip);
                ele.addEventListener(event, _this.hideTooltip, false);
            });
        }
    };
    /* Unbind listener for custom event */


    target.prototype.customUnbindListener = function(ele) {
        var _this$state2 = this.state,
            event = _this$state2.event,
            eventOff = _this$state2.eventOff;
        var dataEvent = event || ele.getAttribute("data-event");
        var dataEventOff = eventOff || ele.getAttribute("data-event-off");
        ele.removeEventListener(dataEvent, customListeners.get(ele, event));
        if (dataEventOff) ele.removeEventListener(dataEventOff, this.hideTooltip);
    };
}

/**
 * Util method to judge if it should follow capture model
 */
function isCapture(target) {
    target.prototype.isCapture = function(currentTarget) {
        return currentTarget && currentTarget.getAttribute("data-iscapture") === "true" || this.props.isCapture || false;
    };
}

/**
 * Util method to get effect
 */
function getEffect(target) {
    target.prototype.getEffect = function(currentTarget) {
        var dataEffect = currentTarget.getAttribute("data-effect");
        return dataEffect || this.props.effect || "float";
    };
}

/**
 * Util method to get effect
 */

var makeProxy = function makeProxy(e) {
    var proxy = {};

    for (var key in e) {
        if (typeof e[key] === "function") {
            proxy[key] = e[key].bind(e);
        } else {
            proxy[key] = e[key];
        }
    }

    return proxy;
};

var bodyListener = function bodyListener(callback, options, e) {
    var _options$respectEffec = options.respectEffect,
        respectEffect = _options$respectEffec === void 0 ? false : _options$respectEffec,
        _options$customEvent = options.customEvent,
        customEvent = _options$customEvent === void 0 ? false : _options$customEvent;
    var id = this.props.id;
    var tip = e.target.getAttribute("data-tip") || null;
    var forId = e.target.getAttribute("data-for") || null;
    var target = e.target;

    if (this.isCustomEvent(target) && !customEvent) {
        return;
    }

    var isTargetBelongsToTooltip = id == null && forId == null || forId === id;

    if (tip != null && (!respectEffect || this.getEffect(target) === "float") && isTargetBelongsToTooltip) {
        var proxy = makeProxy(e);
        proxy.currentTarget = target;
        callback(proxy);
    }
};

var findCustomEvents = function findCustomEvents(targetArray, dataAttribute) {
    var events = {};
    targetArray.forEach(function(target) {
        var event = target.getAttribute(dataAttribute);
        if (event) event.split(" ").forEach(function(event) {
            return events[event] = true;
        });
    });
    return events;
};

var getBody = function getBody() {
    return document.getElementsByTagName("body")[0];
};

function bodyMode(target) {
    target.prototype.isBodyMode = function() {
        return !!this.props.bodyMode;
    };

    target.prototype.bindBodyListener = function(targetArray) {
        var _this = this;

        var _this$state = this.state,
            event = _this$state.event,
            eventOff = _this$state.eventOff,
            possibleCustomEvents = _this$state.possibleCustomEvents,
            possibleCustomEventsOff = _this$state.possibleCustomEventsOff;
        var body = getBody();
        var customEvents = findCustomEvents(targetArray, "data-event");
        var customEventsOff = findCustomEvents(targetArray, "data-event-off");
        if (event != null) customEvents[event] = true;
        if (eventOff != null) customEventsOff[eventOff] = true;
        possibleCustomEvents.split(" ").forEach(function(event) {
            return customEvents[event] = true;
        });
        possibleCustomEventsOff.split(" ").forEach(function(event) {
            return customEventsOff[event] = true;
        });
        this.unbindBodyListener(body);
        var listeners = this.bodyModeListeners = {};

        if (event == null) {
            listeners.mouseover = bodyListener.bind(this, this.showTooltip, {});
            listeners.mousemove = bodyListener.bind(this, this.updateTooltip, {
                respectEffect: true
            });
            listeners.mouseout = bodyListener.bind(this, this.hideTooltip, {});
        }

        for (var _event in customEvents) {
            listeners[_event] = bodyListener.bind(this, function(e) {
                var targetEventOff = e.currentTarget.getAttribute("data-event-off") || eventOff;
                checkStatus.call(_this, targetEventOff, e);
            }, {
                customEvent: true
            });
        }

        for (var _event2 in customEventsOff) {
            listeners[_event2] = bodyListener.bind(this, this.hideTooltip, {
                customEvent: true
            });
        }

        for (var _event3 in listeners) {
            body.addEventListener(_event3, listeners[_event3]);
        }
    };

    target.prototype.unbindBodyListener = function(body) {
        body = body || getBody();
        var listeners = this.bodyModeListeners;

        for (var event in listeners) {
            body.removeEventListener(event, listeners[event]);
        }
    };
}

/**
 * Tracking target removing from DOM.
 * It's necessary to hide tooltip when it's target disappears.
 * Otherwise, the tooltip would be shown forever until another target
 * is triggered.
 *
 * If MutationObserver is not available, this feature just doesn't work.
 */
// https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/
var getMutationObserverClass = function getMutationObserverClass() {
    return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
};

function trackRemoval(target) {
    target.prototype.bindRemovalTracker = function() {
        var _this = this;

        var MutationObserver = getMutationObserverClass();
        if (MutationObserver == null) return;
        var observer = new MutationObserver(function(mutations) {
            for (var m1 = 0; m1 < mutations.length; m1++) {
                var mutation = mutations[m1];

                for (var m2 = 0; m2 < mutation.removedNodes.length; m2++) {
                    var element = mutation.removedNodes[m2];

                    if (element === _this.state.currentTarget) {
                        _this.hideTooltip();

                        return;
                    }
                }
            }
        });
        observer.observe(window.document, {
            childList: true,
            subtree: true
        });
        this.removalTracker = observer;
    };

    target.prototype.unbindRemovalTracker = function() {
        if (this.removalTracker) {
            this.removalTracker.disconnect();
            this.removalTracker = null;
        }
    };
}

/**
 * Calculate the position of tooltip
 *
 * @params
 * - `e` {Event} the event of current mouse
 * - `target` {Element} the currentTarget of the event
 * - `node` {DOM} the react-tooltip object
 * - `place` {String} top / right / bottom / left
 * - `effect` {String} float / solid
 * - `offset` {Object} the offset to default position
 *
 * @return {Object}
 * - `isNewState` {Bool} required
 * - `newState` {Object}
 * - `position` {Object} {left: {Number}, top: {Number}}
 */
function getPosition(e, target, node, place, desiredPlace, effect, offset) {
    var _getDimensions = getDimensions(node),
        tipWidth = _getDimensions.width,
        tipHeight = _getDimensions.height;

    var _getDimensions2 = getDimensions(target),
        targetWidth = _getDimensions2.width,
        targetHeight = _getDimensions2.height;

    var _getCurrentOffset = getCurrentOffset(e, target, effect),
        mouseX = _getCurrentOffset.mouseX,
        mouseY = _getCurrentOffset.mouseY;

    var defaultOffset = getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight);

    var _calculateOffset = calculateOffset(offset),
        extraOffset_X = _calculateOffset.extraOffset_X,
        extraOffset_Y = _calculateOffset.extraOffset_Y;

    var windowWidth = window.innerWidth;
    var windowHeight = window.innerHeight;

    var _getParent = getParent(node),
        parentTop = _getParent.parentTop,
        parentLeft = _getParent.parentLeft; // Get the edge offset of the tooltip


    var getTipOffsetLeft = function getTipOffsetLeft(place) {
        var offset_X = defaultOffset[place].l;
        return mouseX + offset_X + extraOffset_X;
    };

    var getTipOffsetRight = function getTipOffsetRight(place) {
        var offset_X = defaultOffset[place].r;
        return mouseX + offset_X + extraOffset_X;
    };

    var getTipOffsetTop = function getTipOffsetTop(place) {
        var offset_Y = defaultOffset[place].t;
        return mouseY + offset_Y + extraOffset_Y;
    };

    var getTipOffsetBottom = function getTipOffsetBottom(place) {
        var offset_Y = defaultOffset[place].b;
        return mouseY + offset_Y + extraOffset_Y;
    }; //
    // Functions to test whether the tooltip's sides are inside
    // the client window for a given orientation p
    //
    //  _____________
    // |             | <-- Right side
    // | p = 'left'  |\
    // |             |/  |\
    // |_____________|   |_\  <-- Mouse
    //      / \           |
    //       |
    //       |
    //  Bottom side
    //


    var outsideLeft = function outsideLeft(p) {
        return getTipOffsetLeft(p) < 0;
    };

    var outsideRight = function outsideRight(p) {
        return getTipOffsetRight(p) > windowWidth;
    };

    var outsideTop = function outsideTop(p) {
        return getTipOffsetTop(p) < 0;
    };

    var outsideBottom = function outsideBottom(p) {
        return getTipOffsetBottom(p) > windowHeight;
    }; // Check whether the tooltip with orientation p is completely inside the client window


    var outside = function outside(p) {
        return outsideLeft(p) || outsideRight(p) || outsideTop(p) || outsideBottom(p);
    };

    var inside = function inside(p) {
        return !outside(p);
    };

    var placesList = ["top", "bottom", "left", "right"];
    var insideList = [];

    for (var i = 0; i < 4; i++) {
        var p = placesList[i];

        if (inside(p)) {
            insideList.push(p);
        }
    }

    var isNewState = false;
    var newPlace;
    var shouldUpdatePlace = desiredPlace !== place;

    if (inside(desiredPlace) && shouldUpdatePlace) {
        isNewState = true;
        newPlace = desiredPlace;
    } else if (insideList.length > 0 && shouldUpdatePlace && outside(desiredPlace) && outside(place)) {
        isNewState = true;
        newPlace = insideList[0];
    }

    if (isNewState) {
        return {
            isNewState: true,
            newState: {
                place: newPlace
            }
        };
    }

    return {
        isNewState: false,
        position: {
            left: parseInt(getTipOffsetLeft(place) - parentLeft, 10),
            top: parseInt(getTipOffsetTop(place) - parentTop, 10)
        }
    };
}

var getDimensions = function getDimensions(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(),
        height = _node$getBoundingClie.height,
        width = _node$getBoundingClie.width;

    return {
        height: parseInt(height, 10),
        width: parseInt(width, 10)
    };
}; // Get current mouse offset


var getCurrentOffset = function getCurrentOffset(e, currentTarget, effect) {
    var boundingClientRect = currentTarget.getBoundingClientRect();
    var targetTop = boundingClientRect.top;
    var targetLeft = boundingClientRect.left;

    var _getDimensions3 = getDimensions(currentTarget),
        targetWidth = _getDimensions3.width,
        targetHeight = _getDimensions3.height;

    if (effect === "float") {
        return {
            mouseX: e.clientX,
            mouseY: e.clientY
        };
    }

    return {
        mouseX: targetLeft + targetWidth / 2,
        mouseY: targetTop + targetHeight / 2
    };
}; // List all possibility of tooltip final offset
// This is useful in judging if it is necessary for tooltip to switch position when out of window


var getDefaultPosition = function getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight) {
    var top;
    var right;
    var bottom;
    var left;
    var disToMouse = 3;
    var triangleHeight = 2;
    var cursorHeight = 12; // Optimize for float bottom only, cause the cursor will hide the tooltip

    if (effect === "float") {
        top = {
            l: -(tipWidth / 2),
            r: tipWidth / 2,
            t: -(tipHeight + disToMouse + triangleHeight),
            b: -disToMouse
        };
        bottom = {
            l: -(tipWidth / 2),
            r: tipWidth / 2,
            t: disToMouse + cursorHeight,
            b: tipHeight + disToMouse + triangleHeight + cursorHeight
        };
        left = {
            l: -(tipWidth + disToMouse + triangleHeight),
            r: -disToMouse,
            t: -(tipHeight / 2),
            b: tipHeight / 2
        };
        right = {
            l: disToMouse,
            r: tipWidth + disToMouse + triangleHeight,
            t: -(tipHeight / 2),
            b: tipHeight / 2
        };
    } else if (effect === "solid") {
        top = {
            l: -(tipWidth / 2),
            r: tipWidth / 2,
            t: -(targetHeight / 2 + tipHeight + triangleHeight),
            b: -(targetHeight / 2)
        };
        bottom = {
            l: -(tipWidth / 2),
            r: tipWidth / 2,
            t: targetHeight / 2,
            b: targetHeight / 2 + tipHeight + triangleHeight
        };
        left = {
            l: -(tipWidth + targetWidth / 2 + triangleHeight),
            r: -(targetWidth / 2),
            t: -(tipHeight / 2),
            b: tipHeight / 2
        };
        right = {
            l: targetWidth / 2,
            r: tipWidth + targetWidth / 2 + triangleHeight,
            t: -(tipHeight / 2),
            b: tipHeight / 2
        };
    }

    return {
        top: top,
        bottom: bottom,
        left: left,
        right: right
    };
}; // Consider additional offset into position calculation


var calculateOffset = function calculateOffset(offset) {
    var extraOffset_X = 0;
    var extraOffset_Y = 0;

    if (Object.prototype.toString.apply(offset) === "[object String]") {
        offset = JSON.parse(offset.toString().replace(/\'/g, '"'));
    }

    for (var key in offset) {
        if (key === "top") {
            extraOffset_Y -= parseInt(offset[key], 10);
        } else if (key === "bottom") {
            extraOffset_Y += parseInt(offset[key], 10);
        } else if (key === "left") {
            extraOffset_X -= parseInt(offset[key], 10);
        } else if (key === "right") {
            extraOffset_X += parseInt(offset[key], 10);
        }
    }

    return {
        extraOffset_X: extraOffset_X,
        extraOffset_Y: extraOffset_Y
    };
}; // Get the offset of the parent elements


var getParent = function getParent(currentTarget) {
    var currentParent = currentTarget;

    while (currentParent) {
        if (window.getComputedStyle(currentParent).getPropertyValue("transform") !== "none") break;
        currentParent = currentParent.parentElement;
    }

    var parentTop = currentParent && currentParent.getBoundingClientRect().top || 0;
    var parentLeft = currentParent && currentParent.getBoundingClientRect().left || 0;
    return {
        parentTop: parentTop,
        parentLeft: parentLeft
    };
};

/**
 * To get the tooltip content
 * it may comes from data-tip or this.props.children
 * it should support multiline
 *
 * @params
 * - `tip` {String} value of data-tip
 * - `children` {ReactElement} this.props.children
 * - `multiline` {Any} could be Bool(true/false) or String('true'/'false')
 *
 * @return
 * - String or react component
 */
function getTipContent(tip, children, getContent, multiline) {
    if (children) return children;
    if (getContent !== undefined && getContent !== null) return getContent; // getContent can be 0, '', etc.

    if (getContent === null) return null; // Tip not exist and children is null or undefined

    var regexp = /<br\s*\/?>/;

    if (!multiline || multiline === "false" || !regexp.test(tip)) {
        // No trim(), so that user can keep their input
        return tip;
    } // Multiline tooltip content


    return tip.split(regexp).map(function(d, i) {
        return React.createElement("span", {
            key: i,
            className: "multi-line"
        }, d);
    });
}

/**
 * Support aria- and role in ReactTooltip
 *
 * @params props {Object}
 * @return {Object}
 */
function parseAria(props) {
    var ariaObj = {};
    Object.keys(props).filter(function(prop) {
        // aria-xxx and role is acceptable
        return /(^aria-\w+$|^role$)/.test(prop);
    }).forEach(function(prop) {
        ariaObj[prop] = props[prop];
    });
    return ariaObj;
}

/**
 * Convert nodelist to array
 * @see https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/core/createArrayFromMixed.js#L24
 * NodeLists are functions in Safari
 */
function nodeListToArray(nodeList) {
    var length = nodeList.length;

    if (nodeList.hasOwnProperty) {
        return Array.prototype.slice.call(nodeList);
    }

    return new Array(length).fill().map(function(index) {
        return nodeList[index];
    });
}

___$insertStyle(".__react_component_tooltip {\n  border-radius: 3px;\n  display: inline-block;\n  font-size: 13px;\n  left: -999em;\n  opacity: 0;\n  padding: 8px 21px;\n  position: fixed;\n  pointer-events: none;\n  transition: opacity 0.3s ease-out;\n  top: -999em;\n  visibility: hidden;\n  z-index: 999;\n}\n.__react_component_tooltip.allow_hover, .__react_component_tooltip.allow_click {\n  pointer-events: auto;\n}\n.__react_component_tooltip:before, .__react_component_tooltip:after {\n  content: \"\";\n  width: 0;\n  height: 0;\n  position: absolute;\n}\n.__react_component_tooltip.show {\n  opacity: 0.9;\n  margin-top: 0px;\n  margin-left: 0px;\n  visibility: visible;\n}\n.__react_component_tooltip.type-dark {\n  color: #fff;\n  background-color: #222;\n}\n.__react_component_tooltip.type-dark.place-top:after {\n  border-top-color: #222;\n  border-top-style: solid;\n  border-top-width: 6px;\n}\n.__react_component_tooltip.type-dark.place-bottom:after {\n  border-bottom-color: #222;\n  border-bottom-style: solid;\n  border-bottom-width: 6px;\n}\n.__react_component_tooltip.type-dark.place-left:after {\n  border-left-color: #222;\n  border-left-style: solid;\n  border-left-width: 6px;\n}\n.__react_component_tooltip.type-dark.place-right:after {\n  border-right-color: #222;\n  border-right-style: solid;\n  border-right-width: 6px;\n}\n.__react_component_tooltip.type-dark.border {\n  border: 1px solid #fff;\n}\n.__react_component_tooltip.type-dark.border.place-top:before {\n  border-top: 8px solid #fff;\n}\n.__react_component_tooltip.type-dark.border.place-bottom:before {\n  border-bottom: 8px solid #fff;\n}\n.__react_component_tooltip.type-dark.border.place-left:before {\n  border-left: 8px solid #fff;\n}\n.__react_component_tooltip.type-dark.border.place-right:before {\n  border-right: 8px solid #fff;\n}\n.__react_component_tooltip.type-success {\n  color: #fff;\n  background-color: #8DC572;\n}\n.__react_component_tooltip.type-success.place-top:after {\n  border-top-color: #8DC572;\n  border-top-style: solid;\n  border-top-width: 6px;\n}\n.__react_component_tooltip.type-success.place-bottom:after {\n  border-bottom-color: #8DC572;\n  border-bottom-style: solid;\n  border-bottom-width: 6px;\n}\n.__react_component_tooltip.type-success.place-left:after {\n  border-left-color: #8DC572;\n  border-left-style: solid;\n  border-left-width: 6px;\n}\n.__react_component_tooltip.type-success.place-right:after {\n  border-right-color: #8DC572;\n  border-right-style: solid;\n  border-right-width: 6px;\n}\n.__react_component_tooltip.type-success.border {\n  border: 1px solid #fff;\n}\n.__react_component_tooltip.type-success.border.place-top:before {\n  border-top: 8px solid #fff;\n}\n.__react_component_tooltip.type-success.border.place-bottom:before {\n  border-bottom: 8px solid #fff;\n}\n.__react_component_tooltip.type-success.border.place-left:before {\n  border-left: 8px solid #fff;\n}\n.__react_component_tooltip.type-success.border.place-right:before {\n  border-right: 8px solid #fff;\n}\n.__react_component_tooltip.type-warning {\n  color: #fff;\n  background-color: #F0AD4E;\n}\n.__react_component_tooltip.type-warning.place-top:after {\n  border-top-color: #F0AD4E;\n  border-top-style: solid;\n  border-top-width: 6px;\n}\n.__react_component_tooltip.type-warning.place-bottom:after {\n  border-bottom-color: #F0AD4E;\n  border-bottom-style: solid;\n  border-bottom-width: 6px;\n}\n.__react_component_tooltip.type-warning.place-left:after {\n  border-left-color: #F0AD4E;\n  border-left-style: solid;\n  border-left-width: 6px;\n}\n.__react_component_tooltip.type-warning.place-right:after {\n  border-right-color: #F0AD4E;\n  border-right-style: solid;\n  border-right-width: 6px;\n}\n.__react_component_tooltip.type-warning.border {\n  border: 1px solid #fff;\n}\n.__react_component_tooltip.type-warning.border.place-top:before {\n  border-top: 8px solid #fff;\n}\n.__react_component_tooltip.type-warning.border.place-bottom:before {\n  border-bottom: 8px solid #fff;\n}\n.__react_component_tooltip.type-warning.border.place-left:before {\n  border-left: 8px solid #fff;\n}\n.__react_component_tooltip.type-warning.border.place-right:before {\n  border-right: 8px solid #fff;\n}\n.__react_component_tooltip.type-error {\n  color: #fff;\n  background-color: #BE6464;\n}\n.__react_component_tooltip.type-error.place-top:after {\n  border-top-color: #BE6464;\n  border-top-style: solid;\n  border-top-width: 6px;\n}\n.__react_component_tooltip.type-error.place-bottom:after {\n  border-bottom-color: #BE6464;\n  border-bottom-style: solid;\n  border-bottom-width: 6px;\n}\n.__react_component_tooltip.type-error.place-left:after {\n  border-left-color: #BE6464;\n  border-left-style: solid;\n  border-left-width: 6px;\n}\n.__react_component_tooltip.type-error.place-right:after {\n  border-right-color: #BE6464;\n  border-right-style: solid;\n  border-right-width: 6px;\n}\n.__react_component_tooltip.type-error.border {\n  border: 1px solid #fff;\n}\n.__react_component_tooltip.type-error.border.place-top:before {\n  border-top: 8px solid #fff;\n}\n.__react_component_tooltip.type-error.border.place-bottom:before {\n  border-bottom: 8px solid #fff;\n}\n.__react_component_tooltip.type-error.border.place-left:before {\n  border-left: 8px solid #fff;\n}\n.__react_component_tooltip.type-error.border.place-right:before {\n  border-right: 8px solid #fff;\n}\n.__react_component_tooltip.type-info {\n  color: #fff;\n  background-color: #337AB7;\n}\n.__react_component_tooltip.type-info.place-top:after {\n  border-top-color: #337AB7;\n  border-top-style: solid;\n  border-top-width: 6px;\n}\n.__react_component_tooltip.type-info.place-bottom:after {\n  border-bottom-color: #337AB7;\n  border-bottom-style: solid;\n  border-bottom-width: 6px;\n}\n.__react_component_tooltip.type-info.place-left:after {\n  border-left-color: #337AB7;\n  border-left-style: solid;\n  border-left-width: 6px;\n}\n.__react_component_tooltip.type-info.place-right:after {\n  border-right-color: #337AB7;\n  border-right-style: solid;\n  border-right-width: 6px;\n}\n.__react_component_tooltip.type-info.border {\n  border: 1px solid #fff;\n}\n.__react_component_tooltip.type-info.border.place-top:before {\n  border-top: 8px solid #fff;\n}\n.__react_component_tooltip.type-info.border.place-bottom:before {\n  border-bottom: 8px solid #fff;\n}\n.__react_component_tooltip.type-info.border.place-left:before {\n  border-left: 8px solid #fff;\n}\n.__react_component_tooltip.type-info.border.place-right:before {\n  border-right: 8px solid #fff;\n}\n.__react_component_tooltip.type-light {\n  color: #222;\n  background-color: #fff;\n}\n.__react_component_tooltip.type-light.place-top:after {\n  border-top-color: #fff;\n  border-top-style: solid;\n  border-top-width: 6px;\n}\n.__react_component_tooltip.type-light.place-bottom:after {\n  border-bottom-color: #fff;\n  border-bottom-style: solid;\n  border-bottom-width: 6px;\n}\n.__react_component_tooltip.type-light.place-left:after {\n  border-left-color: #fff;\n  border-left-style: solid;\n  border-left-width: 6px;\n}\n.__react_component_tooltip.type-light.place-right:after {\n  border-right-color: #fff;\n  border-right-style: solid;\n  border-right-width: 6px;\n}\n.__react_component_tooltip.type-light.border {\n  border: 1px solid #222;\n}\n.__react_component_tooltip.type-light.border.place-top:before {\n  border-top: 8px solid #222;\n}\n.__react_component_tooltip.type-light.border.place-bottom:before {\n  border-bottom: 8px solid #222;\n}\n.__react_component_tooltip.type-light.border.place-left:before {\n  border-left: 8px solid #222;\n}\n.__react_component_tooltip.type-light.border.place-right:before {\n  border-right: 8px solid #222;\n}\n.__react_component_tooltip.place-top {\n  margin-top: -10px;\n}\n.__react_component_tooltip.place-top:before {\n  border-left: 10px solid transparent;\n  border-right: 10px solid transparent;\n  bottom: -8px;\n  left: 50%;\n  margin-left: -10px;\n}\n.__react_component_tooltip.place-top:after {\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  bottom: -6px;\n  left: 50%;\n  margin-left: -8px;\n}\n.__react_component_tooltip.place-bottom {\n  margin-top: 10px;\n}\n.__react_component_tooltip.place-bottom:before {\n  border-left: 10px solid transparent;\n  border-right: 10px solid transparent;\n  top: -8px;\n  left: 50%;\n  margin-left: -10px;\n}\n.__react_component_tooltip.place-bottom:after {\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  top: -6px;\n  left: 50%;\n  margin-left: -8px;\n}\n.__react_component_tooltip.place-left {\n  margin-left: -10px;\n}\n.__react_component_tooltip.place-left:before {\n  border-top: 6px solid transparent;\n  border-bottom: 6px solid transparent;\n  right: -8px;\n  top: 50%;\n  margin-top: -5px;\n}\n.__react_component_tooltip.place-left:after {\n  border-top: 5px solid transparent;\n  border-bottom: 5px solid transparent;\n  right: -6px;\n  top: 50%;\n  margin-top: -4px;\n}\n.__react_component_tooltip.place-right {\n  margin-left: 10px;\n}\n.__react_component_tooltip.place-right:before {\n  border-top: 6px solid transparent;\n  border-bottom: 6px solid transparent;\n  left: -8px;\n  top: 50%;\n  margin-top: -5px;\n}\n.__react_component_tooltip.place-right:after {\n  border-top: 5px solid transparent;\n  border-bottom: 5px solid transparent;\n  left: -6px;\n  top: 50%;\n  margin-top: -4px;\n}\n.__react_component_tooltip .multi-line {\n  display: block;\n  padding: 2px 0px;\n  text-align: center;\n}");

var _class, _class2, _temp;

var ReactTooltip = staticMethods(_class = windowListener(_class = customEvent(_class = isCapture(_class = getEffect(_class = bodyMode(_class = trackRemoval(_class = (_temp = _class2 =
    /*#__PURE__*/
    function(_React$Component) {
        _inherits(ReactTooltip, _React$Component);

        function ReactTooltip(props) {
            var _this;

            _classCallCheck(this, ReactTooltip);

            _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactTooltip).call(this, props));
            _this.state = {
                place: props.place || "top",
                // Direction of tooltip
                desiredPlace: props.place || "top",
                type: "dark",
                // Color theme of tooltip
                effect: "float",
                // float or fixed
                show: false,
                border: false,
                offset: {},
                extraClass: "",
                html: false,
                delayHide: 0,
                delayShow: 0,
                event: props.event || null,
                eventOff: props.eventOff || null,
                currentEvent: null,
                // Current mouse event
                currentTarget: null,
                // Current target of mouse event
                ariaProps: parseAria(props),
                // aria- and role attributes
                isEmptyTip: false,
                disable: false,
                possibleCustomEvents: props.possibleCustomEvents || "",
                possibleCustomEventsOff: props.possibleCustomEventsOff || "",
                originTooltip: null,
                isMultiline: false
            };

            _this.bind(["showTooltip", "updateTooltip", "hideTooltip", "hideTooltipOnScroll", "getTooltipContent", "globalRebuild", "globalShow", "globalHide", "onWindowResize", "mouseOnToolTip"]);

            _this.mount = true;
            _this.delayShowLoop = null;
            _this.delayHideLoop = null;
            _this.delayReshow = null;
            _this.intervalUpdateContent = null;
            return _this;
        }
        /**
         * For unify the bind and unbind listener
         */


        _createClass(ReactTooltip, [{
            key: "bind",
            value: function bind(methodArray) {
                var _this2 = this;

                methodArray.forEach(function(method) {
                    _this2[method] = _this2[method].bind(_this2);
                });
            }
        }, {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this$props = this.props,
                    insecure = _this$props.insecure,
                    resizeHide = _this$props.resizeHide;

                this.bindListener(); // Bind listener for tooltip

                this.bindWindowEvents(resizeHide); // Bind global event for static method
            }
        }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this.mount = false;
                this.clearTimer();
                this.unbindListener();
                this.removeScrollListener();
                this.unbindWindowEvents();
            }
            /**
             * Return if the mouse is on the tooltip.
             * @returns {boolean} true - mouse is on the tooltip
             */

        }, {
            key: "mouseOnToolTip",
            value: function mouseOnToolTip() {
                var show = this.state.show;

                if (show && this.tooltipRef) {
                    /* old IE or Firefox work around */
                    if (!this.tooltipRef.matches) {
                        /* old IE work around */
                        if (this.tooltipRef.msMatchesSelector) {
                            this.tooltipRef.matches = this.tooltipRef.msMatchesSelector;
                        } else {
                            /* old Firefox work around */
                            this.tooltipRef.matches = this.tooltipRef.mozMatchesSelector;
                        }
                    }

                    return this.tooltipRef.matches(":hover");
                }

                return false;
            }
            /**
             * Pick out corresponded target elements
             */

        }, {
            key: "getTargetArray",
            value: function getTargetArray(id) {
                var targetArray;

                if (!id) {
                    targetArray = document.querySelectorAll("[data-tip]:not([data-for])");
                } else {
                    var escaped = id.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
                    targetArray = document.querySelectorAll("[data-tip][data-for=\"".concat(escaped, "\"]"));
                } // targetArray is a NodeList, convert it to a real array


                return nodeListToArray(targetArray);
            }
            /**
             * Bind listener to the target elements
             * These listeners used to trigger showing or hiding the tooltip
             */

        }, {
            key: "bindListener",
            value: function bindListener() {
                var _this3 = this;

                var _this$props2 = this.props,
                    id = _this$props2.id,
                    globalEventOff = _this$props2.globalEventOff,
                    isCapture = _this$props2.isCapture;
                var targetArray = this.getTargetArray(id);
                targetArray.forEach(function(target) {
                    if (target.getAttribute("currentItem") === null) {
                        target.setAttribute("currentItem", "false");
                    }

                    _this3.unbindBasicListener(target);

                    if (_this3.isCustomEvent(target)) {
                        _this3.customUnbindListener(target);
                    }
                });

                if (this.isBodyMode()) {
                    this.bindBodyListener(targetArray);
                } else {
                    targetArray.forEach(function(target) {
                        var isCaptureMode = _this3.isCapture(target);

                        var effect = _this3.getEffect(target);

                        if (_this3.isCustomEvent(target)) {
                            _this3.customBindListener(target);

                            return;
                        }

                        target.addEventListener("mouseenter", _this3.showTooltip, isCaptureMode);

                        if (effect === "float") {
                            target.addEventListener("mousemove", _this3.updateTooltip, isCaptureMode);
                        }

                        target.addEventListener("mouseleave", _this3.hideTooltip, isCaptureMode);
                    });
                } // Global event to hide tooltip


                if (globalEventOff) {
                    window.removeEventListener(globalEventOff, this.hideTooltip);
                    window.addEventListener(globalEventOff, this.hideTooltip, isCapture);
                } // Track removal of targetArray elements from DOM


                this.bindRemovalTracker();
            }
            /**
             * Unbind listeners on target elements
             */

        }, {
            key: "unbindListener",
            value: function unbindListener() {
                var _this4 = this;

                var _this$props3 = this.props,
                    id = _this$props3.id,
                    globalEventOff = _this$props3.globalEventOff;

                if (this.isBodyMode()) {
                    this.unbindBodyListener();
                } else {
                    var targetArray = this.getTargetArray(id);
                    targetArray.forEach(function(target) {
                        _this4.unbindBasicListener(target);

                        if (_this4.isCustomEvent(target)) _this4.customUnbindListener(target);
                    });
                }

                if (globalEventOff) window.removeEventListener(globalEventOff, this.hideTooltip);
                this.unbindRemovalTracker();
            }
            /**
             * Invoke this before bind listener and unmount the component
             * it is necessary to invoke this even when binding custom event
             * so that the tooltip can switch between custom and default listener
             */

        }, {
            key: "unbindBasicListener",
            value: function unbindBasicListener(target) {
                var isCaptureMode = this.isCapture(target);
                target.removeEventListener("mouseenter", this.showTooltip, isCaptureMode);
                target.removeEventListener("mousemove", this.updateTooltip, isCaptureMode);
                target.removeEventListener("mouseleave", this.hideTooltip, isCaptureMode);
            }
        }, {
            key: "getTooltipContent",
            value: function getTooltipContent() {
                var _this$props4 = this.props,
                    getContent = _this$props4.getContent,
                    children = _this$props4.children; // Generate tooltip content

                var content;

                if (getContent) {
                    if (Array.isArray(getContent)) {
                        content = getContent[0] && getContent[0](this.state.originTooltip);
                    } else {
                        content = getContent(this.state.originTooltip);
                    }
                }

                return getTipContent(this.state.originTooltip, children, content, this.state.isMultiline);
            }
        }, {
            key: "isEmptyTip",
            value: function isEmptyTip(placeholder) {
                return typeof placeholder === "string" && placeholder === "" || placeholder === null;
            }
            /**
             * When mouse enter, show the tooltip
             */

        }, {
            key: "showTooltip",
            value: function showTooltip(e, isGlobalCall) {
                if (isGlobalCall) {
                    // Don't trigger other elements belongs to other ReactTooltip
                    var targetArray = this.getTargetArray(this.props.id);
                    var isMyElement = targetArray.some(function(ele) {
                        return ele === e.currentTarget;
                    });
                    if (!isMyElement) return;
                } // Get the tooltip content
                // calculate in this phrase so that tip width height can be detected


                var _this$props5 = this.props,
                    multiline = _this$props5.multiline,
                    getContent = _this$props5.getContent;
                var originTooltip = e.currentTarget.getAttribute("data-tip");
                var isMultiline = e.currentTarget.getAttribute("data-multiline") || multiline || false; // If it is focus event or called by ReactTooltip.show, switch to `solid` effect

                var switchToSolid = e instanceof window.FocusEvent || isGlobalCall; // if it needs to skip adding hide listener to scroll

                var scrollHide = true;

                if (e.currentTarget.getAttribute("data-scroll-hide")) {
                    scrollHide = e.currentTarget.getAttribute("data-scroll-hide") === "true";
                } else if (this.props.scrollHide != null) {
                    scrollHide = this.props.scrollHide;
                } // Make sure the correct place is set


                var desiredPlace = e.currentTarget.getAttribute("data-place") || this.props.place || "top";
                var effect = switchToSolid && "solid" || this.getEffect(e.currentTarget);
                var offset = e.currentTarget.getAttribute("data-offset") || this.props.offset || {};
                var result = getPosition(e, e.currentTarget, this.tooltipRef, desiredPlace, desiredPlace, effect, offset);

                if (result.position && this.props.overridePosition) {
                    result.position = this.props.overridePosition(result.position, e.currentTarget, this.tooltipRef, desiredPlace, desiredPlace, effect, offset);
                }

                var place = result.isNewState ? result.newState.place : desiredPlace; // To prevent previously created timers from triggering

                this.clearTimer();
                var target = e.currentTarget;
                var reshowDelay = this.state.show ? target.getAttribute("data-delay-update") || this.props.delayUpdate : 0;
                var self = this;

                var updateState = function updateState() {
                    self.setState({
                        originTooltip: originTooltip,
                        isMultiline: isMultiline,
                        desiredPlace: desiredPlace,
                        place: place,
                        type: target.getAttribute("data-type") || self.props.type || "dark",
                        effect: effect,
                        offset: offset,
                        html: target.getAttribute("data-html") ? target.getAttribute("data-html") === "true" : self.props.html || false,
                        delayShow: target.getAttribute("data-delay-show") || self.props.delayShow || 0,
                        delayHide: target.getAttribute("data-delay-hide") || self.props.delayHide || 0,
                        delayUpdate: target.getAttribute("data-delay-update") || self.props.delayUpdate || 0,
                        border: target.getAttribute("data-border") ? target.getAttribute("data-border") === "true" : self.props.border || false,
                        extraClass: target.getAttribute("data-class") || self.props["class"] || self.props.className || "",
                        disable: target.getAttribute("data-tip-disable") ? target.getAttribute("data-tip-disable") === "true" : self.props.disable || false,
                        currentTarget: target
                    }, function() {
                        if (scrollHide) self.addScrollListener(self.state.currentTarget);
                        self.updateTooltip(e);

                        if (getContent && Array.isArray(getContent)) {
                            self.intervalUpdateContent = setInterval(function() {
                                if (self.mount) {
                                    var _getContent = self.props.getContent;
                                    var placeholder = getTipContent(originTooltip, "", _getContent[0](), isMultiline);
                                    var isEmptyTip = self.isEmptyTip(placeholder);
                                    self.setState({
                                        isEmptyTip: isEmptyTip
                                    });
                                    self.updatePosition();
                                }
                            }, getContent[1]);
                        }
                    });
                }; // If there is no delay call immediately, don't allow events to get in first.


                if (reshowDelay) {
                    this.delayReshow = setTimeout(updateState, reshowDelay);
                } else {
                    updateState();
                }
            }
            /**
             * When mouse hover, update tool tip
             */

        }, {
            key: "updateTooltip",
            value: function updateTooltip(e) {
                var _this5 = this;

                var _this$state = this.state,
                    delayShow = _this$state.delayShow,
                    disable = _this$state.disable;
                var afterShow = this.props.afterShow;
                var placeholder = this.getTooltipContent();
                var delayTime = parseInt(delayShow, 10);
                var eventTarget = e.currentTarget || e.target; // Check if the mouse is actually over the tooltip, if so don't hide the tooltip

                if (this.mouseOnToolTip()) {
                    return;
                }

                if (this.isEmptyTip(placeholder) || disable) return; // if the tooltip is empty, disable the tooltip

                var updateState = function updateState() {
                    if (Array.isArray(placeholder) && placeholder.length > 0 || placeholder) {
                        var isInvisible = !_this5.state.show;

                        _this5.setState({
                            currentEvent: e,
                            currentTarget: eventTarget,
                            show: true
                        }, function() {
                            _this5.updatePosition();

                            if (isInvisible && afterShow) afterShow(e);
                        });
                    }
                };

                clearTimeout(this.delayShowLoop);

                if (delayShow) {
                    this.delayShowLoop = setTimeout(updateState, delayTime);
                } else {
                    updateState();
                }
            }
            /*
             * If we're mousing over the tooltip remove it when we leave.
             */

        }, {
            key: "listenForTooltipExit",
            value: function listenForTooltipExit() {
                var show = this.state.show;

                if (show && this.tooltipRef) {
                    this.tooltipRef.addEventListener("mouseleave", this.hideTooltip);
                }
            }
        }, {
            key: "removeListenerForTooltipExit",
            value: function removeListenerForTooltipExit() {
                var show = this.state.show;

                if (show && this.tooltipRef) {
                    this.tooltipRef.removeEventListener("mouseleave", this.hideTooltip);
                }
            }
            /**
             * When mouse leave, hide tooltip
             */

        }, {
            key: "hideTooltip",
            value: function hideTooltip(e, hasTarget) {
                var _this6 = this;

                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
                    isScroll: false
                };
                var disable = this.state.disable;
                var isScroll = options.isScroll;
                var delayHide = isScroll ? 0 : this.state.delayHide;
                var afterHide = this.props.afterHide;
                var placeholder = this.getTooltipContent();
                if (!this.mount) return;
                if (this.isEmptyTip(placeholder) || disable) return; // if the tooltip is empty, disable the tooltip

                if (hasTarget) {
                    // Don't trigger other elements belongs to other ReactTooltip
                    var targetArray = this.getTargetArray(this.props.id);
                    var isMyElement = targetArray.some(function(ele) {
                        return ele === e.currentTarget;
                    });
                    if (!isMyElement || !this.state.show) return;
                }

                var resetState = function resetState() {
                    var isVisible = _this6.state.show; // Check if the mouse is actually over the tooltip, if so don't hide the tooltip

                    if (_this6.mouseOnToolTip()) {
                        _this6.listenForTooltipExit();

                        return;
                    }

                    _this6.removeListenerForTooltipExit();

                    _this6.setState({
                        show: false
                    }, function() {
                        _this6.removeScrollListener();

                        if (isVisible && afterHide) afterHide(e);
                    });
                };

                this.clearTimer();

                if (delayHide) {
                    this.delayHideLoop = setTimeout(resetState, parseInt(delayHide, 10));
                } else {
                    resetState();
                }
            }
            /**
             * When scroll, hide tooltip
             */

        }, {
            key: "hideTooltipOnScroll",
            value: function hideTooltipOnScroll(event, hasTarget) {
                this.hideTooltip(event, hasTarget, {
                    isScroll: true
                });
            }
            /**
             * Add scroll event listener when tooltip show
             * automatically hide the tooltip when scrolling
             */

        }, {
            key: "addScrollListener",
            value: function addScrollListener(currentTarget) {
                var isCaptureMode = this.isCapture(currentTarget);
                window.addEventListener("scroll", this.hideTooltipOnScroll, isCaptureMode);
            }
        }, {
            key: "removeScrollListener",
            value: function removeScrollListener() {
                window.removeEventListener("scroll", this.hideTooltipOnScroll);
            } // Calculation the position

        }, {
            key: "updatePosition",
            value: function updatePosition() {
                var _this7 = this;

                var _this$state2 = this.state,
                    currentEvent = _this$state2.currentEvent,
                    currentTarget = _this$state2.currentTarget,
                    place = _this$state2.place,
                    desiredPlace = _this$state2.desiredPlace,
                    effect = _this$state2.effect,
                    offset = _this$state2.offset;
                var node = this.tooltipRef;
                var result = getPosition(currentEvent, currentTarget, node, place, desiredPlace, effect, offset);

                if (result.position && this.props.overridePosition) {
                    result.position = this.props.overridePosition(result.position, currentEvent, currentTarget, node, place, desiredPlace, effect, offset);
                }

                if (result.isNewState) {
                    // Switch to reverse placement
                    return this.setState(result.newState, function() {
                        _this7.updatePosition();
                    });
                } // Set tooltip position


                node.style.left = result.position.left + "px";
                node.style.top = result.position.top + "px";
            }
            /**
             * Set style tag in header
             * in this way we can insert default css
             */

            /* setStyleHeader() {
              const head = document.getElementsByTagName("head")[0];
              if (!head.querySelector('style[id="react-tooltip"]')) {
                const tag = document.createElement("style");
                tag.id = "react-tooltip";
                tag.innerHTML = cssStyle; */

            /* eslint-disable */

            /*      if (typeof __webpack_nonce__ !== 'undefined' && __webpack_nonce__) {
                    tag.setAttribute('nonce', __webpack_nonce__)
                  }*/

            /* eslint-enable */

            /*    head.insertBefore(tag, head.firstChild);
              }
            } */

            /**
             * CLear all kinds of timeout of interval
             */

        }, {
            key: "clearTimer",
            value: function clearTimer() {
                clearTimeout(this.delayShowLoop);
                clearTimeout(this.delayHideLoop);
                clearTimeout(this.delayReshow);
                clearInterval(this.intervalUpdateContent);
            }
        }, {
            key: "render",
            value: function render() {
                var _this8 = this;

                var _this$state3 = this.state,
                    extraClass = _this$state3.extraClass,
                    html = _this$state3.html,
                    ariaProps = _this$state3.ariaProps,
                    disable = _this$state3.disable;
                var placeholder = this.getTooltipContent();
                var isEmptyTip = this.isEmptyTip(placeholder);
                var tooltipClass = "__react_component_tooltip" + (this.state.show && !disable && !isEmptyTip ? " show" : "") + (this.state.border ? " border" : "") + " place-".concat(this.state.place) + // top, bottom, left, right
                    " type-".concat(this.state.type) + ( // dark, success, warning, error, info, light
                        this.props.delayUpdate ? " allow_hover" : "") + (this.props.clickable ? " allow_click" : "");
                var Wrapper = this.props.wrapper;

                if (ReactTooltip.supportedWrappers.indexOf(Wrapper) < 0) {
                    Wrapper = ReactTooltip.defaultProps.wrapper;
                }

                var wrapperClassName = [tooltipClass, extraClass].filter(Boolean).join(" ");

                if (html) {
                    return React.createElement(Wrapper, _extends({
                        className: wrapperClassName,
                        id: this.props.id,
                        ref: function ref(_ref) {
                            return _this8.tooltipRef = _ref;
                        }
                    }, ariaProps, {
                        "data-id": "tooltip",
                        dangerouslySetInnerHTML: {
                            __html: placeholder
                        }
                    }));
                } else {
                    return React.createElement(Wrapper, _extends({
                        className: wrapperClassName,
                        id: this.props.id
                    }, ariaProps, {
                        ref: function ref(_ref2) {
                            return _this8.tooltipRef = _ref2;
                        },
                        "data-id": "tooltip"
                    }), placeholder);
                }
            }
        }], [{
            key: "getDerivedStateFromProps",
            value: function getDerivedStateFromProps(nextProps, prevState) {
                var ariaProps = prevState.ariaProps;
                var newAriaProps = parseAria(nextProps);
                var isChanged = Object.keys(newAriaProps).some(function(props) {
                    return newAriaProps[props] !== ariaProps[props];
                });

                if (!isChanged) {
                    return null;
                }

                return _objectSpread2({}, prevState, {
                    ariaProps: newAriaProps
                });
            }
        }]);

        return ReactTooltip;
    }(React.Component), _defineProperty(_class2, "propTypes", {
        children: propTypes.any,
        place: propTypes.string,
        type: propTypes.string,
        effect: propTypes.string,
        offset: propTypes.object,
        multiline: propTypes.bool,
        border: propTypes.bool,
        insecure: propTypes.bool,
        "class": propTypes.string,
        className: propTypes.string,
        id: propTypes.string,
        html: propTypes.bool,
        delayHide: propTypes.number,
        delayUpdate: propTypes.number,
        delayShow: propTypes.number,
        event: propTypes.string,
        eventOff: propTypes.string,
        watchWindow: propTypes.bool,
        isCapture: propTypes.bool,
        globalEventOff: propTypes.string,
        getContent: propTypes.any,
        afterShow: propTypes.func,
        afterHide: propTypes.func,
        overridePosition: propTypes.func,
        disable: propTypes.bool,
        scrollHide: propTypes.bool,
        resizeHide: propTypes.bool,
        wrapper: propTypes.string,
        bodyMode: propTypes.bool,
        possibleCustomEvents: propTypes.string,
        possibleCustomEventsOff: propTypes.string,
        clickable: propTypes.bool
    }), _defineProperty(_class2, "defaultProps", {
        insecure: true,
        resizeHide: true,
        wrapper: "div",
        clickable: false
    }), _defineProperty(_class2, "supportedWrappers", ["div", "span"]), _defineProperty(_class2, "displayName", "ReactTooltip"), _temp)) || _class) || _class) || _class) || _class) || _class) || _class) || _class;

export default ReactTooltip;
//# sourceMappingURL=index.es.js.map