'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _functionNames = require('./functionNames');

var _functionNames2 = _interopRequireDefault(_functionNames);

var _eventNames = require('./eventNames');

var _eventNames2 = _interopRequireDefault(_eventNames);

var _FunctionStateMap = require('./FunctionStateMap');

var _FunctionStateMap2 = _interopRequireDefault(_FunctionStateMap);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}

/* eslint-disable promise/prefer-await-to-then */

var debug = (0, _debug2.default)('youtube-player');

var YouTubePlayer = {};

/**
 * Construct an object that defines an event handler for all of the YouTube
 * player events. Proxy captured events through an event emitter.
 *
 * @todo Capture event parameters.
 * @see https://developers.google.com/youtube/iframe_api_reference#Events
 */
YouTubePlayer.proxyEvents = function(emitter) {
    var events = {};

    var _loop = function _loop(eventName) {
        var onEventName = 'on' + eventName.slice(0, 1).toUpperCase() + eventName.slice(1);

        events[onEventName] = function(event) {
            debug('event "%s"', onEventName, event);

            emitter.trigger(eventName, event);
        };
    };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = _eventNames2.default[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var eventName = _step.value;

            _loop(eventName);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return events;
};

/**
 * Delays player API method execution until player state is ready.
 *
 * @todo Proxy all of the methods using Object.keys.
 * @todo See TRICKY below.
 * @param playerAPIReady Promise that resolves when player is ready.
 * @param strictState A flag designating whether or not to wait for
 * an acceptable state when calling supported functions.
 * @returns {Object}
 */
YouTubePlayer.promisifyPlayer = function(playerAPIReady) {
    var strictState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var functions = {};

    var _loop2 = function _loop2(functionName) {
        if (strictState && _FunctionStateMap2.default[functionName]) {
            functions[functionName] = function() {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                return playerAPIReady.then(function(player) {
                    var stateInfo = _FunctionStateMap2.default[functionName];
                    var playerState = player.getPlayerState();

                    // eslint-disable-next-line no-warning-comments
                    // TODO: Just spread the args into the function once Babel is fixed:
                    // https://github.com/babel/babel/issues/4270
                    //
                    // eslint-disable-next-line prefer-spread
                    var value = player[functionName].apply(player, args);

                    // TRICKY: For functions like `seekTo`, a change in state must be
                    // triggered given that the resulting state could match the initial
                    // state.
                    if (stateInfo.stateChangeRequired ||

                        // eslint-disable-next-line no-extra-parens
                        Array.isArray(stateInfo.acceptableStates) && stateInfo.acceptableStates.indexOf(playerState) === -1) {
                        return new Promise(function(resolve) {
                            var onPlayerStateChange = function onPlayerStateChange() {
                                var playerStateAfterChange = player.getPlayerState();

                                var timeout = void 0;

                                if (typeof stateInfo.timeout === 'number') {
                                    timeout = setTimeout(function() {
                                        player.removeEventListener('onStateChange', onPlayerStateChange);

                                        resolve();
                                    }, stateInfo.timeout);
                                }

                                if (Array.isArray(stateInfo.acceptableStates) && stateInfo.acceptableStates.indexOf(playerStateAfterChange) !== -1) {
                                    player.removeEventListener('onStateChange', onPlayerStateChange);

                                    clearTimeout(timeout);

                                    resolve();
                                }
                            };

                            player.addEventListener('onStateChange', onPlayerStateChange);
                        }).then(function() {
                            return value;
                        });
                    }

                    return value;
                });
            };
        } else {
            functions[functionName] = function() {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                }

                return playerAPIReady.then(function(player) {
                    // eslint-disable-next-line no-warning-comments
                    // TODO: Just spread the args into the function once Babel is fixed:
                    // https://github.com/babel/babel/issues/4270
                    //
                    // eslint-disable-next-line prefer-spread
                    return player[functionName].apply(player, args);
                });
            };
        }
    };

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = _functionNames2.default[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var functionName = _step2.value;

            _loop2(functionName);
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return functions;
};

exports.default = YouTubePlayer;
module.exports = exports['default'];