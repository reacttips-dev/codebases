'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var conventionUiReact = require('@pipedrive/convention-ui-react');
var styled = require('styled-components');
var _jsxRuntime = require('react/jsx-runtime');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);
var _jsxRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_jsxRuntime);

var global$1 = (typeof global !== "undefined" ? global :
            typeof self !== "undefined" ? self :
            typeof window !== "undefined" ? window : {});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var process$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var ProfilerContext = React__default['default'].createContext({
  wrapPrepareQueryResource: function wrapPrepareQueryResource(cb) {
    return cb();
  }
});
var ProfilerContext_1 = ProfilerContext;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var CONNECTION_CALLS = {
  after: true,
  before: true,
  find: true,
  first: true,
  last: true,
  surrounds: true
};
var config$1 = {
  CLIENT_MUTATION_ID: 'clientMutationId',
  CURSOR: 'cursor',
  EDGES: 'edges',
  END_CURSOR: 'endCursor',
  HAS_NEXT_PAGE: 'hasNextPage',
  HAS_PREV_PAGE: 'hasPreviousPage',
  NODE: 'node',
  PAGE_INFO_TYPE: 'PageInfo',
  PAGE_INFO: 'pageInfo',
  START_CURSOR: 'startCursor'
};
/**
 * @internal
 *
 * Defines logic relevant to the informal "Connection" GraphQL interface.
 */

var ConnectionInterface = {
  inject: function inject(newConfig) {
    config$1 = newConfig;
  },
  get: function get() {
    return config$1;
  },

  /**
   * Checks whether a call exists strictly to encode which parts of a connection
   * to fetch. Fields that only differ by connection call values should have the
   * same identity.
   */
  isConnectionCall: function isConnectionCall(call) {
    return CONNECTION_CALLS.hasOwnProperty(call.name);
  }
};
var ConnectionInterface_1 = ConnectionInterface;

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process$1.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

var browser$1 = invariant;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var RelayDefaultHandleKey = {
  DEFAULT_HANDLE_KEY: ''
};

var DEFAULT_HANDLE_KEY = RelayDefaultHandleKey.DEFAULT_HANDLE_KEY;
/**
 * @internal
 *
 * Helper to create a unique name for a handle field based on the handle name, handle key and
 * source field.
 */


function getRelayHandleKey(handleName, key, fieldName) {
  if (key && key !== DEFAULT_HANDLE_KEY) {
    return "__".concat(key, "_").concat(handleName);
  }

  !(fieldName != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'getRelayHandleKey: Expected either `fieldName` or `key` in `handle` to be provided') : browser$1(false) : void 0;
  return "__".concat(fieldName, "_").concat(handleName);
}

var getRelayHandleKey_1 = getRelayHandleKey;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}
/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */


var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);

emptyFunction.thatReturnsThis = function () {
  return this;
};

emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

var emptyFunction_1 = emptyFunction;

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */


function printWarning(format) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var argIndex = 0;
  var message = 'Warning: ' + format.replace(/%s/g, function () {
    return args[argIndex++];
  });

  if (typeof console !== 'undefined') {
    console.error(message);
  }

  try {
    // --- Welcome to debugging React ---
    // This error was thrown as a convenience so that you can use this stack
    // to find the callsite that caused this warning to fire.
    throw new Error(message);
  } catch (x) {}
}

var warning = process$1.env.NODE_ENV !== "production" ? function (condition, format) {
  if (format === undefined) {
    throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
  }

  if (!condition) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }

    printWarning.apply(void 0, [format].concat(args));
  }
} : emptyFunction_1;
var warning_1 = warning;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var PREFIX = 'client:';

function generateClientID(id, storageKey, index) {
  var key = id + ':' + storageKey;

  if (index != null) {
    key += ':' + index;
  }

  if (key.indexOf(PREFIX) !== 0) {
    key = PREFIX + key;
  }

  return key;
}

function isClientID(id) {
  return id.indexOf(PREFIX) === 0;
}

var localID = 0;

function generateUniqueClientID() {
  return "".concat(PREFIX, "local:").concat(localID++);
}

var ClientID = {
  generateClientID: generateClientID,
  generateUniqueClientID: generateUniqueClientID,
  isClientID: isClientID
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var interopRequireDefault = createCommonjsModule(function (module) {
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
});

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var arrayLikeToArray = _arrayLikeToArray;

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

var unsupportedIterableToArray = _unsupportedIterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

/**
 * Represents a common GraphQL request that can be executed, an `operation`
 * containing information to normalize the results, and a `fragment` derived
 * from that operation to read the response data (masking data from child
 * fragments).
 */

/**
 * Contains the parameters required for executing a GraphQL request.
 * The operation can either be provided as a persisted `id` or `text`. If given
 * in `text` format, a `cacheID` as a hash of the text should be set to be used
 * for local caching.
 */
var RelayConcreteNode = {
  CONDITION: 'Condition',
  CLIENT_COMPONENT: 'ClientComponent',
  CLIENT_EXTENSION: 'ClientExtension',
  DEFER: 'Defer',
  CONNECTION: 'Connection',
  FLIGHT_FIELD: 'FlightField',
  FRAGMENT: 'Fragment',
  FRAGMENT_SPREAD: 'FragmentSpread',
  INLINE_DATA_FRAGMENT_SPREAD: 'InlineDataFragmentSpread',
  INLINE_DATA_FRAGMENT: 'InlineDataFragment',
  INLINE_FRAGMENT: 'InlineFragment',
  LINKED_FIELD: 'LinkedField',
  LINKED_HANDLE: 'LinkedHandle',
  LITERAL: 'Literal',
  LIST_VALUE: 'ListValue',
  LOCAL_ARGUMENT: 'LocalArgument',
  MODULE_IMPORT: 'ModuleImport',
  RELAY_RESOLVER: 'RelayResolver',
  REQUIRED_FIELD: 'RequiredField',
  OBJECT_VALUE: 'ObjectValue',
  OPERATION: 'Operation',
  REQUEST: 'Request',
  ROOT_ARGUMENT: 'RootArgument',
  SCALAR_FIELD: 'ScalarField',
  SCALAR_HANDLE: 'ScalarHandle',
  SPLIT_OPERATION: 'SplitOperation',
  STREAM: 'Stream',
  TYPE_DISCRIMINATOR: 'TypeDiscriminator',
  VARIABLE: 'Variable'
};
var RelayConcreteNode_1 = RelayConcreteNode;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
/**
 * Creates a copy of the provided value, ensuring any nested objects have their
 * keys sorted such that equivalent values would have identical JSON.stringify
 * results.
 */

function stableCopy(value) {
  if (!value || typeof value !== 'object') {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map(stableCopy);
  }

  var keys = Object.keys(value).sort();
  var stable = {};

  for (var i = 0; i < keys.length; i++) {
    stable[keys[i]] = stableCopy(value[keys[i]]);
  }

  return stable;
}

var stableCopy_1 = stableCopy;

var _toConsumableArray2 = interopRequireDefault(toConsumableArray);









var VARIABLE = RelayConcreteNode_1.VARIABLE,
    LITERAL = RelayConcreteNode_1.LITERAL,
    OBJECT_VALUE = RelayConcreteNode_1.OBJECT_VALUE,
    LIST_VALUE = RelayConcreteNode_1.LIST_VALUE;
var MODULE_COMPONENT_KEY_PREFIX = '__module_component_';
var MODULE_OPERATION_KEY_PREFIX = '__module_operation_';

function getArgumentValue(arg, variables) {
  if (arg.kind === VARIABLE) {
    // Variables are provided at runtime and are not guaranteed to be stable.
    return getStableVariableValue(arg.variableName, variables);
  } else if (arg.kind === LITERAL) {
    // The Relay compiler generates stable ConcreteArgument values.
    return arg.value;
  } else if (arg.kind === OBJECT_VALUE) {
    var value = {};
    arg.fields.forEach(function (field) {
      value[field.name] = getArgumentValue(field, variables);
    });
    return value;
  } else if (arg.kind === LIST_VALUE) {
    var _value = [];
    arg.items.forEach(function (item) {
      item != null ? _value.push(getArgumentValue(item, variables)) : null;
    });
    return _value;
  }
}
/**
 * Returns the values of field/fragment arguments as an object keyed by argument
 * names. Guaranteed to return a result with stable ordered nested values.
 */


function getArgumentValues(args, variables) {
  var values = {};
  args.forEach(function (arg) {
    values[arg.name] = getArgumentValue(arg, variables);
  });
  return values;
}
/**
 * Given a handle field and variable values, returns a key that can be used to
 * uniquely identify the combination of the handle name and argument values.
 *
 * Note: the word "storage" here refers to the fact this key is primarily used
 * when writing the results of a key in a normalized graph or "store". This
 * name was used in previous implementations of Relay internals and is also
 * used here for consistency.
 */


function getHandleStorageKey(handleField, variables) {
  var dynamicKey = handleField.dynamicKey,
      handle = handleField.handle,
      key = handleField.key,
      name = handleField.name,
      args = handleField.args,
      filters = handleField.filters;
  var handleName = getRelayHandleKey_1(handle, key, name);
  var filterArgs = null;

  if (args && filters && args.length !== 0 && filters.length !== 0) {
    filterArgs = args.filter(function (arg) {
      return filters.indexOf(arg.name) > -1;
    });
  }

  if (dynamicKey) {
    // "Sort" the arguments by argument name: this is done by the compiler for
    // user-supplied arguments but the dynamic argument must also be in sorted
    // order.  Note that dynamic key argument name is double-underscore-
    // -prefixed, and a double-underscore prefix is disallowed for user-supplied
    // argument names, so there's no need to actually sort.
    filterArgs = filterArgs != null ? [dynamicKey].concat((0, _toConsumableArray2["default"])(filterArgs)) : [dynamicKey];
  }

  if (filterArgs === null) {
    return handleName;
  } else {
    return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));
  }
}
/**
 * Given a field and variable values, returns a key that can be used to
 * uniquely identify the combination of the field name and argument values.
 *
 * Note: the word "storage" here refers to the fact this key is primarily used
 * when writing the results of a key in a normalized graph or "store". This
 * name was used in previous implementations of Relay internals and is also
 * used here for consistency.
 */


function getStorageKey(field, variables) {
  if (field.storageKey) {
    // TODO T23663664: Handle nodes do not yet define a static storageKey.
    return field.storageKey;
  }

  var args = field.args,
      name = field.name;
  return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;
}
/**
 * Given a `name` (eg. "foo") and an object representing argument values
 * (eg. `{orberBy: "name", first: 10}`) returns a unique storage key
 * (ie. `foo{"first":10,"orderBy":"name"}`).
 *
 * This differs from getStorageKey which requires a ConcreteNode where arguments
 * are assumed to already be sorted into a stable order.
 */


function getStableStorageKey(name, args) {
  return formatStorageKey(name, stableCopy_1(args));
}
/**
 * Given a name and argument values, format a storage key.
 *
 * Arguments and the values within them are expected to be ordered in a stable
 * alphabetical ordering.
 */


function formatStorageKey(name, argValues) {
  if (!argValues) {
    return name;
  }

  var values = [];

  for (var argName in argValues) {
    if (argValues.hasOwnProperty(argName)) {
      var value = argValues[argName];

      if (value != null) {
        var _JSON$stringify;

        values.push(argName + ':' + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'undefined'));
      }
    }
  }

  return values.length === 0 ? name : name + "(".concat(values.join(','), ")");
}
/**
 * Given Variables and a variable name, return a variable value with
 * all values in a stable order.
 */


function getStableVariableValue(name, variables) {
  !variables.hasOwnProperty(name) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'getVariableValue(): Undefined variable `%s`.', name) : browser$1(false) : void 0; // $FlowFixMe[cannot-write]

  return stableCopy_1(variables[name]);
}

function getModuleComponentKey(documentName) {
  return "".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);
}

function getModuleOperationKey(documentName) {
  return "".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);
}
/**
 * Constants shared by all implementations of RecordSource/MutableRecordSource/etc.
 */


var RelayStoreUtils = {
  FRAGMENTS_KEY: '__fragments',
  FRAGMENT_OWNER_KEY: '__fragmentOwner',
  FRAGMENT_PROP_NAME_KEY: '__fragmentPropName',
  MODULE_COMPONENT_KEY: '__module_component',
  // alias returned by Reader
  ID_KEY: '__id',
  REF_KEY: '__ref',
  REFS_KEY: '__refs',
  ROOT_ID: 'client:root',
  ROOT_TYPE: '__Root',
  TYPENAME_KEY: '__typename',
  INVALIDATED_AT_KEY: '__invalidated_at',
  IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: '__isWithinUnmatchedTypeRefinement',
  formatStorageKey: formatStorageKey,
  getArgumentValue: getArgumentValue,
  getArgumentValues: getArgumentValues,
  getHandleStorageKey: getHandleStorageKey,
  getStorageKey: getStorageKey,
  getStableStorageKey: getStableStorageKey,
  getModuleComponentKey: getModuleComponentKey,
  getModuleOperationKey: getModuleOperationKey
};
var RelayStoreUtils_1 = RelayStoreUtils;

var generateClientID$1 = ClientID.generateClientID;

var getStableStorageKey$1 = RelayStoreUtils_1.getStableStorageKey;

var CONNECTION = 'connection'; // Per-instance incrementing index used to generate unique edge IDs

var NEXT_EDGE_INDEX = '__connection_next_edge_index';
/**
 * @public
 *
 * A default runtime handler for connection fields that appends newly fetched
 * edges onto the end of a connection, regardless of the arguments used to fetch
 * those edges.
 */

function update(store, payload) {
  var record = store.get(payload.dataID);

  if (!record) {
    return;
  }

  var _ConnectionInterface$ = ConnectionInterface_1.get(),
      EDGES = _ConnectionInterface$.EDGES,
      END_CURSOR = _ConnectionInterface$.END_CURSOR,
      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,
      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,
      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,
      PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE,
      START_CURSOR = _ConnectionInterface$.START_CURSOR;

  var serverConnection = record.getLinkedRecord(payload.fieldKey);
  var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);

  if (!serverConnection) {
    record.setValue(null, payload.handleKey);
    return;
  } // In rare cases the handleKey field may be unset even though the client
  // connection record exists, in this case new edges should still be merged
  // into the existing client connection record (and the field reset to point
  // to that record).


  var clientConnectionID = generateClientID$1(record.getDataID(), payload.handleKey);
  var clientConnectionField = record.getLinkedRecord(payload.handleKey);
  var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);
  var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);

  if (!clientConnection) {
    // Initial fetch with data: copy fields from the server record
    var connection = store.create(clientConnectionID, serverConnection.getType());
    connection.setValue(0, NEXT_EDGE_INDEX);
    connection.copyFieldsFrom(serverConnection);
    var serverEdges = serverConnection.getLinkedRecords(EDGES);

    if (serverEdges) {
      serverEdges = serverEdges.map(function (edge) {
        return buildConnectionEdge(store, connection, edge);
      });
      connection.setLinkedRecords(serverEdges, EDGES);
    }

    record.setLinkedRecord(connection, payload.handleKey);
    clientPageInfo = store.create(generateClientID$1(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);
    clientPageInfo.setValue(false, HAS_NEXT_PAGE);
    clientPageInfo.setValue(false, HAS_PREV_PAGE);
    clientPageInfo.setValue(null, END_CURSOR);
    clientPageInfo.setValue(null, START_CURSOR);

    if (serverPageInfo) {
      clientPageInfo.copyFieldsFrom(serverPageInfo);
    }

    connection.setLinkedRecord(clientPageInfo, PAGE_INFO);
  } else {
    if (clientConnectionField == null) {
      // If the handleKey field was unset but the client connection record
      // existed, update the field to point to the record
      record.setLinkedRecord(clientConnection, payload.handleKey);
    }

    var _connection = clientConnection; // Subsequent fetches:
    // - updated fields on the connection
    // - merge prev/next edges, de-duplicating by node id
    // - synthesize page info fields

    var _serverEdges = serverConnection.getLinkedRecords(EDGES);

    if (_serverEdges) {
      _serverEdges = _serverEdges.map(function (edge) {
        return buildConnectionEdge(store, _connection, edge);
      });
    }

    var prevEdges = _connection.getLinkedRecords(EDGES);

    var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);

    _connection.copyFieldsFrom(serverConnection); // Reset EDGES and PAGE_INFO fields


    if (prevEdges) {
      _connection.setLinkedRecords(prevEdges, EDGES);
    }

    if (prevPageInfo) {
      _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);
    }

    var nextEdges = [];
    var args = payload.args;

    if (prevEdges && _serverEdges) {
      // $FlowFixMe[prop-missing]
      if (args.after != null) {
        // Forward pagination from the end of the connection: append edges
        if (clientPageInfo && // $FlowFixMe[prop-missing]
        args.after === clientPageInfo.getValue(END_CURSOR)) {
          var nodeIDs = new Set();
          mergeEdges(prevEdges, nextEdges, nodeIDs);
          mergeEdges(_serverEdges, nextEdges, nodeIDs);
        } else {
          process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : void 0;
          return;
        } // $FlowFixMe[prop-missing]

      } else if (args.before != null) {
        // Backward pagination from the start of the connection: prepend edges
        if (clientPageInfo && // $FlowFixMe[prop-missing]
        args.before === clientPageInfo.getValue(START_CURSOR)) {
          var _nodeIDs = new Set();

          mergeEdges(_serverEdges, nextEdges, _nodeIDs);
          mergeEdges(prevEdges, nextEdges, _nodeIDs);
        } else {
          process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : void 0;
          return;
        }
      } else {
        // The connection was refetched from the beginning/end: replace edges
        nextEdges = _serverEdges;
      }
    } else if (_serverEdges) {
      nextEdges = _serverEdges;
    } else {
      nextEdges = prevEdges;
    } // Update edges only if they were updated, the null check is
    // for Flow (prevEdges could be null).


    if (nextEdges != null && nextEdges !== prevEdges) {
      _connection.setLinkedRecords(nextEdges, EDGES);
    } // Page info should be updated even if no new edge were returned.


    if (clientPageInfo && serverPageInfo) {
      // $FlowFixMe[prop-missing]
      if (args.after == null && args.before == null) {
        // The connection was refetched from the beginning/end: replace
        // page_info
        clientPageInfo.copyFieldsFrom(serverPageInfo); // $FlowFixMe[prop-missing]
      } else if (args.before != null || args.after == null && args.last) {
        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);
        var startCursor = serverPageInfo.getValue(START_CURSOR);

        if (typeof startCursor === 'string') {
          clientPageInfo.setValue(startCursor, START_CURSOR);
        } // $FlowFixMe[prop-missing]

      } else if (args.after != null || args.before == null && args.first) {
        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);
        var endCursor = serverPageInfo.getValue(END_CURSOR);

        if (typeof endCursor === 'string') {
          clientPageInfo.setValue(endCursor, END_CURSOR);
        }
      }
    }
  }
}
/**
 * @public
 *
 * Given a record and the name of the schema field for which a connection was
 * fetched, returns the linked connection record.
 *
 * Example:
 *
 * Given that data has already been fetched on some user `<id>` on the `friends`
 * field:
 *
 * ```
 * fragment FriendsFragment on User {
 *   friends(first: 10) @connection(key: "FriendsFragment_friends") {
 *    edges {
 *      node {
 *        id
 *        }
 *      }
 *   }
 * }
 * ```
 *
 * The `friends` connection record can be accessed with:
 *
 * ```
 * store => {
 *   const user = store.get('<id>');
 *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');
 *   // Access fields on the connection:
 *   const edges = friends.getLinkedRecords('edges');
 * }
 * ```
 *
 * TODO: t15733312
 * Currently we haven't run into this case yet, but we need to add a `getConnections`
 * that returns an array of the connections under the same `key` regardless of the variables.
 */


function getConnection(record, key, filters) {
  var handleKey = getRelayHandleKey_1(CONNECTION, key, null);
  return record.getLinkedRecord(handleKey, filters);
}
/**
 * @public
 *
 * Given a record ID, the key of a connection field, and optional filters used
 * to identify the connection, returns the connection ID.
 *
 * Example:
 *
 * Given that data has already been fetched on some user `<user-id>` on the `friends`
 * field:
 *
 * ```
 * fragment FriendsFragment on User {
 *   friends(first: 10) @connection(key: "FriendsFragment_friends") {
 *     edges {
 *       node {
 *         id
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * The ID of the `friends` connection record can be accessed with:
 *
 * ```
 * store => {
 *   const connectionID = ConnectionHandler.getConnectionID('<user-id>', 'FriendsFragment_friends');
 * }
 * ```
 */


function getConnectionID(recordID, key, filters) {
  var handleKey = getRelayHandleKey_1(CONNECTION, key, null);
  var storageKey = getStableStorageKey$1(handleKey, filters);
  return generateClientID$1(recordID, storageKey);
}
/**
 * @public
 *
 * Inserts an edge after the given cursor, or at the end of the list if no
 * cursor is provided.
 *
 * Example:
 *
 * Given that data has already been fetched on some user `<id>` on the `friends`
 * field:
 *
 * ```
 * fragment FriendsFragment on User {
 *   friends(first: 10) @connection(key: "FriendsFragment_friends") {
 *    edges {
 *      node {
 *        id
 *        }
 *      }
 *   }
 * }
 * ```
 *
 * An edge can be appended with:
 *
 * ```
 * store => {
 *   const user = store.get('<id>');
 *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');
 *   const edge = store.create('<edge-id>', 'FriendsEdge');
 *   ConnectionHandler.insertEdgeAfter(friends, edge);
 * }
 * ```
 */


function insertEdgeAfter(record, newEdge, cursor) {
  var _ConnectionInterface$2 = ConnectionInterface_1.get(),
      CURSOR = _ConnectionInterface$2.CURSOR,
      EDGES = _ConnectionInterface$2.EDGES;

  var edges = record.getLinkedRecords(EDGES);

  if (!edges) {
    record.setLinkedRecords([newEdge], EDGES);
    return;
  }

  var nextEdges;

  if (cursor == null) {
    nextEdges = edges.concat(newEdge);
  } else {
    nextEdges = [];
    var foundCursor = false;

    for (var ii = 0; ii < edges.length; ii++) {
      var edge = edges[ii];
      nextEdges.push(edge);

      if (edge == null) {
        continue;
      }

      var edgeCursor = edge.getValue(CURSOR);

      if (cursor === edgeCursor) {
        nextEdges.push(newEdge);
        foundCursor = true;
      }
    }

    if (!foundCursor) {
      nextEdges.push(newEdge);
    }
  }

  record.setLinkedRecords(nextEdges, EDGES);
}
/**
 * @public
 *
 * Creates an edge for a connection record, given a node and edge type.
 */


function createEdge(store, record, node, edgeType) {
  var _ConnectionInterface$3 = ConnectionInterface_1.get(),
      NODE = _ConnectionInterface$3.NODE; // An index-based client ID could easily conflict (unless it was
  // auto-incrementing, but there is nowhere to the store the id)
  // Instead, construct a client ID based on the connection ID and node ID,
  // which will only conflict if the same node is added to the same connection
  // twice. This is acceptable since the `insertEdge*` functions ignore
  // duplicates.


  var edgeID = generateClientID$1(record.getDataID(), node.getDataID());
  var edge = store.get(edgeID);

  if (!edge) {
    edge = store.create(edgeID, edgeType);
  }

  edge.setLinkedRecord(node, NODE);

  if (edge.getValue('cursor') == null) {
    // Always use null instead of undefined value for cursor
    // to avoid considering it as missing data
    edge.setValue(null, 'cursor');
  }

  return edge;
}
/**
 * @public
 *
 * Inserts an edge before the given cursor, or at the beginning of the list if
 * no cursor is provided.
 *
 * Example:
 *
 * Given that data has already been fetched on some user `<id>` on the `friends`
 * field:
 *
 * ```
 * fragment FriendsFragment on User {
 *   friends(first: 10) @connection(key: "FriendsFragment_friends") {
 *    edges {
 *      node {
 *        id
 *        }
 *      }
 *   }
 * }
 * ```
 *
 * An edge can be prepended with:
 *
 * ```
 * store => {
 *   const user = store.get('<id>');
 *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');
 *   const edge = store.create('<edge-id>', 'FriendsEdge');
 *   ConnectionHandler.insertEdgeBefore(friends, edge);
 * }
 * ```
 */


function insertEdgeBefore(record, newEdge, cursor) {
  var _ConnectionInterface$4 = ConnectionInterface_1.get(),
      CURSOR = _ConnectionInterface$4.CURSOR,
      EDGES = _ConnectionInterface$4.EDGES;

  var edges = record.getLinkedRecords(EDGES);

  if (!edges) {
    record.setLinkedRecords([newEdge], EDGES);
    return;
  }

  var nextEdges;

  if (cursor == null) {
    nextEdges = [newEdge].concat(edges);
  } else {
    nextEdges = [];
    var foundCursor = false;

    for (var ii = 0; ii < edges.length; ii++) {
      var edge = edges[ii];

      if (edge != null) {
        var edgeCursor = edge.getValue(CURSOR);

        if (cursor === edgeCursor) {
          nextEdges.push(newEdge);
          foundCursor = true;
        }
      }

      nextEdges.push(edge);
    }

    if (!foundCursor) {
      nextEdges.unshift(newEdge);
    }
  }

  record.setLinkedRecords(nextEdges, EDGES);
}
/**
 * @public
 *
 * Remove any edges whose `node.id` matches the given id.
 */


function deleteNode(record, nodeID) {
  var _ConnectionInterface$5 = ConnectionInterface_1.get(),
      EDGES = _ConnectionInterface$5.EDGES,
      NODE = _ConnectionInterface$5.NODE;

  var edges = record.getLinkedRecords(EDGES);

  if (!edges) {
    return;
  }

  var nextEdges;

  for (var ii = 0; ii < edges.length; ii++) {
    var edge = edges[ii];
    var node = edge && edge.getLinkedRecord(NODE);

    if (node != null && node.getDataID() === nodeID) {
      if (nextEdges === undefined) {
        nextEdges = edges.slice(0, ii);
      }
    } else if (nextEdges !== undefined) {
      nextEdges.push(edge);
    }
  }

  if (nextEdges !== undefined) {
    record.setLinkedRecords(nextEdges, EDGES);
  }
}
/**
 * @internal
 *
 * Creates a copy of an edge with a unique ID based on per-connection-instance
 * incrementing edge index. This is necessary to avoid collisions between edges,
 * which can occur because (edge) client IDs are assigned deterministically
 * based on the path from the nearest node with an id.
 *
 * Example: if the first N edges of the same connection are refetched, the edges
 * from the second fetch will be assigned the same IDs as the first fetch, even
 * though the nodes they point to may be different (or the same and in different
 * order).
 */


function buildConnectionEdge(store, connection, edge) {
  if (edge == null) {
    return edge;
  }

  var _ConnectionInterface$6 = ConnectionInterface_1.get(),
      EDGES = _ConnectionInterface$6.EDGES;

  var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);
  !(typeof edgeIndex === 'number') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : browser$1(false) : void 0;
  var edgeID = generateClientID$1(connection.getDataID(), EDGES, edgeIndex);
  var connectionEdge = store.create(edgeID, edge.getType());
  connectionEdge.copyFieldsFrom(edge);

  if (connectionEdge.getValue('cursor') == null) {
    // Always use null instead of undefined value for cursor
    // to avoid considering it as missing data
    connectionEdge.setValue(null, 'cursor');
  }

  connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);
  return connectionEdge;
}
/**
 * @internal
 *
 * Adds the source edges to the target edges, skipping edges with
 * duplicate node ids.
 */


function mergeEdges(sourceEdges, targetEdges, nodeIDs) {
  var _ConnectionInterface$7 = ConnectionInterface_1.get(),
      NODE = _ConnectionInterface$7.NODE;

  for (var ii = 0; ii < sourceEdges.length; ii++) {
    var edge = sourceEdges[ii];

    if (!edge) {
      continue;
    }

    var node = edge.getLinkedRecord(NODE);
    var nodeID = node && node.getDataID();

    if (nodeID) {
      if (nodeIDs.has(nodeID)) {
        continue;
      }

      nodeIDs.add(nodeID);
    }

    targetEdges.push(edge);
  }
}

var ConnectionHandler = {
  buildConnectionEdge: buildConnectionEdge,
  createEdge: createEdge,
  deleteNode: deleteNode,
  getConnection: getConnection,
  getConnectionID: getConnectionID,
  insertEdgeAfter: insertEdgeAfter,
  insertEdgeBefore: insertEdgeBefore,
  update: update
};

/**
 * Runtime function to correspond to the `graphql` tagged template function.
 * All calls to this function should be transformed by the plugin.
 */
function graphql(strings) {
   process$1.env.NODE_ENV !== "production" ? browser$1(false, 'graphql: Unexpected invocation at runtime. Either the Babel transform ' + 'was not set up, or it failed to identify this call site. Make sure it ' + 'is being used verbatim as `graphql`. Note also that there cannot be ' + 'a space between graphql and the backtick that follows.') : browser$1(false) ;
}

function getNode(taggedNode) {
  var node = taggedNode;

  if (typeof node === 'function') {
    node = node();
    process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayGraphQLTag: node `%s` unexpectedly wrapped in a function.', node.kind === 'Fragment' ? node.name : node.operation.name) : void 0;
  } else if (node["default"]) {
    // Support for languages that work (best) with ES6 modules, such as TypeScript.
    node = node["default"];
  }

  return node;
}

function isFragment(node) {
  var fragment = getNode(node);
  return typeof fragment === 'object' && fragment !== null && fragment.kind === RelayConcreteNode_1.FRAGMENT;
}

function isRequest(node) {
  var request = getNode(node);
  return typeof request === 'object' && request !== null && request.kind === RelayConcreteNode_1.REQUEST;
}

function isInlineDataFragment(node) {
  var fragment = getNode(node);
  return typeof fragment === 'object' && fragment !== null && fragment.kind === RelayConcreteNode_1.INLINE_DATA_FRAGMENT;
}

function getFragment(taggedNode) {
  var fragment = getNode(taggedNode);
  !isFragment(fragment) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'GraphQLTag: Expected a fragment, got `%s`.', JSON.stringify(fragment)) : browser$1(false) : void 0;
  return fragment;
}

function getPaginationFragment(taggedNode) {
  var _fragment$metadata;

  var fragment = getFragment(taggedNode);
  var refetch = (_fragment$metadata = fragment.metadata) === null || _fragment$metadata === void 0 ? void 0 : _fragment$metadata.refetch;
  var connection = refetch === null || refetch === void 0 ? void 0 : refetch.connection;

  if (refetch === null || typeof refetch !== 'object' || connection === null || typeof connection !== 'object') {
    return null;
  }

  return fragment;
}

function getRefetchableFragment(taggedNode) {
  var _fragment$metadata2;

  var fragment = getFragment(taggedNode);
  var refetch = (_fragment$metadata2 = fragment.metadata) === null || _fragment$metadata2 === void 0 ? void 0 : _fragment$metadata2.refetch;

  if (refetch === null || typeof refetch !== 'object') {
    return null;
  }

  return fragment;
}

function getRequest(taggedNode) {
  var request = getNode(taggedNode);
  !isRequest(request) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'GraphQLTag: Expected a request, got `%s`.', JSON.stringify(request)) : browser$1(false) : void 0;
  return request;
}

function getInlineDataFragment(taggedNode) {
  var fragment = getNode(taggedNode);
  !isInlineDataFragment(fragment) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'GraphQLTag: Expected an inline data fragment, got `%s`.', JSON.stringify(fragment)) : browser$1(false) : void 0;
  return fragment;
}

var GraphQLTag = {
  getFragment: getFragment,
  getNode: getNode,
  getPaginationFragment: getPaginationFragment,
  getRefetchableFragment: getRefetchableFragment,
  getRequest: getRequest,
  getInlineDataFragment: getInlineDataFragment,
  graphql: graphql,
  isFragment: isFragment,
  isRequest: isRequest,
  isInlineDataFragment: isInlineDataFragment
};

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var createForOfIteratorHelper = _createForOfIteratorHelper;

var _createForOfIteratorHelper2 = interopRequireDefault(createForOfIteratorHelper);









var DeleteRecordHandler = {
  update: function update(store, payload) {
    var record = store.get(payload.dataID);

    if (record != null) {
      var idOrIds = record.getValue(payload.fieldKey);

      if (typeof idOrIds === 'string') {
        store["delete"](idOrIds);
      } else if (Array.isArray(idOrIds)) {
        idOrIds.forEach(function (id) {
          if (typeof id === 'string') {
            store["delete"](id);
          }
        });
      }
    }
  }
};
var DeleteEdgeHandler = {
  update: function update(store, payload) {
    var record = store.get(payload.dataID);

    if (record == null) {
      return;
    } // $FlowFixMe[prop-missing]


    var connections = payload.handleArgs.connections;
    !(connections != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'MutationHandlers: Expected connection IDs to be specified.') : browser$1(false) : void 0;
    var idOrIds = record.getValue(payload.fieldKey);
    var idList = Array.isArray(idOrIds) ? idOrIds : [idOrIds];
    idList.forEach(function (id) {
      if (typeof id === 'string') {
        var _iterator = (0, _createForOfIteratorHelper2["default"])(connections),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var connectionID = _step.value;
            var connection = store.get(connectionID);

            if (connection == null) {
              process$1.env.NODE_ENV !== "production" ? warning_1(false, "[Relay][Mutation] The connection with id '".concat(connectionID, "' doesn't exist.")) : void 0;
              continue;
            }

            ConnectionHandler.deleteNode(connection, id);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    });
  }
};
var AppendEdgeHandler = {
  update: edgeUpdater(ConnectionHandler.insertEdgeAfter)
};
var PrependEdgeHandler = {
  update: edgeUpdater(ConnectionHandler.insertEdgeBefore)
};
var AppendNodeHandler = {
  update: nodeUpdater(ConnectionHandler.insertEdgeAfter)
};
var PrependNodeHandler = {
  update: nodeUpdater(ConnectionHandler.insertEdgeBefore)
};

function edgeUpdater(insertFn) {
  return function (store, payload) {
    var _serverEdges;

    var record = store.get(payload.dataID);

    if (record == null) {
      return;
    } // $FlowFixMe[prop-missing]


    var connections = payload.handleArgs.connections;
    !(connections != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'MutationHandlers: Expected connection IDs to be specified.') : browser$1(false) : void 0;
    var singleServerEdge, serverEdges;

    try {
      singleServerEdge = record.getLinkedRecord(payload.fieldKey, payload.args);
    } catch (_unused) {}

    if (!singleServerEdge) {
      try {
        serverEdges = record.getLinkedRecords(payload.fieldKey, payload.args);
      } catch (_unused2) {}
    }

    if (singleServerEdge == null && serverEdges == null) {
      process$1.env.NODE_ENV !== "production" ? warning_1(false, 'MutationHandlers: Expected the server edge to be non-null.') : void 0;
      return;
    }

    var _ConnectionInterface$ = ConnectionInterface_1.get(),
        NODE = _ConnectionInterface$.NODE,
        EDGES = _ConnectionInterface$.EDGES;

    var serverEdgeList = (_serverEdges = serverEdges) !== null && _serverEdges !== void 0 ? _serverEdges : [singleServerEdge];

    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(serverEdgeList),
        _step2;

    try {
      var _loop = function _loop() {
        var serverEdge = _step2.value;

        if (serverEdge == null) {
          return "continue";
        }

        var serverNode = serverEdge.getLinkedRecord('node');

        if (!serverNode) {
          return "continue";
        }

        var serverNodeId = serverNode.getDataID();

        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(connections),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var connectionID = _step3.value;
            var connection = store.get(connectionID);

            if (connection == null) {
              process$1.env.NODE_ENV !== "production" ? warning_1(false, "[Relay][Mutation] The connection with id '".concat(connectionID, "' doesn't exist.")) : void 0;
              continue;
            }

            var nodeAlreadyExistsInConnection = (_connection$getLinked = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked === void 0 ? void 0 : _connection$getLinked.some(function (edge) {
              var _edge$getLinkedRecord;

              return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord === void 0 ? void 0 : _edge$getLinkedRecord.getDataID()) === serverNodeId;
            });

            if (nodeAlreadyExistsInConnection) {
              continue;
            }

            var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);
            !(clientEdge != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'MutationHandlers: Failed to build the edge.') : browser$1(false) : void 0;
            insertFn(connection, clientEdge);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      };

      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _connection$getLinked;

        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  };
}

function nodeUpdater(insertFn) {
  return function (store, payload) {
    var _serverNodes;

    var record = store.get(payload.dataID);

    if (record == null) {
      return;
    } // $FlowFixMe[prop-missing]


    var _payload$handleArgs = payload.handleArgs,
        connections = _payload$handleArgs.connections,
        edgeTypeName = _payload$handleArgs.edgeTypeName;
    !(connections != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'MutationHandlers: Expected connection IDs to be specified.') : browser$1(false) : void 0;
    !(edgeTypeName != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'MutationHandlers: Expected edge typename to be specified.') : browser$1(false) : void 0;
    var singleServerNode;
    var serverNodes;

    try {
      singleServerNode = record.getLinkedRecord(payload.fieldKey, payload.args);
    } catch (_unused3) {}

    if (!singleServerNode) {
      try {
        serverNodes = record.getLinkedRecords(payload.fieldKey, payload.args);
      } catch (_unused4) {}
    }

    if (singleServerNode == null && serverNodes == null) {
      process$1.env.NODE_ENV !== "production" ? warning_1(false, 'MutationHandlers: Expected target node to exist.') : void 0;
      return;
    }

    var _ConnectionInterface$2 = ConnectionInterface_1.get(),
        NODE = _ConnectionInterface$2.NODE,
        EDGES = _ConnectionInterface$2.EDGES;

    var serverNodeList = (_serverNodes = serverNodes) !== null && _serverNodes !== void 0 ? _serverNodes : [singleServerNode];

    var _iterator4 = (0, _createForOfIteratorHelper2["default"])(serverNodeList),
        _step4;

    try {
      var _loop2 = function _loop2() {
        var serverNode = _step4.value;

        if (serverNode == null) {
          return "continue";
        }

        var serverNodeId = serverNode.getDataID();

        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(connections),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var connectionID = _step5.value;
            var connection = store.get(connectionID);

            if (connection == null) {
              process$1.env.NODE_ENV !== "production" ? warning_1(false, "[Relay][Mutation] The connection with id '".concat(connectionID, "' doesn't exist.")) : void 0;
              continue;
            }

            var nodeAlreadyExistsInConnection = (_connection$getLinked2 = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked2 === void 0 ? void 0 : _connection$getLinked2.some(function (edge) {
              var _edge$getLinkedRecord2;

              return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord2 = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord2 === void 0 ? void 0 : _edge$getLinkedRecord2.getDataID()) === serverNodeId;
            });

            if (nodeAlreadyExistsInConnection) {
              continue;
            }

            var clientEdge = ConnectionHandler.createEdge(store, connection, serverNode, edgeTypeName);
            !(clientEdge != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'MutationHandlers: Failed to build the edge.') : browser$1(false) : void 0;
            insertFn(connection, clientEdge);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      };

      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _connection$getLinked2;

        var _ret2 = _loop2();

        if (_ret2 === "continue") continue;
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  };
}

var MutationHandlers = {
  AppendEdgeHandler: AppendEdgeHandler,
  DeleteRecordHandler: DeleteRecordHandler,
  PrependEdgeHandler: PrependEdgeHandler,
  AppendNodeHandler: AppendNodeHandler,
  PrependNodeHandler: PrependNodeHandler,
  DeleteEdgeHandler: DeleteEdgeHandler
};

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails oncall+relay
 * 
 * @format
 */

var PreloadableQueryRegistry = /*#__PURE__*/function () {
  function PreloadableQueryRegistry() {
    this._preloadableQueries = new Map();
    this._callbacks = new Map();
  }

  var _proto = PreloadableQueryRegistry.prototype;

  _proto.set = function set(key, value) {
    this._preloadableQueries.set(key, value);

    var callbacks = this._callbacks.get(key);

    if (callbacks != null) {
      callbacks.forEach(function (cb) {
        try {
          cb(value);
        } catch (e) {
          // We do *not* want to throw in this tick, as this callback is executed
          // while a query is required for the very first time.
          setTimeout(function () {
            throw e;
          }, 0);
        }
      });
    }
  };

  _proto.get = function get(key) {
    return this._preloadableQueries.get(key);
  };

  _proto.onLoad = function onLoad(key, callback) {
    var _this$_callbacks$get;

    var callbacks = (_this$_callbacks$get = this._callbacks.get(key)) !== null && _this$_callbacks$get !== void 0 ? _this$_callbacks$get : new Set();
    callbacks.add(callback);

    var dispose = function dispose() {
      callbacks["delete"](callback);
    };

    this._callbacks.set(key, callbacks);

    return {
      dispose: dispose
    };
  };

  _proto.clear = function clear() {
    this._preloadableQueries.clear();
  };

  return PreloadableQueryRegistry;
}();

var preloadableQueryRegistry = new PreloadableQueryRegistry();
var PreloadableQueryRegistry_1 = preloadableQueryRegistry;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var objectSpread2 = _objectSpread2;

var _objectSpread2$1 = interopRequireDefault(objectSpread2);



/**
 * Determines the variables that are in scope for a fragment given the variables
 * in scope at the root query as well as any arguments applied at the fragment
 * spread via `@arguments`.
 *
 * Note that this is analagous to determining function arguments given a function call.
 */
function getFragmentVariables(fragment, rootVariables, argumentVariables) {
  var variables;
  fragment.argumentDefinitions.forEach(function (definition) {
    if (argumentVariables.hasOwnProperty(definition.name)) {
      return;
    } // $FlowFixMe[cannot-spread-interface]


    variables = variables || (0, _objectSpread2$1["default"])({}, argumentVariables);

    switch (definition.kind) {
      case 'LocalArgument':
        variables[definition.name] = definition.defaultValue;
        break;

      case 'RootArgument':
        if (!rootVariables.hasOwnProperty(definition.name)) {
          /*
           * Global variables passed as values of @arguments are not required to
           * be declared unless they are used by the callee fragment or a
           * descendant. In this case, the root variable may not be defined when
           * resolving the callee's variables. The value is explicitly set to
           * undefined to conform to the check in
           * RelayStoreUtils.getStableVariableValue() that variable keys are all
           * present.
           */
          // $FlowFixMe[incompatible-use]
          variables[definition.name] = undefined;
          break;
        } // $FlowFixMe[incompatible-use]
        // $FlowFixMe[cannot-write]


        variables[definition.name] = rootVariables[definition.name];
        break;

      default:
         process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.', definition.kind, fragment.name) : browser$1(false) ;
    }
  });
  return variables || argumentVariables;
}
/**
 * Determines the variables that are in scope for a given operation given values
 * for some/all of its arguments. Extraneous input variables are filtered from
 * the output, and missing variables are set to default values (if given in the
 * operation's definition).
 */


function getOperationVariables(operation, variables) {
  var operationVariables = {};
  operation.argumentDefinitions.forEach(function (def) {
    var value = def.defaultValue; // $FlowFixMe[cannot-write]

    if (variables[def.name] != null) {
      value = variables[def.name];
    }

    operationVariables[def.name] = value;
  });
  return operationVariables;
}

var RelayConcreteVariables = {
  getFragmentVariables: getFragmentVariables,
  getOperationVariables: getOperationVariables
};

var _createForOfIteratorHelper2$1 = interopRequireDefault(createForOfIteratorHelper);





var MutationTypes = Object.freeze({
  RANGE_ADD: 'RANGE_ADD',
  RANGE_DELETE: 'RANGE_DELETE',
  NODE_DELETE: 'NODE_DELETE'
});
var RangeOperations = Object.freeze({
  APPEND: 'append',
  PREPEND: 'prepend'
});

function convert(configs, request, optimisticUpdater, updater) {
  var configOptimisticUpdates = optimisticUpdater ? [optimisticUpdater] : [];
  var configUpdates = updater ? [updater] : [];
  configs.forEach(function (config) {
    switch (config.type) {
      case 'NODE_DELETE':
        var nodeDeleteResult = nodeDelete(config, request);

        if (nodeDeleteResult) {
          configOptimisticUpdates.push(nodeDeleteResult);
          configUpdates.push(nodeDeleteResult);
        }

        break;

      case 'RANGE_ADD':
        var rangeAddResult = rangeAdd(config, request);

        if (rangeAddResult) {
          configOptimisticUpdates.push(rangeAddResult);
          configUpdates.push(rangeAddResult);
        }

        break;

      case 'RANGE_DELETE':
        var rangeDeleteResult = rangeDelete(config, request);

        if (rangeDeleteResult) {
          configOptimisticUpdates.push(rangeDeleteResult);
          configUpdates.push(rangeDeleteResult);
        }

        break;
    }
  });
  return {
    optimisticUpdater: function optimisticUpdater(store, data) {
      configOptimisticUpdates.forEach(function (eachOptimisticUpdater) {
        eachOptimisticUpdater(store, data);
      });
    },
    updater: function updater(store, data) {
      configUpdates.forEach(function (eachUpdater) {
        eachUpdater(store, data);
      });
    }
  };
}

function nodeDelete(config, request) {
  var deletedIDFieldName = config.deletedIDFieldName;
  var rootField = getRootField(request);

  if (!rootField) {
    return null;
  }

  return function (store, data) {
    var payload = store.getRootField(rootField);

    if (!payload) {
      return;
    }

    var deleteID = payload.getValue(deletedIDFieldName);
    var deleteIDs = Array.isArray(deleteID) ? deleteID : [deleteID];
    deleteIDs.forEach(function (id) {
      if (id && typeof id === 'string') {
        store["delete"](id);
      }
    });
  };
}

function rangeAdd(config, request) {
  var parentID = config.parentID,
      connectionInfo = config.connectionInfo,
      edgeName = config.edgeName;

  if (!parentID) {
    process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayDeclarativeMutationConfig: For mutation config RANGE_ADD ' + 'to work you must include a parentID') : void 0;
    return null;
  }

  var rootField = getRootField(request);

  if (!connectionInfo || !rootField) {
    return null;
  }

  return function (store, data) {
    var parent = store.get(parentID);

    if (!parent) {
      return;
    }

    var payload = store.getRootField(rootField);

    if (!payload) {
      return;
    }

    var serverEdge = payload.getLinkedRecord(edgeName);

    var _iterator = (0, _createForOfIteratorHelper2$1["default"])(connectionInfo),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var info = _step.value;

        if (!serverEdge) {
          continue;
        }

        var connection = ConnectionHandler.getConnection(parent, info.key, info.filters);

        if (!connection) {
          continue;
        }

        var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);

        if (!clientEdge) {
          continue;
        }

        switch (info.rangeBehavior) {
          case 'append':
            ConnectionHandler.insertEdgeAfter(connection, clientEdge);
            break;

          case 'prepend':
            ConnectionHandler.insertEdgeBefore(connection, clientEdge);
            break;

          default:
            process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayDeclarativeMutationConfig: RANGE_ADD range behavior `%s` ' + 'will not work as expected in RelayModern, supported range ' + "behaviors are 'append', 'prepend'.", info.rangeBehavior) : void 0;
            break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };
}

function rangeDelete(config, request) {
  var parentID = config.parentID,
      connectionKeys = config.connectionKeys,
      pathToConnection = config.pathToConnection,
      deletedIDFieldName = config.deletedIDFieldName;

  if (!parentID) {
    process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayDeclarativeMutationConfig: For mutation config RANGE_DELETE ' + 'to work you must include a parentID') : void 0;
    return null;
  }

  var rootField = getRootField(request);

  if (!rootField) {
    return null;
  }

  return function (store, data) {
    if (!data) {
      return;
    }

    var deleteIDs = [];
    var deletedIDField = data[rootField];

    if (deletedIDField && Array.isArray(deletedIDFieldName)) {
      var _iterator2 = (0, _createForOfIteratorHelper2$1["default"])(deletedIDFieldName),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var eachField = _step2.value;

          if (deletedIDField && typeof deletedIDField === 'object') {
            deletedIDField = deletedIDField[eachField];
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (Array.isArray(deletedIDField)) {
        deletedIDField.forEach(function (idObject) {
          if (idObject && idObject.id && typeof idObject === 'object' && typeof idObject.id === 'string') {
            deleteIDs.push(idObject.id);
          }
        });
      } else if (deletedIDField && deletedIDField.id && typeof deletedIDField.id === 'string') {
        deleteIDs.push(deletedIDField.id);
      }
    } else if (deletedIDField && typeof deletedIDFieldName === 'string' && typeof deletedIDField === 'object') {
      deletedIDField = deletedIDField[deletedIDFieldName];

      if (typeof deletedIDField === 'string') {
        deleteIDs.push(deletedIDField);
      } else if (Array.isArray(deletedIDField)) {
        deletedIDField.forEach(function (id) {
          if (typeof id === 'string') {
            deleteIDs.push(id);
          }
        });
      }
    }

    deleteNode$1(parentID, connectionKeys, pathToConnection, store, deleteIDs);
  };
}

function deleteNode$1(parentID, connectionKeys, pathToConnection, store, deleteIDs) {
  process$1.env.NODE_ENV !== "production" ? warning_1(connectionKeys != null, 'RelayDeclarativeMutationConfig: RANGE_DELETE must provide a ' + 'connectionKeys') : void 0;
  var parent = store.get(parentID);

  if (!parent) {
    return;
  }

  if (pathToConnection.length < 2) {
    process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayDeclarativeMutationConfig: RANGE_DELETE ' + 'pathToConnection must include at least parent and connection') : void 0;
    return;
  }

  var recordProxy = parent;

  for (var i = 1; i < pathToConnection.length - 1; i++) {
    if (recordProxy) {
      recordProxy = recordProxy.getLinkedRecord(pathToConnection[i]);
    }
  } // Should never enter loop except edge cases


  if (!connectionKeys || !recordProxy) {
    process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayDeclarativeMutationConfig: RANGE_DELETE ' + 'pathToConnection is incorrect. Unable to find connection with ' + 'parentID: %s and path: %s', parentID, pathToConnection.toString()) : void 0;
    return;
  }

  var _iterator3 = (0, _createForOfIteratorHelper2$1["default"])(connectionKeys),
      _step3;

  try {
    var _loop = function _loop() {
      var key = _step3.value;
      var connection = ConnectionHandler.getConnection(recordProxy, key.key, key.filters);

      if (connection) {
        deleteIDs.forEach(function (deleteID) {
          ConnectionHandler.deleteNode(connection, deleteID);
        });
      }
    };

    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}

function getRootField(request) {
  if (request.fragment.selections && request.fragment.selections.length > 0 && request.fragment.selections[0].kind === 'LinkedField') {
    return request.fragment.selections[0].name;
  }

  return null;
}

var RelayDeclarativeMutationConfig = {
  MutationTypes: MutationTypes,
  RangeOperations: RangeOperations,
  convert: convert
};

function RelayDefaultHandlerProvider(handle) {
  switch (handle) {
    case 'connection':
      return ConnectionHandler;

    case 'deleteRecord':
      return MutationHandlers.DeleteRecordHandler;

    case 'deleteEdge':
      return MutationHandlers.DeleteEdgeHandler;

    case 'appendEdge':
      return MutationHandlers.AppendEdgeHandler;

    case 'prependEdge':
      return MutationHandlers.PrependEdgeHandler;

    case 'appendNode':
      return MutationHandlers.AppendNodeHandler;

    case 'prependNode':
      return MutationHandlers.PrependNodeHandler;
  }

   process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayDefaultHandlerProvider: No handler provided for `%s`.', handle) : browser$1(false) ;
}

var RelayDefaultHandlerProvider_1 = RelayDefaultHandlerProvider;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
/**
 * @private
 */

function createError(type, name, messageFormat) {
  for (var _len = arguments.length, messageParams = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    messageParams[_key - 3] = arguments[_key];
  }

  var index = 0;
  var message = messageFormat.replace(/%s/g, function () {
    return String(messageParams[index++]);
  });
  var err = new Error(message);
  var error = Object.assign(err, {
    name: name,
    messageFormat: messageFormat,
    messageParams: messageParams,
    type: type,
    taalOpcodes: [2, 2] // skip frame (code=2) twice

  }); // In V8, Error objects keep the closure scope chain alive until the
  // err.stack property is accessed.

  if (error.stack === undefined) {
    // IE sets the stack only if error is thrown
    try {
      throw error;
    } catch (_unused) {}
  }

  return error;
}

var RelayError = {
  create: function create(name, messageFormat) {
    for (var _len2 = arguments.length, messageParams = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      messageParams[_key2 - 2] = arguments[_key2];
    }

    return createError.apply(void 0, ['error', name, messageFormat].concat(messageParams));
  },
  createWarning: function createWarning(name, messageFormat) {
    for (var _len3 = arguments.length, messageParams = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      messageParams[_key3 - 2] = arguments[_key3];
    }

    return createError.apply(void 0, ['warn', name, messageFormat].concat(messageParams));
  }
};

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var RelayFeatureFlags = {
  ENABLE_VARIABLE_CONNECTION_KEY: false,
  ENABLE_PARTIAL_RENDERING_DEFAULT: true,
  ENABLE_RELAY_CONTAINERS_SUSPENSE: true,
  ENABLE_PRECISE_TYPE_REFINEMENT: false,
  ENABLE_REACT_FLIGHT_COMPONENT_FIELD: false,
  ENABLE_REQUIRED_DIRECTIVES: false,
  ENABLE_RELAY_RESOLVERS: false,
  ENABLE_GETFRAGMENTIDENTIFIER_OPTIMIZATION: false,
  ENABLE_FRIENDLY_QUERY_NAME_GQL_URL: false,
  ENABLE_STORE_SUBSCRIPTIONS_REFACTOR: false,
  ENABLE_LOAD_QUERY_REQUEST_DEDUPING: true,
  ENABLE_DO_NOT_WRAP_LIVE_QUERY: false,
  ENABLE_NOTIFY_SUBSCRIPTION: false,
  ENABLE_UNIQUE_SUBSCRIPTION_ROOT: false,
  ENABLE_BATCHED_STORE_UPDATES: false
};
var RelayFeatureFlags_1 = RelayFeatureFlags;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var aStackPool = [];
var bStackPool = [];
/**
 * Checks if two values are equal. Values may be primitives, arrays, or objects.
 * Returns true if both arguments have the same keys and values.
 *
 * @see http://underscorejs.org
 * @copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * @license MIT
 */

function areEqual(a, b) {
  var aStack = aStackPool.length ? aStackPool.pop() : [];
  var bStack = bStackPool.length ? bStackPool.pop() : [];
  var result = eq(a, b, aStack, bStack);
  aStack.length = 0;
  bStack.length = 0;
  aStackPool.push(aStack);
  bStackPool.push(bStack);
  return result;
}

function eq(a, b, aStack, bStack) {
  if (a === b) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    return a !== 0 || 1 / a == 1 / b;
  }

  if (a == null || b == null) {
    // a or b can be `null` or `undefined`
    return false;
  }

  if (typeof a != 'object' || typeof b != 'object') {
    return false;
  }

  var objToStr = Object.prototype.toString;
  var className = objToStr.call(a);

  if (className != objToStr.call(b)) {
    return false;
  }

  switch (className) {
    case '[object String]':
      return a == String(b);

    case '[object Number]':
      return isNaN(a) || isNaN(b) ? false : a == Number(b);

    case '[object Date]':
    case '[object Boolean]':
      return +a == +b;

    case '[object RegExp]':
      return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
  } // Assume equality for cyclic structures.


  var length = aStack.length;

  while (length--) {
    if (aStack[length] == a) {
      return bStack[length] == b;
    }
  }

  aStack.push(a);
  bStack.push(b);
  var size = 0; // Recursively compare objects and arrays.

  if (className === '[object Array]') {
    size = a.length;

    if (size !== b.length) {
      return false;
    } // Deep compare the contents, ignoring non-numeric properties.


    while (size--) {
      if (!eq(a[size], b[size], aStack, bStack)) {
        return false;
      }
    }
  } else {
    if (a.constructor !== b.constructor) {
      return false;
    }

    if (a.hasOwnProperty('valueOf') && b.hasOwnProperty('valueOf')) {
      return a.valueOf() == b.valueOf();
    }

    var keys = Object.keys(a);

    if (keys.length != Object.keys(b).length) {
      return false;
    }

    for (var i = 0; i < keys.length; i++) {
      if (!eq(a[keys[i]], b[keys[i]], aStack, bStack)) {
        return false;
      }
    }
  }

  aStack.pop();
  bStack.pop();
  return true;
}

var areEqual_1 = areEqual;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
/**
 * Recursively "deep" freezes the supplied object.
 *
 * For convenience, and for consistency with the behavior of `Object.freeze`,
 * returns the now-frozen original object.
 */

function deepFreeze(object) {
  Object.freeze(object);
  Object.getOwnPropertyNames(object).forEach(function (name) {
    // $FlowFixMe[prop-missing]
    var property = object[name];

    if (property && typeof property === 'object' && !Object.isFrozen(property)) {
      deepFreeze(property);
    }
  });
  return object;
}

var deepFreeze_1 = deepFreeze;

var _objectSpread2$2 = interopRequireDefault(objectSpread2);









var isClientID$1 = ClientID.isClientID;

var ID_KEY = RelayStoreUtils_1.ID_KEY,
    REF_KEY = RelayStoreUtils_1.REF_KEY,
    REFS_KEY = RelayStoreUtils_1.REFS_KEY,
    TYPENAME_KEY = RelayStoreUtils_1.TYPENAME_KEY,
    INVALIDATED_AT_KEY = RelayStoreUtils_1.INVALIDATED_AT_KEY,
    ROOT_ID = RelayStoreUtils_1.ROOT_ID;

/**
 * @public
 *
 * Low-level record manipulation methods.
 *
 * A note about perf: we use long-hand property access rather than computed
 * properties in this file for speed ie.
 *
 *    const object = {};
 *    object[KEY] = value;
 *    record[storageKey] = object;
 *
 * instead of:
 *
 *    record[storageKey] = {
 *      [KEY]: value,
 *    };
 *
 * The latter gets transformed by Babel into something like:
 *
 *    function _defineProperty(obj, key, value) {
 *      if (key in obj) {
 *        Object.defineProperty(obj, key, {
 *          value: value,
 *          enumerable: true,
 *          configurable: true,
 *          writable: true,
 *        });
 *      } else {
 *        obj[key] = value;
 *      }
 *      return obj;
 *    }
 *
 *    record[storageKey] = _defineProperty({}, KEY, value);
 *
 * A quick benchmark shows that computed property access is an order of
 * magnitude slower (times in seconds for 100,000 iterations):
 *
 *               best     avg     sd
 *    computed 0.02175 0.02292 0.00113
 *      manual 0.00110 0.00123 0.00008
 */

/**
 * @public
 *
 * Clone a record.
 */
function clone(record) {
  return (0, _objectSpread2$2["default"])({}, record);
}
/**
 * @public
 *
 * Copies all fields from `source` to `sink`, excluding `__id` and `__typename`.
 *
 * NOTE: This function does not treat `id` specially. To preserve the id,
 * manually reset it after calling this function. Also note that values are
 * copied by reference and not value; callers should ensure that values are
 * copied on write.
 */


function copyFields(source, sink) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      if (key !== ID_KEY && key !== TYPENAME_KEY) {
        sink[key] = source[key];
      }
    }
  }
}
/**
 * @public
 *
 * Create a new record.
 */


function create(dataID, typeName) {
  // See perf note above for why we aren't using computed property access.
  var record = {};
  record[ID_KEY] = dataID;
  record[TYPENAME_KEY] = typeName;
  return record;
}
/**
 * @public
 *
 * Get the record's `id` if available or the client-generated identifier.
 */


function getDataID(record) {
  return record[ID_KEY];
}
/**
 * @public
 *
 * Get the concrete type of the record.
 */


function getType(record) {
  return record[TYPENAME_KEY];
}
/**
 * @public
 *
 * Get a scalar (non-link) field value.
 */


function getValue(record, storageKey) {
  var value = record[storageKey];

  if (value && typeof value === 'object') {
    !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` ' + 'but found %s.', record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? 'a linked record' : 'plural linked records') : browser$1(false) : void 0;
  }

  return value;
}
/**
 * @public
 *
 * Get the value of a field as a reference to another record. Throws if the
 * field has a different type.
 */


function getLinkedRecordID(record, storageKey) {
  var link = record[storageKey];

  if (link == null) {
    return link;
  }

  !(typeof link === 'object' && link && typeof link[REF_KEY] === 'string') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : browser$1(false) : void 0;
  return link[REF_KEY];
}
/**
 * @public
 *
 * Get the value of a field as a list of references to other records. Throws if
 * the field has a different type.
 */


function getLinkedRecordIDs(record, storageKey) {
  var links = record[storageKey];

  if (links == null) {
    return links;
  }

  !(typeof links === 'object' && Array.isArray(links[REFS_KEY])) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array ' + 'of linked IDs, got `%s`.', record[ID_KEY], storageKey, JSON.stringify(links)) : browser$1(false) : void 0; // assume items of the array are ids

  return links[REFS_KEY];
}
/**
 * @public
 *
 * Returns the epoch at which the record was invalidated, if it
 * ever was; otherwise returns null;
 */


function getInvalidationEpoch(record) {
  if (record == null) {
    return null;
  }

  var invalidatedAt = record[INVALIDATED_AT_KEY];

  if (typeof invalidatedAt !== 'number') {
    // If the record has never been invalidated, it isn't stale.
    return null;
  }

  return invalidatedAt;
}
/**
 * @public
 *
 * Compares the fields of a previous and new record, returning either the
 * previous record if all fields are equal or a new record (with merged fields)
 * if any fields have changed.
 */


function update$1(prevRecord, nextRecord) {
  if (process$1.env.NODE_ENV !== "production") {
    var _getType, _getType2;

    var prevID = getDataID(prevRecord);
    var nextID = getDataID(nextRecord);
    process$1.env.NODE_ENV !== "production" ? warning_1(prevID === nextID, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null

    var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;
    var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;
    process$1.env.NODE_ENV !== "production" ? warning_1(isClientID$1(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;
  }

  var updated = null;
  var keys = Object.keys(nextRecord);

  for (var ii = 0; ii < keys.length; ii++) {
    var key = keys[ii];

    if (updated || !areEqual_1(prevRecord[key], nextRecord[key])) {
      updated = updated !== null ? updated : (0, _objectSpread2$2["default"])({}, prevRecord);
      updated[key] = nextRecord[key];
    }
  }

  return updated !== null ? updated : prevRecord;
}
/**
 * @public
 *
 * Returns a new record with the contents of the given records. Fields in the
 * second record will overwrite identical fields in the first record.
 */


function merge(record1, record2) {
  if (process$1.env.NODE_ENV !== "production") {
    var _getType3, _getType4;

    var prevID = getDataID(record1);
    var nextID = getDataID(record2);
    process$1.env.NODE_ENV !== "production" ? warning_1(prevID === nextID, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null

    var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;
    var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;
    process$1.env.NODE_ENV !== "production" ? warning_1(isClientID$1(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;
  }

  return Object.assign({}, record1, record2);
}
/**
 * @public
 *
 * Prevent modifications to the record. Attempts to call `set*` functions on a
 * frozen record will fatal at runtime.
 */


function freeze(record) {
  deepFreeze_1(record);
}
/**
 * @public
 *
 * Set the value of a storageKey to a scalar.
 */


function setValue(record, storageKey, value) {
  if (process$1.env.NODE_ENV !== "production") {
    var prevID = getDataID(record);

    if (storageKey === ID_KEY) {
      process$1.env.NODE_ENV !== "production" ? warning_1(prevID === value, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, value) : void 0;
    } else if (storageKey === TYPENAME_KEY) {
      var _getType5;

      // note: coalesce null/undefined to null
      var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;
      var nextType = value !== null && value !== void 0 ? value : null;
      process$1.env.NODE_ENV !== "production" ? warning_1(isClientID$1(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;
    }
  }

  record[storageKey] = value;
}
/**
 * @public
 *
 * Set the value of a field to a reference to another record.
 */


function setLinkedRecordID(record, storageKey, linkedID) {
  // See perf note above for why we aren't using computed property access.
  var link = {};
  link[REF_KEY] = linkedID;
  record[storageKey] = link;
}
/**
 * @public
 *
 * Set the value of a field to a list of references other records.
 */


function setLinkedRecordIDs(record, storageKey, linkedIDs) {
  // See perf note above for why we aren't using computed property access.
  var links = {};
  links[REFS_KEY] = linkedIDs;
  record[storageKey] = links;
}

var RelayModernRecord = {
  clone: clone,
  copyFields: copyFields,
  create: create,
  freeze: freeze,
  getDataID: getDataID,
  getInvalidationEpoch: getInvalidationEpoch,
  getLinkedRecordID: getLinkedRecordID,
  getLinkedRecordIDs: getLinkedRecordIDs,
  getType: getType,
  getValue: getValue,
  merge: merge,
  setValue: setValue,
  setLinkedRecordID: setLinkedRecordID,
  setLinkedRecordIDs: setLinkedRecordIDs,
  update: update$1
};

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

function isPromise(p) {
  return !!p && typeof p.then === 'function';
}

var isPromise_1 = isPromise;

/**
 * A Subscription object is returned from .subscribe(), which can be
 * unsubscribed or checked to see if the resulting subscription has closed.
 */


var hostReportError = swallowError;
/**
 * Limited implementation of ESObservable, providing the limited set of behavior
 * Relay networking requires.
 *
 * Observables retain the benefit of callbacks which can be called
 * synchronously, avoiding any UI jitter, while providing a compositional API,
 * which simplifies logic and prevents mishandling of errors compared to
 * the direct use of callback functions.
 *
 * ESObservable: https://github.com/tc39/proposal-observable
 */

var RelayObservable = /*#__PURE__*/function () {
  RelayObservable.create = function create(source) {
    return new RelayObservable(source);
  } // Use RelayObservable.create()
  ;

  function RelayObservable(source) {
    if (process$1.env.NODE_ENV !== "production") {
      // Early runtime errors for ill-formed sources.
      if (!source || typeof source !== 'function') {
        throw new Error('Source must be a Function: ' + String(source));
      }
    }

    this._source = source;
  }
  /**
   * When an emitted error event is not handled by an Observer, it is reported
   * to the host environment (what the ESObservable spec refers to as
   * "HostReportErrors()").
   *
   * The default implementation in development rethrows thrown errors, and
   * logs emitted error events to the console, while in production does nothing
   * (swallowing unhandled errors).
   *
   * Called during application initialization, this method allows
   * application-specific handling of unhandled errors. Allowing, for example,
   * integration with error logging or developer tools.
   *
   * A second parameter `isUncaughtThrownError` is true when the unhandled error
   * was thrown within an Observer handler, and false when the unhandled error
   * was an unhandled emitted event.
   *
   *  - Uncaught thrown errors typically represent avoidable errors thrown from
   *    application code, which should be handled with a try/catch block, and
   *    usually have useful stack traces.
   *
   *  - Unhandled emitted event errors typically represent unavoidable events in
   *    application flow such as network failure, and may not have useful
   *    stack traces.
   */


  RelayObservable.onUnhandledError = function onUnhandledError(callback) {
    hostReportError = callback;
  }
  /**
   * Accepts various kinds of data sources, and always returns a RelayObservable
   * useful for accepting the result of a user-provided FetchFunction.
   */
  ;

  RelayObservable.from = function from(obj) {
    return isObservable(obj) ? fromObservable(obj) : isPromise_1(obj) ? fromPromise(obj) : fromValue(obj);
  }
  /**
   * Similar to promise.catch(), observable.catch() handles error events, and
   * provides an alternative observable to use in it's place.
   *
   * If the catch handler throws a new error, it will appear as an error event
   * on the resulting Observable.
   */
  ;

  var _proto = RelayObservable.prototype;

  _proto["catch"] = function _catch(fn) {
    var _this = this;

    return RelayObservable.create(function (sink) {
      var subscription;

      _this.subscribe({
        start: function start(sub) {
          subscription = sub;
        },
        next: sink.next,
        complete: sink.complete,
        error: function error(_error2) {
          try {
            fn(_error2).subscribe({
              start: function start(sub) {
                subscription = sub;
              },
              next: sink.next,
              complete: sink.complete,
              error: sink.error
            });
          } catch (error2) {
            sink.error(error2, true
            /* isUncaughtThrownError */
            );
          }
        }
      });

      return function () {
        return subscription.unsubscribe();
      };
    });
  }
  /**
   * Returns a new Observable which first yields values from this Observable,
   * then yields values from the next Observable. This is useful for chaining
   * together Observables of finite length.
   */
  ;

  _proto.concat = function concat(next) {
    var _this2 = this;

    return RelayObservable.create(function (sink) {
      var current;

      _this2.subscribe({
        start: function start(subscription) {
          current = subscription;
        },
        next: sink.next,
        error: sink.error,
        complete: function complete() {
          current = next.subscribe(sink);
        }
      });

      return function () {
        current && current.unsubscribe();
      };
    });
  }
  /**
   * Returns a new Observable which returns the same values as this one, but
   * modified so that the provided Observer is called to perform a side-effects
   * for all events emitted by the source.
   *
   * Any errors that are thrown in the side-effect Observer are unhandled, and
   * do not affect the source Observable or its Observer.
   *
   * This is useful for when debugging your Observables or performing other
   * side-effects such as logging or performance monitoring.
   */
  ;

  _proto["do"] = function _do(observer) {
    var _this3 = this;

    return RelayObservable.create(function (sink) {
      var both = function both(action) {
        return function () {
          try {
            observer[action] && observer[action].apply(observer, arguments);
          } catch (error) {
            hostReportError(error, true
            /* isUncaughtThrownError */
            );
          }

          sink[action] && sink[action].apply(sink, arguments);
        };
      };

      return _this3.subscribe({
        start: both('start'),
        next: both('next'),
        error: both('error'),
        complete: both('complete'),
        unsubscribe: both('unsubscribe')
      });
    });
  }
  /**
   * Returns a new Observable which returns the same values as this one, but
   * modified so that the finally callback is performed after completion,
   * whether normal or due to error or unsubscription.
   *
   * This is useful for cleanup such as resource finalization.
   */
  ;

  _proto["finally"] = function _finally(fn) {
    var _this4 = this;

    return RelayObservable.create(function (sink) {
      var subscription = _this4.subscribe(sink);

      return function () {
        subscription.unsubscribe();
        fn();
      };
    });
  }
  /**
   * Returns a new Observable which is identical to this one, unless this
   * Observable completes before yielding any values, in which case the new
   * Observable will yield the values from the alternate Observable.
   *
   * If this Observable does yield values, the alternate is never subscribed to.
   *
   * This is useful for scenarios where values may come from multiple sources
   * which should be tried in order, i.e. from a cache before a network.
   */
  ;

  _proto.ifEmpty = function ifEmpty(alternate) {
    var _this5 = this;

    return RelayObservable.create(function (sink) {
      var hasValue = false;

      var current = _this5.subscribe({
        next: function next(value) {
          hasValue = true;
          sink.next(value);
        },
        error: sink.error,
        complete: function complete() {
          if (hasValue) {
            sink.complete();
          } else {
            current = alternate.subscribe(sink);
          }
        }
      });

      return function () {
        current.unsubscribe();
      };
    });
  }
  /**
   * Observable's primary API: returns an unsubscribable Subscription to the
   * source of this Observable.
   *
   * Note: A sink may be passed directly to .subscribe() as its observer,
   * allowing for easily composing Observables.
   */
  ;

  _proto.subscribe = function subscribe(observer) {
    if (process$1.env.NODE_ENV !== "production") {
      // Early runtime errors for ill-formed observers.
      if (!observer || typeof observer !== 'object') {
        throw new Error('Observer must be an Object with callbacks: ' + String(observer));
      }
    }

    return _subscribe(this._source, observer);
  }
  /**
   * Returns a new Observerable where each value has been transformed by
   * the mapping function.
   */
  ;

  _proto.map = function map(fn) {
    var _this6 = this;

    return RelayObservable.create(function (sink) {
      var subscription = _this6.subscribe({
        complete: sink.complete,
        error: sink.error,
        next: function next(value) {
          try {
            var mapValue = fn(value);
            sink.next(mapValue);
          } catch (error) {
            sink.error(error, true
            /* isUncaughtThrownError */
            );
          }
        }
      });

      return function () {
        subscription.unsubscribe();
      };
    });
  }
  /**
   * Returns a new Observable where each value is replaced with a new Observable
   * by the mapping function, the results of which returned as a single
   * merged Observable.
   */
  ;

  _proto.mergeMap = function mergeMap(fn) {
    var _this7 = this;

    return RelayObservable.create(function (sink) {
      var subscriptions = [];

      function start(subscription) {
        this._sub = subscription;
        subscriptions.push(subscription);
      }

      function complete() {
        subscriptions.splice(subscriptions.indexOf(this._sub), 1);

        if (subscriptions.length === 0) {
          sink.complete();
        }
      }

      _this7.subscribe({
        start: start,
        next: function next(value) {
          try {
            if (!sink.closed) {
              RelayObservable.from(fn(value)).subscribe({
                start: start,
                next: sink.next,
                error: sink.error,
                complete: complete
              });
            }
          } catch (error) {
            sink.error(error, true
            /* isUncaughtThrownError */
            );
          }
        },
        error: sink.error,
        complete: complete
      });

      return function () {
        subscriptions.forEach(function (sub) {
          return sub.unsubscribe();
        });
        subscriptions.length = 0;
      };
    });
  }
  /**
   * Returns a new Observable which first mirrors this Observable, then when it
   * completes, waits for `pollInterval` milliseconds before re-subscribing to
   * this Observable again, looping in this manner until unsubscribed.
   *
   * The returned Observable never completes.
   */
  ;

  _proto.poll = function poll(pollInterval) {
    var _this8 = this;

    if (process$1.env.NODE_ENV !== "production") {
      if (typeof pollInterval !== 'number' || pollInterval <= 0) {
        throw new Error('RelayObservable: Expected pollInterval to be positive, got: ' + pollInterval);
      }
    }

    return RelayObservable.create(function (sink) {
      var subscription;
      var timeout;

      var poll = function poll() {
        subscription = _this8.subscribe({
          next: sink.next,
          error: sink.error,
          complete: function complete() {
            timeout = setTimeout(poll, pollInterval);
          }
        });
      };

      poll();
      return function () {
        clearTimeout(timeout);
        subscription.unsubscribe();
      };
    });
  }
  /**
   * Returns a Promise which resolves when this Observable yields a first value
   * or when it completes with no value.
   *
   * NOTE: The source Observable is *NOT* canceled when the returned Promise
   * resolves. The Observable is always run to completion.
   */
  ;

  _proto.toPromise = function toPromise() {
    var _this9 = this;

    return new Promise(function (resolve, reject) {
      var resolved = false;

      _this9.subscribe({
        next: function next(val) {
          if (!resolved) {
            resolved = true;
            resolve(val);
          }
        },
        error: reject,
        complete: resolve
      });
    });
  };

  return RelayObservable;
}(); // Use declarations to teach Flow how to check isObservable.


function isObservable(obj) {
  return typeof obj === 'object' && obj !== null && typeof obj.subscribe === 'function';
}

function fromObservable(obj) {
  return obj instanceof RelayObservable ? obj : RelayObservable.create(function (sink) {
    return obj.subscribe(sink);
  });
}

function fromPromise(promise) {
  return RelayObservable.create(function (sink) {
    // Since sink methods do not throw, the resulting Promise can be ignored.
    promise.then(function (value) {
      sink.next(value);
      sink.complete();
    }, sink.error);
  });
}

function fromValue(value) {
  return RelayObservable.create(function (sink) {
    sink.next(value);
    sink.complete();
  });
}

function _subscribe(source, observer) {
  var closed = false;
  var cleanup; // Ideally we would simply describe a `get closed()` method on the Sink and
  // Subscription objects below, however not all flow environments we expect
  // Relay to be used within will support property getters, and many minifier
  // tools still do not support ES5 syntax. Instead, we can use defineProperty.

  var withClosed = function withClosed(obj) {
    return Object.defineProperty(obj, 'closed', {
      get: function get() {
        return closed;
      }
    });
  };

  function doCleanup() {
    if (cleanup) {
      if (cleanup.unsubscribe) {
        cleanup.unsubscribe();
      } else {
        try {
          cleanup();
        } catch (error) {
          hostReportError(error, true
          /* isUncaughtThrownError */
          );
        }
      }

      cleanup = undefined;
    }
  } // Create a Subscription.


  var subscription = withClosed({
    unsubscribe: function unsubscribe() {
      if (!closed) {
        closed = true; // Tell Observer that unsubscribe was called.

        try {
          observer.unsubscribe && observer.unsubscribe(subscription);
        } catch (error) {
          hostReportError(error, true
          /* isUncaughtThrownError */
          );
        } finally {
          doCleanup();
        }
      }
    }
  }); // Tell Observer that observation is about to begin.

  try {
    observer.start && observer.start(subscription);
  } catch (error) {
    hostReportError(error, true
    /* isUncaughtThrownError */
    );
  } // If closed already, don't bother creating a Sink.


  if (closed) {
    return subscription;
  } // Create a Sink respecting subscription state and cleanup.


  var sink = withClosed({
    next: function next(value) {
      if (!closed && observer.next) {
        try {
          observer.next(value);
        } catch (error) {
          hostReportError(error, true
          /* isUncaughtThrownError */
          );
        }
      }
    },
    error: function error(_error3, isUncaughtThrownError) {
      if (closed || !observer.error) {
        closed = true;
        hostReportError(_error3, isUncaughtThrownError || false);
        doCleanup();
      } else {
        closed = true;

        try {
          observer.error(_error3);
        } catch (error2) {
          hostReportError(error2, true
          /* isUncaughtThrownError */
          );
        } finally {
          doCleanup();
        }
      }
    },
    complete: function complete() {
      if (!closed) {
        closed = true;

        try {
          observer.complete && observer.complete();
        } catch (error) {
          hostReportError(error, true
          /* isUncaughtThrownError */
          );
        } finally {
          doCleanup();
        }
      }
    }
  }); // If anything goes wrong during observing the source, handle the error.

  try {
    cleanup = source(sink);
  } catch (error) {
    sink.error(error, true
    /* isUncaughtThrownError */
    );
  }

  if (process$1.env.NODE_ENV !== "production") {
    // Early runtime errors for ill-formed returned cleanup.
    if (cleanup !== undefined && typeof cleanup !== 'function' && (!cleanup || typeof cleanup.unsubscribe !== 'function')) {
      throw new Error('Returned cleanup function which cannot be called: ' + String(cleanup));
    }
  } // If closed before the source function existed, cleanup now.


  if (closed) {
    doCleanup();
  }

  return subscription;
}

function swallowError(_error, _isUncaughtThrownError) {// do nothing.
}

if (process$1.env.NODE_ENV !== "production") {
  // Default implementation of HostReportErrors() in development builds.
  // Can be replaced by the host application environment.
  RelayObservable.onUnhandledError(function (error, isUncaughtThrownError) {
    if (typeof fail === 'function') {
      // In test environments (Jest), fail() immediately fails the current test.
      fail(String(error));
    } else if (isUncaughtThrownError) {
      // Rethrow uncaught thrown errors on the next frame to avoid breaking
      // current logic.
      setTimeout(function () {
        throw error;
      });
    } else if (typeof console !== 'undefined') {
      // Otherwise, log the unhandled error for visibility.
      // eslint-disable-next-line no-console
      console.error('RelayObservable: Unhandled Error', error);
    }
  });
}

var RelayObservable_1 = RelayObservable;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var RelayRecordState = {
  /**
   * Record exists (either fetched from the server or produced by a local,
   * optimistic update).
   */
  EXISTENT: 'EXISTENT',

  /**
   * Record is known not to exist (either as the result of a mutation, or
   * because the server returned `null` when queried for the record).
   */
  NONEXISTENT: 'NONEXISTENT',

  /**
   * Record State is unknown because it has not yet been fetched from the
   * server.
   */
  UNKNOWN: 'UNKNOWN'
};
var RelayRecordState_1 = RelayRecordState;

var _createForOfIteratorHelper2$2 = interopRequireDefault(createForOfIteratorHelper);



var EXISTENT = RelayRecordState_1.EXISTENT,
    NONEXISTENT = RelayRecordState_1.NONEXISTENT,
    UNKNOWN = RelayRecordState_1.UNKNOWN;
/**
 * An implementation of the `MutableRecordSource` interface (defined in
 * `RelayStoreTypes`) that holds all records in memory (JS Map).
 */

var RelayMapRecordSourceMapImpl = /*#__PURE__*/function () {
  function RelayMapRecordSourceMapImpl(records) {
    var _this = this;

    this._records = new Map();

    if (records != null) {
      Object.keys(records).forEach(function (key) {
        _this._records.set(key, records[key]);
      });
    }
  }

  var _proto = RelayMapRecordSourceMapImpl.prototype;

  _proto.clear = function clear() {
    this._records = new Map();
  };

  _proto["delete"] = function _delete(dataID) {
    this._records.set(dataID, null);
  };

  _proto.get = function get(dataID) {
    return this._records.get(dataID);
  };

  _proto.getRecordIDs = function getRecordIDs() {
    return Array.from(this._records.keys());
  };

  _proto.getStatus = function getStatus(dataID) {
    if (!this._records.has(dataID)) {
      return UNKNOWN;
    }

    return this._records.get(dataID) == null ? NONEXISTENT : EXISTENT;
  };

  _proto.has = function has(dataID) {
    return this._records.has(dataID);
  };

  _proto.remove = function remove(dataID) {
    this._records["delete"](dataID);
  };

  _proto.set = function set(dataID, record) {
    this._records.set(dataID, record);
  };

  _proto.size = function size() {
    return this._records.size;
  };

  _proto.toJSON = function toJSON() {
    var obj = {};

    var _iterator = (0, _createForOfIteratorHelper2$2["default"])(this._records),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _step.value,
            key = _step$value[0],
            value = _step$value[1];
        obj[key] = value;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return obj;
  };

  return RelayMapRecordSourceMapImpl;
}();

var RelayRecordSourceMapImpl = RelayMapRecordSourceMapImpl;

var RelayRecordSource = /*#__PURE__*/function () {
  function RelayRecordSource(records) {
    return RelayRecordSource.create(records);
  }

  RelayRecordSource.create = function create(records) {
    return new RelayRecordSourceMapImpl(records);
  };

  return RelayRecordSource;
}();

var RelayRecordSource_1 = RelayRecordSource;

var getFragmentVariables$1 = RelayConcreteVariables.getFragmentVariables;

var FRAGMENT_OWNER_KEY = RelayStoreUtils_1.FRAGMENT_OWNER_KEY,
    FRAGMENTS_KEY = RelayStoreUtils_1.FRAGMENTS_KEY,
    ID_KEY$1 = RelayStoreUtils_1.ID_KEY,
    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = RelayStoreUtils_1.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT;

/**
 * @public
 *
 * Given the result `item` from a parent that fetched `fragment`, creates a
 * selector that can be used to read the results of that fragment for that item.
 *
 * Example:
 *
 * Given two fragments as follows:
 *
 * ```
 * fragment Parent on User {
 *   id
 *   ...Child
 * }
 * fragment Child on User {
 *   name
 * }
 * ```
 *
 * And given some object `parent` that is the results of `Parent` for id "4",
 * the results of `Child` can be accessed by first getting a selector and then
 * using that selector to `lookup()` the results against the environment:
 *
 * ```
 * const childSelector = getSingularSelector(queryVariables, Child, parent);
 * const childData = environment.lookup(childSelector).data;
 * ```
 */
function getSingularSelector(fragment, item) {
  !(typeof item === 'object' && item !== null && !Array.isArray(item)) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernSelector: Expected value for fragment `%s` to be an object, got ' + '`%s`.', fragment.name, JSON.stringify(item)) : browser$1(false) : void 0;
  var dataID = item[ID_KEY$1];
  var fragments = item[FRAGMENTS_KEY];
  var mixedOwner = item[FRAGMENT_OWNER_KEY];
  var isWithinUnmatchedTypeRefinement = item[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] === true;

  if (typeof dataID === 'string' && typeof fragments === 'object' && fragments !== null && typeof fragments[fragment.name] === 'object' && fragments[fragment.name] !== null && typeof mixedOwner === 'object' && mixedOwner !== null) {
    var owner = mixedOwner;
    var argumentVariables = fragments[fragment.name];
    var fragmentVariables = getFragmentVariables$1(fragment, owner.variables, argumentVariables);
    return createReaderSelector(fragment, dataID, fragmentVariables, owner, isWithinUnmatchedTypeRefinement);
  }

  if (process$1.env.NODE_ENV !== "production") {
    var stringifiedItem = JSON.stringify(item);

    if (stringifiedItem.length > 499) {
      stringifiedItem = stringifiedItem.substr(0, 498) + "\u2026";
    }

    process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayModernSelector: Expected object to contain data for fragment `%s`, got ' + '`%s`. Make sure that the parent operation/fragment included fragment ' + '`...%s` without `@relay(mask: false)`.', fragment.name, stringifiedItem, fragment.name) : void 0;
  }

  return null;
}
/**
 * @public
 *
 * Given the result `items` from a parent that fetched `fragment`, creates a
 * selector that can be used to read the results of that fragment on those
 * items. This is similar to `getSingularSelector` but for "plural" fragments that
 * expect an array of results and therefore return an array of selectors.
 */


function getPluralSelector(fragment, items) {
  var selectors = null;
  items.forEach(function (item, ii) {
    var selector = item != null ? getSingularSelector(fragment, item) : null;

    if (selector != null) {
      selectors = selectors || [];
      selectors.push(selector);
    }
  });

  if (selectors == null) {
    return null;
  } else {
    return {
      kind: 'PluralReaderSelector',
      selectors: selectors
    };
  }
}

function getSelector(fragment, item) {
  if (item == null) {
    return item;
  } else if (fragment.metadata && fragment.metadata.plural === true) {
    !Array.isArray(item) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. ' + 'Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.', fragment.name, JSON.stringify(item), fragment.name) : browser$1(false) : void 0;
    return getPluralSelector(fragment, item);
  } else {
    !!Array.isArray(item) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernSelector: Expected value for fragment `%s` to be an object, got `%s`. ' + 'Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.', fragment.name, JSON.stringify(item), fragment.name) : browser$1(false) : void 0;
    return getSingularSelector(fragment, item);
  }
}
/**
 * @public
 *
 * Given a mapping of keys -> results and a mapping of keys -> fragments,
 * extracts the selectors for those fragments from the results.
 *
 * The canonical use-case for this function is ReactRelayFragmentContainer, which
 * uses this function to convert (props, fragments) into selectors so that it
 * can read the results to pass to the inner component.
 */


function getSelectorsFromObject(fragments, object) {
  var selectors = {};

  for (var _key in fragments) {
    if (fragments.hasOwnProperty(_key)) {
      var fragment = fragments[_key];
      var item = object[_key];
      selectors[_key] = getSelector(fragment, item);
    }
  }

  return selectors;
}
/**
 * @public
 *
 * Given a mapping of keys -> results and a mapping of keys -> fragments,
 * extracts a mapping of keys -> id(s) of the results.
 *
 * Similar to `getSelectorsFromObject()`, this function can be useful in
 * determining the "identity" of the props passed to a component.
 */


function getDataIDsFromObject(fragments, object) {
  var ids = {};

  for (var _key2 in fragments) {
    if (fragments.hasOwnProperty(_key2)) {
      var fragment = fragments[_key2];
      var item = object[_key2];
      ids[_key2] = getDataIDsFromFragment(fragment, item);
    }
  }

  return ids;
}

function getDataIDsFromFragment(fragment, item) {
  if (item == null) {
    return item;
  } else if (fragment.metadata && fragment.metadata.plural === true) {
    !Array.isArray(item) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. ' + 'Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.', fragment.name, JSON.stringify(item), fragment.name) : browser$1(false) : void 0;
    return getDataIDs(fragment, item);
  } else {
    !!Array.isArray(item) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernFragmentSpecResolver: Expected value for fragment `%s` to be an object, got `%s`. ' + 'Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.', fragment.name, JSON.stringify(item), fragment.name) : browser$1(false) : void 0;
    return getDataID$1(fragment, item);
  }
}
/**
 * @internal
 */


function getDataIDs(fragment, items) {
  var ids = null;
  items.forEach(function (item) {
    var id = item != null ? getDataID$1(fragment, item) : null;

    if (id != null) {
      ids = ids || [];
      ids.push(id);
    }
  });
  return ids;
}
/**
 * @internal
 */


function getDataID$1(fragment, item) {
  !(typeof item === 'object' && item !== null && !Array.isArray(item)) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernSelector: Expected value for fragment `%s` to be an object, got ' + '`%s`.', fragment.name, JSON.stringify(item)) : browser$1(false) : void 0;
  var dataID = item[ID_KEY$1];

  if (typeof dataID === 'string') {
    return dataID;
  }

  process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayModernSelector: Expected object to contain data for fragment `%s`, got ' + '`%s`. Make sure that the parent operation/fragment included fragment ' + '`...%s` without `@relay(mask: false)`, or `null` is passed as the fragment ' + "reference for `%s` if it's conditonally included and the condition isn't met.", fragment.name, JSON.stringify(item), fragment.name, fragment.name) : void 0;
  return null;
}
/**
 * @public
 *
 * Given a mapping of keys -> results and a mapping of keys -> fragments,
 * extracts the merged variables that would be in scope for those
 * fragments/results.
 *
 * This can be useful in determing what varaibles were used to fetch the data
 * for a Relay container, for example.
 */


function getVariablesFromObject(fragments, object) {
  var variables = {};

  for (var _key3 in fragments) {
    if (fragments.hasOwnProperty(_key3)) {
      var fragment = fragments[_key3];
      var item = object[_key3];
      var itemVariables = getVariablesFromFragment(fragment, item);
      Object.assign(variables, itemVariables);
    }
  }

  return variables;
}

function getVariablesFromFragment(fragment, item) {
  var _fragment$metadata;

  if (item == null) {
    return {};
  } else if (((_fragment$metadata = fragment.metadata) === null || _fragment$metadata === void 0 ? void 0 : _fragment$metadata.plural) === true) {
    !Array.isArray(item) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. ' + 'Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.', fragment.name, JSON.stringify(item), fragment.name) : browser$1(false) : void 0;
    return getVariablesFromPluralFragment(fragment, item);
  } else {
    !!Array.isArray(item) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernFragmentSpecResolver: Expected value for fragment `%s` to be an object, got `%s`. ' + 'Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.', fragment.name, JSON.stringify(item), fragment.name) : browser$1(false) : void 0;
    return getVariablesFromSingularFragment(fragment, item) || {};
  }
}

function getVariablesFromSingularFragment(fragment, item) {
  var selector = getSingularSelector(fragment, item);

  if (!selector) {
    return null;
  }

  return selector.variables;
}

function getVariablesFromPluralFragment(fragment, items) {
  var variables = {};
  items.forEach(function (value, ii) {
    if (value != null) {
      var itemVariables = getVariablesFromSingularFragment(fragment, value);

      if (itemVariables != null) {
        Object.assign(variables, itemVariables);
      }
    }
  });
  return variables;
}
/**
 * @public
 *
 * Determine if two selectors are equal (represent the same selection). Note
 * that this function returns `false` when the two queries/fragments are
 * different objects, even if they select the same fields.
 */


function areEqualSelectors(thisSelector, thatSelector) {
  return thisSelector.owner === thatSelector.owner && thisSelector.dataID === thatSelector.dataID && thisSelector.node === thatSelector.node && areEqual_1(thisSelector.variables, thatSelector.variables);
}

function createReaderSelector(fragment, dataID, variables, request) {
  var isWithinUnmatchedTypeRefinement = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  return {
    kind: 'SingularReaderSelector',
    dataID: dataID,
    isWithinUnmatchedTypeRefinement: isWithinUnmatchedTypeRefinement,
    node: fragment,
    variables: variables,
    owner: request
  };
}

function createNormalizationSelector(node, dataID, variables) {
  return {
    dataID: dataID,
    node: node,
    variables: variables
  };
}

var RelayModernSelector = {
  areEqualSelectors: areEqualSelectors,
  createReaderSelector: createReaderSelector,
  createNormalizationSelector: createNormalizationSelector,
  getDataIDsFromFragment: getDataIDsFromFragment,
  getDataIDsFromObject: getDataIDsFromObject,
  getSingularSelector: getSingularSelector,
  getPluralSelector: getPluralSelector,
  getSelector: getSelector,
  getSelectorsFromObject: getSelectorsFromObject,
  getVariablesFromSingularFragment: getVariablesFromSingularFragment,
  getVariablesFromPluralFragment: getVariablesFromPluralFragment,
  getVariablesFromFragment: getVariablesFromFragment,
  getVariablesFromObject: getVariablesFromObject
};

var getType$1 = RelayModernRecord.getType;

// Reachable (client) executable definitions encountered while server component
// rendering
var REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY = 'executableDefinitions';
var REACT_FLIGHT_TREE_STORAGE_KEY = 'tree';
var REACT_FLIGHT_TYPE_NAME = 'ReactFlightComponent';

function refineToReactFlightPayloadData(payload) {
  if (payload == null || typeof payload !== 'object' || typeof payload.status !== 'string' || !Array.isArray(payload.tree) && payload.tree !== null || !Array.isArray(payload.queries) || !Array.isArray(payload.fragments) || !Array.isArray(payload.errors)) {
    return null;
  }

  return payload;
}

function getReactFlightClientResponse(record) {
  !(getType$1(record) === REACT_FLIGHT_TYPE_NAME) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'getReactFlightClientResponse(): Expected a ReactFlightComponentRecord, ' + 'got %s.', record) : browser$1(false) : void 0;
  var response = record[REACT_FLIGHT_TREE_STORAGE_KEY];

  if (response != null) {
    return response;
  }

  return null;
}

var RelayStoreReactFlightUtils = {
  REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY: REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY,
  REACT_FLIGHT_TREE_STORAGE_KEY: REACT_FLIGHT_TREE_STORAGE_KEY,
  REACT_FLIGHT_TYPE_NAME: REACT_FLIGHT_TYPE_NAME,
  getReactFlightClientResponse: getReactFlightClientResponse,
  refineToReactFlightPayloadData: refineToReactFlightPayloadData
};

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var PREFIX$1 = 'client:__type:';
var TYPE_SCHEMA_TYPE = '__TypeSchema';

function generateTypeID(typeName) {
  return PREFIX$1 + typeName;
}

function isTypeID(id) {
  return id.indexOf(PREFIX$1) === 0;
}

var TypeID = {
  generateTypeID: generateTypeID,
  isTypeID: isTypeID,
  TYPE_SCHEMA_TYPE: TYPE_SCHEMA_TYPE
};

var _createForOfIteratorHelper2$3 = interopRequireDefault(createForOfIteratorHelper);

var _toConsumableArray2$1 = interopRequireDefault(toConsumableArray);











var CONDITION = RelayConcreteNode_1.CONDITION,
    CLIENT_COMPONENT = RelayConcreteNode_1.CLIENT_COMPONENT,
    CLIENT_EXTENSION = RelayConcreteNode_1.CLIENT_EXTENSION,
    DEFER = RelayConcreteNode_1.DEFER,
    FLIGHT_FIELD = RelayConcreteNode_1.FLIGHT_FIELD,
    FRAGMENT_SPREAD = RelayConcreteNode_1.FRAGMENT_SPREAD,
    INLINE_FRAGMENT = RelayConcreteNode_1.INLINE_FRAGMENT,
    LINKED_FIELD = RelayConcreteNode_1.LINKED_FIELD,
    LINKED_HANDLE = RelayConcreteNode_1.LINKED_HANDLE,
    MODULE_IMPORT = RelayConcreteNode_1.MODULE_IMPORT,
    SCALAR_FIELD = RelayConcreteNode_1.SCALAR_FIELD,
    SCALAR_HANDLE = RelayConcreteNode_1.SCALAR_HANDLE,
    STREAM = RelayConcreteNode_1.STREAM,
    TYPE_DISCRIMINATOR = RelayConcreteNode_1.TYPE_DISCRIMINATOR;

var generateClientID$2 = ClientID.generateClientID,
    isClientID$2 = ClientID.isClientID;

var createNormalizationSelector$1 = RelayModernSelector.createNormalizationSelector;

var refineToReactFlightPayloadData$1 = RelayStoreReactFlightUtils.refineToReactFlightPayloadData,
    REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY$1 = RelayStoreReactFlightUtils.REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY,
    REACT_FLIGHT_TREE_STORAGE_KEY$1 = RelayStoreReactFlightUtils.REACT_FLIGHT_TREE_STORAGE_KEY,
    REACT_FLIGHT_TYPE_NAME$1 = RelayStoreReactFlightUtils.REACT_FLIGHT_TYPE_NAME;

var getArgumentValues$1 = RelayStoreUtils_1.getArgumentValues,
    getHandleStorageKey$1 = RelayStoreUtils_1.getHandleStorageKey,
    getModuleComponentKey$1 = RelayStoreUtils_1.getModuleComponentKey,
    getModuleOperationKey$1 = RelayStoreUtils_1.getModuleOperationKey,
    getStorageKey$1 = RelayStoreUtils_1.getStorageKey,
    TYPENAME_KEY$1 = RelayStoreUtils_1.TYPENAME_KEY,
    ROOT_ID$1 = RelayStoreUtils_1.ROOT_ID,
    ROOT_TYPE = RelayStoreUtils_1.ROOT_TYPE;

/**
 * Normalizes the results of a query and standard GraphQL response, writing the
 * normalized records/fields into the given MutableRecordSource.
 */
function normalize(recordSource, selector, response, options) {
  var dataID = selector.dataID,
      node = selector.node,
      variables = selector.variables;
  var normalizer = new RelayResponseNormalizer(recordSource, variables, options);
  return normalizer.normalizeResponse(node, dataID, response);
}
/**
 * @private
 *
 * Helper for handling payloads.
 */


var RelayResponseNormalizer = /*#__PURE__*/function () {
  function RelayResponseNormalizer(recordSource, variables, options) {
    this._getDataId = options.getDataID;
    this._handleFieldPayloads = [];
    this._treatMissingFieldsAsNull = options.treatMissingFieldsAsNull;
    this._incrementalPlaceholders = [];
    this._isClientExtension = false;
    this._isUnmatchedAbstractType = false;
    this._moduleImportPayloads = [];
    this._path = options.path ? (0, _toConsumableArray2$1["default"])(options.path) : [];
    this._recordSource = recordSource;
    this._variables = variables;
    this._reactFlightPayloadDeserializer = options.reactFlightPayloadDeserializer;
    this._reactFlightServerErrorHandler = options.reactFlightServerErrorHandler;
    this._shouldProcessClientComponents = options.shouldProcessClientComponents;
  }

  var _proto = RelayResponseNormalizer.prototype;

  _proto.normalizeResponse = function normalizeResponse(node, dataID, data) {
    var record = this._recordSource.get(dataID);

    !record ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer(): Expected root record `%s` to exist.', dataID) : browser$1(false) : void 0;

    this._traverseSelections(node, record, data);

    return {
      errors: null,
      fieldPayloads: this._handleFieldPayloads,
      incrementalPlaceholders: this._incrementalPlaceholders,
      moduleImportPayloads: this._moduleImportPayloads,
      source: this._recordSource,
      isFinal: false
    };
  };

  _proto._getVariableValue = function _getVariableValue(name) {
    !this._variables.hasOwnProperty(name) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer(): Undefined variable `%s`.', name) : browser$1(false) : void 0; // $FlowFixMe[cannot-write]

    return this._variables[name];
  };

  _proto._getRecordType = function _getRecordType(data) {
    var typeName = data[TYPENAME_KEY$1];
    !(typeName != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer(): Expected a typename for record `%s`.', JSON.stringify(data, null, 2)) : browser$1(false) : void 0;
    return typeName;
  };

  _proto._traverseSelections = function _traverseSelections(node, record, data) {
    for (var i = 0; i < node.selections.length; i++) {
      var selection = node.selections[i];

      switch (selection.kind) {
        case SCALAR_FIELD:
        case LINKED_FIELD:
          this._normalizeField(node, selection, record, data);

          break;

        case CONDITION:
          var conditionValue = this._getVariableValue(selection.condition);

          if (conditionValue === selection.passingValue) {
            this._traverseSelections(selection, record, data);
          }

          break;

        case FRAGMENT_SPREAD:
          {
            this._traverseSelections(selection.fragment, record, data);

            break;
          }

        case INLINE_FRAGMENT:
          {
            var abstractKey = selection.abstractKey;

            if (abstractKey == null) {
              var _typeName = RelayModernRecord.getType(record);

              if (_typeName === selection.type) {
                this._traverseSelections(selection, record, data);
              }
            } else {
              // legacy behavior for abstract refinements: always normalize even
              // if the type doesn't conform, but track if the type matches or not
              // for determining whether response fields are expected to be present
              var _implementsInterface = data.hasOwnProperty(abstractKey);

              var parentIsUnmatchedAbstractType = this._isUnmatchedAbstractType;
              this._isUnmatchedAbstractType = this._isUnmatchedAbstractType || !_implementsInterface;

              this._traverseSelections(selection, record, data);

              this._isUnmatchedAbstractType = parentIsUnmatchedAbstractType;
            }

            break;
          }

        case TYPE_DISCRIMINATOR:
          {

            break;
          }

        case LINKED_HANDLE:
        case SCALAR_HANDLE:
          var args = selection.args ? getArgumentValues$1(selection.args, this._variables) : {};
          var fieldKey = getStorageKey$1(selection, this._variables);
          var handleKey = getHandleStorageKey$1(selection, this._variables);

          this._handleFieldPayloads.push({
            args: args,
            dataID: RelayModernRecord.getDataID(record),
            fieldKey: fieldKey,
            handle: selection.handle,
            handleKey: handleKey,
            handleArgs: selection.handleArgs ? getArgumentValues$1(selection.handleArgs, this._variables) : {}
          });

          break;

        case MODULE_IMPORT:
          this._normalizeModuleImport(node, selection, record, data);

          break;

        case DEFER:
          this._normalizeDefer(selection, record, data);

          break;

        case STREAM:
          this._normalizeStream(selection, record, data);

          break;

        case CLIENT_EXTENSION:
          var isClientExtension = this._isClientExtension;
          this._isClientExtension = true;

          this._traverseSelections(selection, record, data);

          this._isClientExtension = isClientExtension;
          break;

        case CLIENT_COMPONENT:
          if (this._shouldProcessClientComponents === false) {
            break;
          }

          this._traverseSelections(selection.fragment, record, data);

          break;

        case FLIGHT_FIELD:
          {
            throw new Error('Flight fields are not yet supported.');
          }

        default:
           process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s`.', selection.kind) : browser$1(false) ;
      }
    }
  };

  _proto._normalizeDefer = function _normalizeDefer(defer, record, data) {
    var isDeferred = defer["if"] === null || this._getVariableValue(defer["if"]);

    if (process$1.env.NODE_ENV !== "production") {
      process$1.env.NODE_ENV !== "production" ? warning_1(typeof isDeferred === 'boolean', 'RelayResponseNormalizer: Expected value for @defer `if` argument to ' + 'be a boolean, got `%s`.', isDeferred) : void 0;
    }

    if (isDeferred === false) {
      // If defer is disabled there will be no additional response chunk:
      // normalize the data already present.
      this._traverseSelections(defer, record, data);
    } else {
      // Otherwise data *for this selection* should not be present: enqueue
      // metadata to process the subsequent response chunk.
      this._incrementalPlaceholders.push({
        kind: 'defer',
        data: data,
        label: defer.label,
        path: (0, _toConsumableArray2$1["default"])(this._path),
        selector: createNormalizationSelector$1(defer, RelayModernRecord.getDataID(record), this._variables),
        typeName: RelayModernRecord.getType(record)
      });
    }
  };

  _proto._normalizeStream = function _normalizeStream(stream, record, data) {
    // Always normalize regardless of whether streaming is enabled or not,
    // this populates the initial array value (including any items when
    // initial_count > 0).
    this._traverseSelections(stream, record, data);

    var isStreamed = stream["if"] === null || this._getVariableValue(stream["if"]);

    if (process$1.env.NODE_ENV !== "production") {
      process$1.env.NODE_ENV !== "production" ? warning_1(typeof isStreamed === 'boolean', 'RelayResponseNormalizer: Expected value for @stream `if` argument ' + 'to be a boolean, got `%s`.', isStreamed) : void 0;
    }

    if (isStreamed === true) {
      // If streaming is enabled, *also* emit metadata to process any
      // response chunks that may be delivered.
      this._incrementalPlaceholders.push({
        kind: 'stream',
        label: stream.label,
        path: (0, _toConsumableArray2$1["default"])(this._path),
        parentID: RelayModernRecord.getDataID(record),
        node: stream,
        variables: this._variables
      });
    }
  };

  _proto._normalizeModuleImport = function _normalizeModuleImport(parent, moduleImport, record, data) {
    !(typeof data === 'object' && data) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer: Expected data for @module to be an object.') : browser$1(false) : void 0;
    var typeName = RelayModernRecord.getType(record);
    var componentKey = getModuleComponentKey$1(moduleImport.documentName);
    var componentReference = data[componentKey];
    RelayModernRecord.setValue(record, componentKey, componentReference !== null && componentReference !== void 0 ? componentReference : null);
    var operationKey = getModuleOperationKey$1(moduleImport.documentName);
    var operationReference = data[operationKey];
    RelayModernRecord.setValue(record, operationKey, operationReference !== null && operationReference !== void 0 ? operationReference : null);

    if (operationReference != null) {
      this._moduleImportPayloads.push({
        data: data,
        dataID: RelayModernRecord.getDataID(record),
        operationReference: operationReference,
        path: (0, _toConsumableArray2$1["default"])(this._path),
        typeName: typeName,
        variables: this._variables
      });
    }
  };

  _proto._normalizeField = function _normalizeField(parent, selection, record, data) {
    !(typeof data === 'object' && data) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'writeField(): Expected data for field `%s` to be an object.', selection.name) : browser$1(false) : void 0;
    var responseKey = selection.alias || selection.name;
    var storageKey = getStorageKey$1(selection, this._variables);
    var fieldValue = data[responseKey];

    if (fieldValue == null) {
      if (fieldValue === undefined) {
        // Fields may be missing in the response in two main cases:
        // - Inside a client extension: the server will not generally return
        //   values for these fields, but a local update may provide them.
        // - Inside an abstract type refinement where the concrete type does
        //   not conform to the interface/union.
        // However an otherwise-required field may also be missing if the server
        // is configured to skip fields with `null` values, in which case the
        // client is assumed to be correctly configured with
        // treatMissingFieldsAsNull=true.
        var isOptionalField = this._isClientExtension || this._isUnmatchedAbstractType;

        if (isOptionalField) {
          // Field not expected to exist regardless of whether the server is pruning null
          // fields or not.
          return;
        } else if (!this._treatMissingFieldsAsNull) {
          // Not optional and the server is not pruning null fields: field is expected
          // to be present
          if (process$1.env.NODE_ENV !== "production") {
            process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s: %s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload.', responseKey, storageKey) : void 0;
          }

          return;
        }
      }

      if (process$1.env.NODE_ENV !== "production") {
        if (selection.kind === SCALAR_FIELD) {
          this._validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue);
        }
      }

      RelayModernRecord.setValue(record, storageKey, null);
      return;
    }

    if (selection.kind === SCALAR_FIELD) {
      if (process$1.env.NODE_ENV !== "production") {
        this._validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue);
      }

      RelayModernRecord.setValue(record, storageKey, fieldValue);
    } else if (selection.kind === LINKED_FIELD) {
      this._path.push(responseKey);

      if (selection.plural) {
        this._normalizePluralLink(selection, record, storageKey, fieldValue);
      } else {
        this._normalizeLink(selection, record, storageKey, fieldValue);
      }

      this._path.pop();
    } else {
       process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s` during normalization.', selection.kind) : browser$1(false) ;
    }
  };

  _proto._normalizeFlightField = function _normalizeFlightField(parent, selection, record, data) {
    var responseKey = selection.alias || selection.name;
    var storageKey = getStorageKey$1(selection, this._variables);
    var fieldValue = data[responseKey];

    if (fieldValue == null) {
      if (fieldValue === undefined) {
        // Flight field may be missing in the response if:
        // - It is inside an abstract type refinement where the concrete type does
        //   not conform to the interface/union.
        // However an otherwise-required field may also be missing if the server
        // is configured to skip fields with `null` values, in which case the
        // client is assumed to be correctly configured with
        // treatMissingFieldsAsNull=true.
        if (this._isUnmatchedAbstractType) {
          // Field not expected to exist regardless of whether the server is pruning null
          // fields or not.
          return;
        } else if (!this._treatMissingFieldsAsNull) {
          // Not optional and the server is not pruning null fields: field is expected
          // to be present
          if (process$1.env.NODE_ENV !== "production") {
            process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s: %s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload.', responseKey, storageKey) : void 0;
          }

          return;
        }
      }

      RelayModernRecord.setValue(record, storageKey, null);
      return;
    }

    var reactFlightPayload = refineToReactFlightPayloadData$1(fieldValue);
    var reactFlightPayloadDeserializer = this._reactFlightPayloadDeserializer;
    !(reactFlightPayload != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer: Expected React Flight payload data to be an ' + 'object with `status`, tree`, `queries` and `errors` properties, got ' + '`%s`.', fieldValue) : browser$1(false) : void 0;
    !(typeof reactFlightPayloadDeserializer === 'function') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer: Expected reactFlightPayloadDeserializer to ' + 'be a function, got `%s`.', reactFlightPayloadDeserializer) : browser$1(false) : void 0;

    if (reactFlightPayload.errors.length > 0) {
      if (typeof this._reactFlightServerErrorHandler === 'function') {
        this._reactFlightServerErrorHandler(reactFlightPayload.status, reactFlightPayload.errors);
      } else {
        process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayResponseNormalizer: Received server errors for field `%s`.\n\n' + '%s\n%s', responseKey, reactFlightPayload.errors[0].message, reactFlightPayload.errors[0].stack) : void 0;
      }
    }

    var reactFlightID = generateClientID$2(RelayModernRecord.getDataID(record), getStorageKey$1(selection, this._variables));

    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightID);

    if (reactFlightClientResponseRecord == null) {
      reactFlightClientResponseRecord = RelayModernRecord.create(reactFlightID, REACT_FLIGHT_TYPE_NAME$1);

      this._recordSource.set(reactFlightID, reactFlightClientResponseRecord);
    }

    if (reactFlightPayload.tree == null) {
      // This typically indicates that a fatal server error prevented rows from
      // being written. When this occurs, we should not continue normalization of
      // the Flight field because the row response is malformed.
      //
      // Receiving empty rows is OK because it can indicate the start of a stream.
      process$1.env.NODE_ENV !== "production" ? warning_1(false, 'RelayResponseNormalizer: Expected `tree` not to be null. This ' + 'typically indicates that a fatal server error prevented any Server ' + 'Component rows from being written.') : void 0; // We create the flight record with a null value for the tree
      // and empty reachable definitions

      RelayModernRecord.setValue(reactFlightClientResponseRecord, REACT_FLIGHT_TREE_STORAGE_KEY$1, null);
      RelayModernRecord.setValue(reactFlightClientResponseRecord, REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY$1, []);
      RelayModernRecord.setLinkedRecordID(record, storageKey, reactFlightID);
      return;
    } // We store the deserialized reactFlightClientResponse in a separate
    // record and link it to the parent record. This is so we can GC the Flight
    // tree later even if the parent record is still reachable.


    var reactFlightClientResponse = reactFlightPayloadDeserializer(reactFlightPayload.tree);
    RelayModernRecord.setValue(reactFlightClientResponseRecord, REACT_FLIGHT_TREE_STORAGE_KEY$1, reactFlightClientResponse);
    var reachableExecutableDefinitions = [];

    var _iterator = (0, _createForOfIteratorHelper2$3["default"])(reactFlightPayload.queries),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var query = _step.value;

        if (query.response.data != null) {
          this._moduleImportPayloads.push({
            data: query.response.data,
            dataID: ROOT_ID$1,
            operationReference: query.module,
            path: [],
            typeName: ROOT_TYPE,
            variables: query.variables
          });
        }

        reachableExecutableDefinitions.push({
          module: query.module,
          variables: query.variables
        });
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = (0, _createForOfIteratorHelper2$3["default"])(reactFlightPayload.fragments),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var fragment = _step2.value;

        if (fragment.response.data != null) {
          this._moduleImportPayloads.push({
            data: fragment.response.data,
            dataID: fragment.__id,
            operationReference: fragment.module,
            path: [],
            typeName: fragment.__typename,
            variables: fragment.variables
          });
        }

        reachableExecutableDefinitions.push({
          module: fragment.module,
          variables: fragment.variables
        });
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    RelayModernRecord.setValue(reactFlightClientResponseRecord, REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY$1, reachableExecutableDefinitions);
    RelayModernRecord.setLinkedRecordID(record, storageKey, reactFlightID);
  };

  _proto._normalizeLink = function _normalizeLink(field, record, storageKey, fieldValue) {
    var _field$concreteType;

    !(typeof fieldValue === 'object' && fieldValue) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an object.', storageKey) : browser$1(false) : void 0;
    var nextID = this._getDataId( // $FlowFixMe[incompatible-variance]
    fieldValue, // $FlowFixMe[incompatible-variance]
    (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : this._getRecordType(fieldValue)) || // Reuse previously generated client IDs
    RelayModernRecord.getLinkedRecordID(record, storageKey) || generateClientID$2(RelayModernRecord.getDataID(record), storageKey);
    !(typeof nextID === 'string') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer: Expected id on field `%s` to be a string.', storageKey) : browser$1(false) : void 0;

    if (process$1.env.NODE_ENV !== "production") {
      this._validateConflictingLinkedFieldsWithIdenticalId(record, RelayModernRecord.getLinkedRecordID(record, storageKey), nextID, storageKey);
    }

    RelayModernRecord.setLinkedRecordID(record, storageKey, nextID);

    var nextRecord = this._recordSource.get(nextID);

    if (!nextRecord) {
      // $FlowFixMe[incompatible-variance]
      var _typeName4 = field.concreteType || this._getRecordType(fieldValue);

      nextRecord = RelayModernRecord.create(nextID, _typeName4);

      this._recordSource.set(nextID, nextRecord);
    } else if (process$1.env.NODE_ENV !== "production") {
      this._validateRecordType(nextRecord, field, fieldValue);
    } // $FlowFixMe[incompatible-variance]


    this._traverseSelections(field, nextRecord, fieldValue);
  };

  _proto._normalizePluralLink = function _normalizePluralLink(field, record, storageKey, fieldValue) {
    var _this = this;

    !Array.isArray(fieldValue) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an array ' + 'of objects.', storageKey) : browser$1(false) : void 0;
    var prevIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
    var nextIDs = [];
    fieldValue.forEach(function (item, nextIndex) {
      var _field$concreteType2;

      // validate response data
      if (item == null) {
        nextIDs.push(item);
        return;
      }

      _this._path.push(String(nextIndex));

      !(typeof item === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer: Expected elements for field `%s` to be ' + 'objects.', storageKey) : browser$1(false) : void 0;
      var nextID = _this._getDataId( // $FlowFixMe[incompatible-variance]
      item, // $FlowFixMe[incompatible-variance]
      (_field$concreteType2 = field.concreteType) !== null && _field$concreteType2 !== void 0 ? _field$concreteType2 : _this._getRecordType(item)) || prevIDs && prevIDs[nextIndex] || // Reuse previously generated client IDs:
      generateClientID$2(RelayModernRecord.getDataID(record), storageKey, nextIndex);
      !(typeof nextID === 'string') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayResponseNormalizer: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : browser$1(false) : void 0;
      nextIDs.push(nextID);

      var nextRecord = _this._recordSource.get(nextID);

      if (!nextRecord) {
        // $FlowFixMe[incompatible-variance]
        var _typeName5 = field.concreteType || _this._getRecordType(item);

        nextRecord = RelayModernRecord.create(nextID, _typeName5);

        _this._recordSource.set(nextID, nextRecord);
      } else if (process$1.env.NODE_ENV !== "production") {
        _this._validateRecordType(nextRecord, field, item);
      } // NOTE: the check to strip __DEV__ code only works for simple
      // `if (__DEV__)`


      if (process$1.env.NODE_ENV !== "production") {
        if (prevIDs) {
          _this._validateConflictingLinkedFieldsWithIdenticalId(record, prevIDs[nextIndex], nextID, storageKey);
        }
      } // $FlowFixMe[incompatible-variance]


      _this._traverseSelections(field, nextRecord, item);

      _this._path.pop();
    });
    RelayModernRecord.setLinkedRecordIDs(record, storageKey, nextIDs);
  }
  /**
   * Warns if the type of the record does not match the type of the field/payload.
   */
  ;

  _proto._validateRecordType = function _validateRecordType(record, field, payload) {
    var _field$concreteType3;

    var typeName = (_field$concreteType3 = field.concreteType) !== null && _field$concreteType3 !== void 0 ? _field$concreteType3 : this._getRecordType(payload);
    var dataID = RelayModernRecord.getDataID(record);
    process$1.env.NODE_ENV !== "production" ? warning_1(isClientID$2(dataID) && dataID !== ROOT_ID$1 || RelayModernRecord.getType(record) === typeName, 'RelayResponseNormalizer: Invalid record `%s`. Expected %s to be ' + 'consistent, but the record was assigned conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', dataID, TYPENAME_KEY$1, RelayModernRecord.getType(record), typeName) : void 0;
  }
  /**
   * Warns if a single response contains conflicting fields with the same id
   */
  ;

  _proto._validateConflictingFieldsWithIdenticalId = function _validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue) {
    // NOTE: Only call this function in DEV
    if (process$1.env.NODE_ENV !== "production") {
      var dataID = RelayModernRecord.getDataID(record);
      var previousValue = RelayModernRecord.getValue(record, storageKey);
      process$1.env.NODE_ENV !== "production" ? warning_1(storageKey === TYPENAME_KEY$1 || previousValue === undefined || areEqual_1(previousValue, fieldValue), 'RelayResponseNormalizer: Invalid record. The record contains two ' + 'instances of the same id: `%s` with conflicting field, %s and its values: %s and %s. ' + 'If two fields are different but share ' + 'the same id, one field will overwrite the other.', dataID, storageKey, previousValue, fieldValue) : void 0;
    }
  }
  /**
   * Warns if a single response contains conflicting fields with the same id
   */
  ;

  _proto._validateConflictingLinkedFieldsWithIdenticalId = function _validateConflictingLinkedFieldsWithIdenticalId(record, prevID, nextID, storageKey) {
    // NOTE: Only call this function in DEV
    if (process$1.env.NODE_ENV !== "production") {
      process$1.env.NODE_ENV !== "production" ? warning_1(prevID === undefined || prevID === nextID, 'RelayResponseNormalizer: Invalid record. The record contains ' + 'references to the conflicting field, %s and its id values: %s and %s. ' + 'We need to make sure that the record the field points ' + 'to remains consistent or one field will overwrite the other.', storageKey, prevID, nextID) : void 0;
    }
  };

  return RelayResponseNormalizer;
}();

var RelayResponseNormalizer_1 = {
  normalize: normalize
};

var REQUEST = RelayConcreteNode_1.REQUEST,
    SPLIT_OPERATION = RelayConcreteNode_1.SPLIT_OPERATION;

/**
 * OperationLoaders can return either a NormalizationSplitOperation or
 * ConcreteRequest.
 */
function getOperation(node) {
  switch (node.kind) {
    case REQUEST:
      return node.operation;

    case SPLIT_OPERATION:
    default:
      return node;
  }
}

var getOperation_1 = getOperation;

var _objectSpread2$3 = interopRequireDefault(objectSpread2);

var _createForOfIteratorHelper2$4 = interopRequireDefault(createForOfIteratorHelper);

var _toConsumableArray2$2 = interopRequireDefault(toConsumableArray);





















var generateClientID$3 = ClientID.generateClientID;

var createNormalizationSelector$2 = RelayModernSelector.createNormalizationSelector;

var ROOT_TYPE$1 = RelayStoreUtils_1.ROOT_TYPE,
    TYPENAME_KEY$2 = RelayStoreUtils_1.TYPENAME_KEY,
    getStorageKey$2 = RelayStoreUtils_1.getStorageKey;

function execute(config) {
  return new Executor(config);
}
/**
 * Coordinates the execution of a query, handling network callbacks
 * including optimistic payloads, standard payloads, resolution of match
 * dependencies, etc.
 */


var Executor = /*#__PURE__*/function () {
  function Executor(_ref) {
    var _this = this;

    var operation = _ref.operation,
        operationExecutions = _ref.operationExecutions,
        operationLoader = _ref.operationLoader,
        optimisticConfig = _ref.optimisticConfig,
        publishQueue = _ref.publishQueue,
        scheduler = _ref.scheduler,
        sink = _ref.sink,
        source = _ref.source,
        store = _ref.store,
        updater = _ref.updater,
        operationTracker = _ref.operationTracker,
        treatMissingFieldsAsNull = _ref.treatMissingFieldsAsNull,
        getDataID = _ref.getDataID,
        isClientPayload = _ref.isClientPayload,
        reactFlightPayloadDeserializer = _ref.reactFlightPayloadDeserializer,
        reactFlightServerErrorHandler = _ref.reactFlightServerErrorHandler,
        shouldProcessClientComponents = _ref.shouldProcessClientComponents;
    this._getDataID = getDataID;
    this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;
    this._incrementalPayloadsPending = false;
    this._incrementalResults = new Map();
    this._nextSubscriptionId = 0;
    this._operation = operation;
    this._operationExecutions = operationExecutions;
    this._operationLoader = operationLoader;
    this._operationTracker = operationTracker;
    this._operationUpdateEpochs = new Map();
    this._optimisticUpdates = null;
    this._pendingModulePayloadsCount = 0;
    this._publishQueue = publishQueue;
    this._scheduler = scheduler;
    this._sink = sink;
    this._source = new Map();
    this._state = 'started';
    this._store = store;
    this._subscriptions = new Map();
    this._updater = updater;
    this._isClientPayload = isClientPayload === true;
    this._reactFlightPayloadDeserializer = reactFlightPayloadDeserializer;
    this._reactFlightServerErrorHandler = reactFlightServerErrorHandler;
    this._isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';
    this._shouldProcessClientComponents = shouldProcessClientComponents;
    var id = this._nextSubscriptionId++;
    source.subscribe({
      complete: function complete() {
        return _this._complete(id);
      },
      error: function error(_error2) {
        return _this._error(_error2);
      },
      next: function next(response) {
        try {
          _this._next(id, response);
        } catch (error) {
          sink.error(error);
        }
      },
      start: function start(subscription) {
        return _this._start(id, subscription);
      }
    });

    if (optimisticConfig != null) {
      this._processOptimisticResponse(optimisticConfig.response != null ? {
        data: optimisticConfig.response
      } : null, optimisticConfig.updater, false);
    }
  } // Cancel any pending execution tasks and mark the executor as completed.


  var _proto = Executor.prototype;

  _proto.cancel = function cancel() {
    var _this2 = this;

    if (this._state === 'completed') {
      return;
    }

    this._state = 'completed';

    this._operationExecutions["delete"](this._operation.request.identifier);

    if (this._subscriptions.size !== 0) {
      this._subscriptions.forEach(function (sub) {
        return sub.unsubscribe();
      });

      this._subscriptions.clear();
    }

    var optimisticUpdates = this._optimisticUpdates;

    if (optimisticUpdates !== null) {
      this._optimisticUpdates = null;
      optimisticUpdates.forEach(function (update) {
        return _this2._publishQueue.revertUpdate(update);
      }); // OK: run revert on cancel

      this._publishQueue.run();
    }

    this._incrementalResults.clear();

    this._completeOperationTracker();

    if (this._retainDisposable) {
      this._retainDisposable.dispose();

      this._retainDisposable = null;
    }
  };

  _proto._updateActiveState = function _updateActiveState() {
    var activeState;

    switch (this._state) {
      case 'started':
        {
          activeState = 'active';
          break;
        }

      case 'loading_incremental':
        {
          activeState = 'active';
          break;
        }

      case 'completed':
        {
          activeState = 'inactive';
          break;
        }

      case 'loading_final':
        {
          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';
          break;
        }

      default:
        this._state;
         process$1.env.NODE_ENV !== "production" ? browser$1(false, 'OperationExecutor: invalid executor state.') : browser$1(false) ;
    }

    this._operationExecutions.set(this._operation.request.identifier, activeState);
  };

  _proto._schedule = function _schedule(task) {
    var _this3 = this;

    var scheduler = this._scheduler;

    if (scheduler != null) {
      var _id2 = this._nextSubscriptionId++;

      RelayObservable_1.create(function (sink) {
        var cancellationToken = scheduler.schedule(function () {
          try {
            task();
            sink.complete();
          } catch (error) {
            sink.error(error);
          }
        });
        return function () {
          return scheduler.cancel(cancellationToken);
        };
      }).subscribe({
        complete: function complete() {
          return _this3._complete(_id2);
        },
        error: function error(_error3) {
          return _this3._error(_error3);
        },
        start: function start(subscription) {
          return _this3._start(_id2, subscription);
        }
      });
    } else {
      task();
    }
  };

  _proto._complete = function _complete(id) {
    this._subscriptions["delete"](id);

    if (this._subscriptions.size === 0) {
      this.cancel();

      this._sink.complete();
    }
  };

  _proto._error = function _error(error) {
    this.cancel();

    this._sink.error(error);
  };

  _proto._start = function _start(id, subscription) {
    this._subscriptions.set(id, subscription);

    this._updateActiveState();
  } // Handle a raw GraphQL response.
  ;

  _proto._next = function _next(_id, response) {
    var _this4 = this;

    this._schedule(function () {
      _this4._handleNext(response);

      _this4._maybeCompleteSubscriptionOperationTracking();
    });
  };

  _proto._handleErrorResponse = function _handleErrorResponse(responses) {
    var _this5 = this;

    var results = [];
    responses.forEach(function (response) {
      if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {
        // Skip extensions-only payloads
        return;
      } else if (response.data == null) {
        // Error if any other payload in the batch is missing data, regardless of whether
        // it had `errors` or not.
        var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;
        var messages = errors ? errors.map(function (_ref2) {
          var message = _ref2.message;
          return message;
        }).join('\n') : '(No errors)';
        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\n' + messages + '\n\nSee the error `source` property for more information.');
        error.source = {
          errors: errors,
          operation: _this5._operation.request.node,
          variables: _this5._operation.request.variables
        }; // In V8, Error objects keep the closure scope chain alive until the
        // err.stack property is accessed.

        error.stack;
        throw error;
      } else {
        var responseWithData = response;
        results.push(responseWithData);
      }
    });
    return results;
  }
  /**
   * This method return boolean to indicate if the optimistic
   * response has been handled
   */
  ;

  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {
    var _response$extensions;

    if (responses.length > 1) {
      if (responses.some(function (responsePart) {
        var _responsePart$extensi;

        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;
      })) {
         process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Optimistic responses cannot be batched.') : browser$1(false) ;
      }

      return false;
    }

    var response = responses[0];
    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;

    if (isOptimistic && this._state !== 'started') {
       process$1.env.NODE_ENV !== "production" ? browser$1(false, 'OperationExecutor: optimistic payload received after server payload.') : browser$1(false) ;
    }

    if (isOptimistic) {
      this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);

      this._sink.next(response);

      return true;
    }

    return false;
  };

  _proto._handleNext = function _handleNext(response) {
    if (this._state === 'completed') {
      return;
    }

    var responses = Array.isArray(response) ? response : [response];

    var responsesWithData = this._handleErrorResponse(responses);

    if (responsesWithData.length === 0) {
      // no results with data, nothing to process
      // this can occur with extensions-only payloads
      var isFinal = responses.some(function (x) {
        var _x$extensions;

        return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;
      });

      if (isFinal) {
        this._state = 'loading_final';

        this._updateActiveState();

        this._incrementalPayloadsPending = false;
      }

      this._sink.next(response);

      return;
    } // Next, handle optimistic responses


    var isOptimistic = this._handleOptimisticResponses(responsesWithData);

    if (isOptimistic) {
      return;
    }

    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),
        nonIncrementalResponses = _partitionGraphQLResp[0],
        incrementalResponses = _partitionGraphQLResp[1];

    var hasNonIncrementalResponses = nonIncrementalResponses.length > 0; // In theory this doesn't preserve the ordering of the batch.
    // The idea is that a batch is always:
    //  * at most one non-incremental payload
    //  * followed by zero or more incremental payloads
    // The non-incremental payload can appear if the server sends a batch
    // with the initial payload followed by some early-to-resolve incremental
    // payloads (although, can that even happen?)

    if (hasNonIncrementalResponses) {
      var payloadFollowups = this._processResponses(nonIncrementalResponses);

      {
        var updatedOwners = this._publishQueue.run(this._operation);

        this._updateOperationTracker(updatedOwners);
      }

      this._processPayloadFollowups(payloadFollowups);

      {
        if (this._incrementalPayloadsPending && !this._retainDisposable) {
          this._retainDisposable = this._store.retain(this._operation);
        }
      }
    }

    if (incrementalResponses.length > 0) {
      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses);

      {
        // For the incremental case, we're only handling follow-up responses
        // for already initiated operation (and we're not passing it to
        // the run(...) call)
        var _updatedOwners = this._publishQueue.run();

        this._updateOperationTracker(_updatedOwners);
      }

      this._processPayloadFollowups(_payloadFollowups);
    }

    if (this._isSubscriptionOperation && RelayFeatureFlags_1.ENABLE_UNIQUE_SUBSCRIPTION_ROOT) {
      // We attach the id to allow the `requestSubscription` to read from the store using
      // the current id in its `onNext` callback
      if (responsesWithData[0].extensions == null) {
        // $FlowFixMe[cannot-write]
        responsesWithData[0].extensions = {
          __relay_subscription_root_id: this._operation.fragment.dataID
        };
      } else {
        responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;
      }
    }

    this._sink.next(response);
  };

  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {
    var _this6 = this;

    !(this._optimisticUpdates === null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'environment.execute: only support one optimistic response per ' + 'execute.') : browser$1(false) : void 0;

    if (response == null && updater == null) {
      return;
    }

    var optimisticUpdates = [];

    if (response) {
      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE$1, {
        getDataID: this._getDataID,
        path: [],
        reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,
        reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,
        shouldProcessClientComponents: this._shouldProcessClientComponents,
        treatMissingFieldsAsNull: treatMissingFieldsAsNull
      });
      validateOptimisticResponsePayload(payload);
      optimisticUpdates.push({
        operation: this._operation,
        payload: payload,
        updater: updater
      });

      this._processOptimisticFollowups(payload, optimisticUpdates);
    } else if (updater) {
      optimisticUpdates.push({
        operation: this._operation,
        payload: {
          errors: null,
          fieldPayloads: null,
          incrementalPlaceholders: null,
          moduleImportPayloads: null,
          source: RelayRecordSource_1.create(),
          isFinal: false
        },
        updater: updater
      });
    }

    this._optimisticUpdates = optimisticUpdates;
    optimisticUpdates.forEach(function (update) {
      return _this6._publishQueue.applyUpdate(update);
    }); // OK: only called on construction and when receiving an optimistic payload from network,
    // which doesn't fall-through to the regular next() handling

    this._publishQueue.run();
  };

  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {
    if (payload.moduleImportPayloads && payload.moduleImportPayloads.length) {
      var moduleImportPayloads = payload.moduleImportPayloads;
      var operationLoader = this._operationLoader;
      !operationLoader ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : browser$1(false) : void 0;

      var _iterator = (0, _createForOfIteratorHelper2$4["default"])(moduleImportPayloads),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var moduleImportPayload = _step.value;
          var operation = operationLoader.get(moduleImportPayload.operationReference);

          if (operation == null) {
            this._processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload);
          } else {
            var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, moduleImportPayload);

            optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2$2["default"])(moduleImportOptimisticUpdates));
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  };

  _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImportPayload, operation) {
    var selector = createNormalizationSelector$2(operation, moduleImportPayload.dataID, moduleImportPayload.variables);
    return normalizeResponse({
      data: moduleImportPayload.data
    }, selector, moduleImportPayload.typeName, {
      getDataID: this._getDataID,
      path: moduleImportPayload.path,
      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,
      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,
      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
      shouldProcessClientComponents: this._shouldProcessClientComponents
    });
  };

  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {
    var operation = getOperation_1(normalizationRootNode);
    var optimisticUpdates = [];

    var modulePayload = this._normalizeModuleImport(moduleImportPayload, operation);

    validateOptimisticResponsePayload(modulePayload);
    optimisticUpdates.push({
      operation: this._operation,
      payload: modulePayload,
      updater: null
    });

    this._processOptimisticFollowups(modulePayload, optimisticUpdates);

    return optimisticUpdates;
  };

  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload) {
    var _this7 = this;

    operationLoader.load(moduleImportPayload.operationReference).then(function (operation) {
      if (operation == null || _this7._state !== 'started') {
        return;
      }

      var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);

      moduleImportOptimisticUpdates.forEach(function (update) {
        return _this7._publishQueue.applyUpdate(update);
      });

      if (_this7._optimisticUpdates == null) {
        process$1.env.NODE_ENV !== "production" ? warning_1(false, 'OperationExecutor: Unexpected ModuleImport optimistic ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;
      } else {
        var _this$_optimisticUpda;

        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2$2["default"])(moduleImportOptimisticUpdates)); // OK: always have to run() after an module import resolves async


        _this7._publishQueue.run();
      }
    });
  };

  _proto._processResponses = function _processResponses(responses) {
    var _this8 = this;

    if (this._optimisticUpdates !== null) {
      this._optimisticUpdates.forEach(function (update) {
        return _this8._publishQueue.revertUpdate(update);
      });

      this._optimisticUpdates = null;
    }

    this._incrementalPayloadsPending = false;

    this._incrementalResults.clear();

    this._source.clear();

    return responses.map(function (payloadPart) {
      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE$1, {
        getDataID: _this8._getDataID,
        path: [],
        reactFlightPayloadDeserializer: _this8._reactFlightPayloadDeserializer,
        reactFlightServerErrorHandler: _this8._reactFlightServerErrorHandler,
        treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,
        shouldProcessClientComponents: _this8._shouldProcessClientComponents
      });

      _this8._publishQueue.commitPayload(_this8._operation, relayPayload, _this8._updater);

      return relayPayload;
    });
  }
  /**
   * Handles any follow-up actions for a Relay payload for @match, @defer,
   * and @stream directives.
   */
  ;

  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {
    var _this9 = this;

    if (this._state === 'completed') {
      return;
    }

    payloads.forEach(function (payload) {
      var incrementalPlaceholders = payload.incrementalPlaceholders,
          moduleImportPayloads = payload.moduleImportPayloads,
          isFinal = payload.isFinal;
      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';

      _this9._updateActiveState();

      if (isFinal) {
        _this9._incrementalPayloadsPending = false;
      }

      if (moduleImportPayloads && moduleImportPayloads.length !== 0) {
        var operationLoader = _this9._operationLoader;
        !operationLoader ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : browser$1(false) : void 0;
        moduleImportPayloads.forEach(function (moduleImportPayload) {
          _this9._processModuleImportPayload(moduleImportPayload, operationLoader);
        });
      }

      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {
        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';
        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {
          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);
        });

        if (_this9._isClientPayload || _this9._state === 'loading_final') {
          // The query has defer/stream selections that are enabled, but either
          // the server indicated that this is a "final" payload: no incremental
          // payloads will be delivered, then warn that the query was (likely)
          // executed on the server in non-streaming mode, with incremental
          // delivery disabled; or this is a client payload, and there will be
          // no incremental payload.
          process$1.env.NODE_ENV !== "production" ? warning_1(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads

          var relayPayloads = [];
          incrementalPlaceholders.forEach(function (placeholder) {
            if (placeholder.kind === 'defer') {
              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {
                data: placeholder.data
              }));
            }
          });

          if (relayPayloads.length > 0) {
            {
              var updatedOwners = _this9._publishQueue.run();

              _this9._updateOperationTracker(updatedOwners);
            }

            _this9._processPayloadFollowups(relayPayloads);
          }
        }
      }
    });
  };

  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {
    if (!this._isSubscriptionOperation) {
      return;
    }

    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {
      this._completeOperationTracker();
    }
  }
  /**
   * Processes a ModuleImportPayload, asynchronously resolving the normalization
   * AST and using it to normalize the field data into a RelayResponsePayload.
   * The resulting payload may contain other incremental payloads (match,
   * defer, stream, etc); these are handled by calling
   * `_processPayloadFollowups()`.
   */
  ;

  _proto._processModuleImportPayload = function _processModuleImportPayload(moduleImportPayload, operationLoader) {
    var _this10 = this;

    var node = operationLoader.get(moduleImportPayload.operationReference);

    if (node != null) {
      var operation = getOperation_1(node); // If the operation module is available synchronously, normalize the
      // data synchronously.

      this._handleModuleImportPayload(moduleImportPayload, operation);

      this._maybeCompleteSubscriptionOperationTracking();
    } else {
      // Otherwise load the operation module and schedule a task to normalize
      // the data when the module is available.
      var _id3 = this._nextSubscriptionId++;

      this._pendingModulePayloadsCount++;

      var decrementPendingCount = function decrementPendingCount() {
        _this10._pendingModulePayloadsCount--;

        _this10._maybeCompleteSubscriptionOperationTracking();
      }; // Observable.from(operationLoader.load()) wouldn't catch synchronous
      // errors thrown by the load function, which is user-defined. Guard
      // against that with Observable.from(new Promise(<work>)).


      RelayObservable_1.from(new Promise(function (resolve, reject) {
        operationLoader.load(moduleImportPayload.operationReference).then(resolve, reject);
      })).map(function (operation) {
        if (operation != null) {
          _this10._schedule(function () {
            _this10._handleModuleImportPayload(moduleImportPayload, getOperation_1(operation)); // OK: always have to run after an async module import resolves


            var updatedOwners = _this10._publishQueue.run();

            _this10._updateOperationTracker(updatedOwners);
          });
        }
      }).subscribe({
        complete: function complete() {
          _this10._complete(_id3);

          decrementPendingCount();
        },
        error: function error(_error4) {
          _this10._error(_error4);

          decrementPendingCount();
        },
        start: function start(subscription) {
          return _this10._start(_id3, subscription);
        }
      });
    }
  };

  _proto._handleModuleImportPayload = function _handleModuleImportPayload(moduleImportPayload, operation) {
    var relayPayload = this._normalizeModuleImport(moduleImportPayload, operation);

    this._publishQueue.commitPayload(this._operation, relayPayload);

    {
      var updatedOwners = this._publishQueue.run();

      this._updateOperationTracker(updatedOwners);
    }

    this._processPayloadFollowups([relayPayload]);
  }
  /**
   * The executor now knows that GraphQL responses are expected for a given
   * label/path:
   * - Store the placeholder in order to process any future responses that may
   *   arrive.
   * - Then process any responses that had already arrived.
   *
   * The placeholder contains the normalization selector, path (for nested
   * defer/stream), and other metadata used to normalize the incremental
   * response(s).
   */
  ;

  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {
    var _relayPayload$fieldPa;

    // Update the label => path => placeholder map
    var label = placeholder.label,
        path = placeholder.path;
    var pathKey = path.map(String).join('.');

    var resultForLabel = this._incrementalResults.get(label);

    if (resultForLabel == null) {
      resultForLabel = new Map();

      this._incrementalResults.set(label, resultForLabel);
    }

    var resultForPath = resultForLabel.get(pathKey);
    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;
    resultForLabel.set(pathKey, {
      kind: 'placeholder',
      placeholder: placeholder
    }); // Store references to the parent node to allow detecting concurrent
    // modifications to the parent before items arrive and to replay
    // handle field payloads to account for new information on source records.

    var parentID;

    if (placeholder.kind === 'stream') {
      parentID = placeholder.parentID;
    } else if (placeholder.kind === 'defer') {
      parentID = placeholder.selector.dataID;
    } else {
       process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Unsupported incremental placeholder kind `%s`.', placeholder.kind) : browser$1(false) ;
    }

    var parentRecord = relayPayload.source.get(parentID);
    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {
      var fieldID = generateClientID$3(fieldPayload.dataID, fieldPayload.fieldKey);
      return (// handlers applied to the streamed field itself
        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where
        // ancestor.field links to the parent record (example: connections)
        fieldID === parentID
      );
    }); // If an incremental payload exists for some id that record should also
    // exist.

    !(parentRecord != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected record `%s` to exist.', parentID) : browser$1(false) : void 0;
    var nextParentRecord;
    var nextParentPayloads;

    var previousParentEntry = this._source.get(parentID);

    if (previousParentEntry != null) {
      // If a previous entry exists, merge the previous/next records and
      // payloads together.
      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);
      var handlePayloads = new Map();

      var dedupePayload = function dedupePayload(payload) {
        var key = stableStringify(payload);
        handlePayloads.set(key, payload);
      };

      previousParentEntry.fieldPayloads.forEach(dedupePayload);
      parentPayloads.forEach(dedupePayload);
      nextParentPayloads = Array.from(handlePayloads.values());
    } else {
      nextParentRecord = parentRecord;
      nextParentPayloads = parentPayloads;
    }

    this._source.set(parentID, {
      record: nextParentRecord,
      fieldPayloads: nextParentPayloads
    }); // If there were any queued responses, process them now that placeholders
    // are in place


    if (pendingResponses != null) {
      var payloadFollowups = this._processIncrementalResponses(pendingResponses);

      {
        var updatedOwners = this._publishQueue.run();

        this._updateOperationTracker(updatedOwners);
      }

      this._processPayloadFollowups(payloadFollowups);
    }
  }
  /**
   * Lookup the placeholder the describes how to process an incremental
   * response, normalize/publish it, and process any nested defer/match/stream
   * metadata.
   */
  ;

  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {
    var _this11 = this;

    var relayPayloads = [];
    incrementalResponses.forEach(function (incrementalResponse) {
      var label = incrementalResponse.label,
          path = incrementalResponse.path,
          response = incrementalResponse.response;

      var resultForLabel = _this11._incrementalResults.get(label);

      if (resultForLabel == null) {
        resultForLabel = new Map();

        _this11._incrementalResults.set(label, resultForLabel);
      }

      if (label.indexOf('$defer$') !== -1) {
        var pathKey = path.map(String).join('.');
        var resultForPath = resultForLabel.get(pathKey);

        if (resultForPath == null) {
          resultForPath = {
            kind: 'response',
            responses: [incrementalResponse]
          };
          resultForLabel.set(pathKey, resultForPath);
          return;
        } else if (resultForPath.kind === 'response') {
          resultForPath.responses.push(incrementalResponse);
          return;
        }

        var placeholder = resultForPath.placeholder;
        !(placeholder.kind === 'defer') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : browser$1(false) : void 0;
        relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));
      } else {
        // @stream payload path values end in the field name and item index,
        // but Relay records paths relative to the parent of the stream node:
        // therefore we strip the last two elements just to lookup the path
        // (the item index is used later to insert the element in the list)
        var _pathKey = path.slice(0, -2).map(String).join('.');

        var _resultForPath = resultForLabel.get(_pathKey);

        if (_resultForPath == null) {
          _resultForPath = {
            kind: 'response',
            responses: [incrementalResponse]
          };
          resultForLabel.set(_pathKey, _resultForPath);
          return;
        } else if (_resultForPath.kind === 'response') {
          _resultForPath.responses.push(incrementalResponse);

          return;
        }

        var _placeholder = _resultForPath.placeholder;
        !(_placeholder.kind === 'stream') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : browser$1(false) : void 0;
        relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));
      }
    });
    return relayPayloads;
  };

  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {
    var parentID = placeholder.selector.dataID;
    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {
      getDataID: this._getDataID,
      path: placeholder.path,
      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,
      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,
      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
      shouldProcessClientComponents: this._shouldProcessClientComponents
    });

    this._publishQueue.commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data
    // was derived


    var parentEntry = this._source.get(parentID);

    !(parentEntry != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : browser$1(false) : void 0;
    var fieldPayloads = parentEntry.fieldPayloads;

    if (fieldPayloads.length !== 0) {
      var _response$extensions2;

      var handleFieldsRelayPayload = {
        errors: null,
        fieldPayloads: fieldPayloads,
        incrementalPlaceholders: null,
        moduleImportPayloads: null,
        source: RelayRecordSource_1.create(),
        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true
      };

      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);
    }

    return relayPayload;
  }
  /**
   * Process the data for one item in a @stream field.
   */
  ;

  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {
    var parentID = placeholder.parentID,
        node = placeholder.node,
        variables = placeholder.variables; // Find the LinkedField where @stream was applied

    var field = node.selections[0];
    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected @stream to be used on a plural field.') : browser$1(false) : void 0;

    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),
        fieldPayloads = _this$_normalizeStrea.fieldPayloads,
        itemID = _this$_normalizeStrea.itemID,
        itemIndex = _this$_normalizeStrea.itemIndex,
        prevIDs = _this$_normalizeStrea.prevIDs,
        relayPayload = _this$_normalizeStrea.relayPayload,
        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set
    // field[index] = item *if* the parent record hasn't been concurrently
    // modified.


    this._publishQueue.commitPayload(this._operation, relayPayload, function (store) {
      var currentParentRecord = store.get(parentID);

      if (currentParentRecord == null) {
        // parent has since been deleted, stream data is stale
        return;
      }

      var currentItems = currentParentRecord.getLinkedRecords(storageKey);

      if (currentItems == null) {
        // field has since been deleted, stream data is stale
        return;
      }

      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {
        return prevIDs[index] !== (currentItem && currentItem.getDataID());
      })) {
        // field has been modified by something other than this query,
        // stream data is stale
        return;
      } // parent.field has not been concurrently modified:
      // update `parent.field[index] = item`


      var nextItems = (0, _toConsumableArray2$2["default"])(currentItems);
      nextItems[itemIndex] = store.get(itemID);
      currentParentRecord.setLinkedRecords(nextItems, storageKey);
    }); // Now that the parent record has been updated to include the new item,
    // also update any handle fields that are derived from the parent record.


    if (fieldPayloads.length !== 0) {
      var handleFieldsRelayPayload = {
        errors: null,
        fieldPayloads: fieldPayloads,
        incrementalPlaceholders: null,
        moduleImportPayloads: null,
        source: RelayRecordSource_1.create(),
        isFinal: false
      };

      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);
    }

    return relayPayload;
  };

  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {
    var _field$alias, _field$concreteType, _this$_getDataID;

    var data = response.data;
    !(typeof data === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : browser$1(false) : void 0;
    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;
    var storageKey = getStorageKey$2(field, variables); // Load the version of the parent record from which this incremental data
    // was derived

    var parentEntry = this._source.get(parentID);

    !(parentEntry != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : browser$1(false) : void 0;
    var parentRecord = parentEntry.record,
        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor
    // in order to check if there has been any concurrent modifications by some
    // other operation.

    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);
    !(prevIDs != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : browser$1(false) : void 0; // Determine the index in the field of the new item

    var finalPathEntry = path[path.length - 1];
    var itemIndex = parseInt(finalPathEntry, 10);
    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : browser$1(false) : void 0;
    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY$2];
    !(typeof typeName === 'string') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected @stream field `%s` to have a ' + '__typename.', field.name) : browser$1(false) : void 0; // Determine the __id of the new item: this must equal the value that would
    // be assigned had the item not been streamed

    var itemID = // https://github.com/prettier/prettier/issues/6403
    // prettier-ignore
    ((_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs && prevIDs[itemIndex]) || // Reuse previously generated client IDs
    generateClientID$3(parentID, storageKey, itemIndex);
    !(typeof itemID === 'string') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : browser$1(false) : void 0; // Build a selector to normalize the item data with

    var selector = createNormalizationSelector$2(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:
    // this is used when subsequent stream payloads arrive to see if there
    // have been concurrent modifications to the list

    var nextParentRecord = RelayModernRecord.clone(parentRecord);
    var nextIDs = (0, _toConsumableArray2$2["default"])(prevIDs);
    nextIDs[itemIndex] = itemID;
    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);

    this._source.set(parentID, {
      record: nextParentRecord,
      fieldPayloads: fieldPayloads
    });

    var relayPayload = normalizeResponse(response, selector, typeName, {
      getDataID: this._getDataID,
      path: [].concat((0, _toConsumableArray2$2["default"])(normalizationPath), [responseKey, String(itemIndex)]),
      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,
      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,
      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
      shouldProcessClientComponents: this._shouldProcessClientComponents
    });
    return {
      fieldPayloads: fieldPayloads,
      itemID: itemID,
      itemIndex: itemIndex,
      prevIDs: prevIDs,
      relayPayload: relayPayload,
      storageKey: storageKey
    };
  };

  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {
    if (updatedOwners != null && updatedOwners.length > 0) {
      this._operationTracker.update(this._operation.request, new Set(updatedOwners));
    }
  };

  _proto._completeOperationTracker = function _completeOperationTracker() {
    this._operationTracker.complete(this._operation.request);
  };

  return Executor;
}();

function partitionGraphQLResponses(responses) {
  var nonIncrementalResponses = [];
  var incrementalResponses = [];
  responses.forEach(function (response) {
    if (response.path != null || response.label != null) {
      var label = response.label,
          path = response.path;

      if (label == null || path == null) {
         process$1.env.NODE_ENV !== "production" ? browser$1(false, 'OperationExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : browser$1(false) ;
      }

      incrementalResponses.push({
        label: label,
        path: path,
        response: response
      });
    } else {
      nonIncrementalResponses.push(response);
    }
  });
  return [nonIncrementalResponses, incrementalResponses];
}

function normalizeResponse(response, selector, typeName, options) {
  var _response$extensions3;

  var data = response.data,
      errors = response.errors;
  var source = RelayRecordSource_1.create();
  var record = RelayModernRecord.create(selector.dataID, typeName);
  source.set(selector.dataID, record);
  var relayPayload = RelayResponseNormalizer_1.normalize(source, selector, data, options);
  return (0, _objectSpread2$3["default"])((0, _objectSpread2$3["default"])({}, relayPayload), {}, {
    errors: errors,
    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true
  });
}

function stableStringify(value) {
  var _JSON$stringify;

  return (_JSON$stringify = JSON.stringify(stableCopy_1(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow
}

function validateOptimisticResponsePayload(payload) {
  var incrementalPlaceholders = payload.incrementalPlaceholders;

  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {
     process$1.env.NODE_ENV !== "production" ? browser$1(false, 'OperationExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : browser$1(false) ;
  }
}

var OperationExecutor = {
  execute: execute
};

var _createForOfIteratorHelper2$5 = interopRequireDefault(createForOfIteratorHelper);



var RelayOperationTracker = /*#__PURE__*/function () {
  function RelayOperationTracker() {
    this._ownersToPendingOperationsIdentifier = new Map();
    this._pendingOperationsToOwnersIdentifier = new Map();
    this._ownersIdentifierToPromise = new Map();
  }
  /**
   * Update the map of current processing operations with the set of
   * affected owners and notify subscribers
   */


  var _proto = RelayOperationTracker.prototype;

  _proto.update = function update(pendingOperation, affectedOwners) {
    if (affectedOwners.size === 0) {
      return;
    }

    var pendingOperationIdentifier = pendingOperation.identifier;
    var newlyAffectedOwnersIdentifier = new Set();

    var _iterator = (0, _createForOfIteratorHelper2$5["default"])(affectedOwners),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var owner = _step.value;
        var ownerIdentifier = owner.identifier;

        var pendingOperationsAffectingOwner = this._ownersToPendingOperationsIdentifier.get(ownerIdentifier);

        if (pendingOperationsAffectingOwner != null) {
          // In this case the `ownerIdentifier` already affected by some operations
          // We just need to detect, is it the same operation that we already
          // have in the list, or it's a new operation
          if (!pendingOperationsAffectingOwner.has(pendingOperationIdentifier)) {
            pendingOperationsAffectingOwner.add(pendingOperationIdentifier);
            newlyAffectedOwnersIdentifier.add(ownerIdentifier);
          }
        } else {
          // This is a new `ownerIdentifier` that is affected by the operation
          this._ownersToPendingOperationsIdentifier.set(ownerIdentifier, new Set([pendingOperationIdentifier]));

          newlyAffectedOwnersIdentifier.add(ownerIdentifier);
        }
      } // No new owners were affected by this operation, we may stop here

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    if (newlyAffectedOwnersIdentifier.size === 0) {
      return;
    } // But, if some owners were affected we need to add them to
    // the `_pendingOperationsToOwnersIdentifier` set


    var ownersAffectedByOperationIdentifier = this._pendingOperationsToOwnersIdentifier.get(pendingOperationIdentifier) || new Set();

    var _iterator2 = (0, _createForOfIteratorHelper2$5["default"])(newlyAffectedOwnersIdentifier),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _ownerIdentifier = _step2.value;

        this._resolveOwnerResolvers(_ownerIdentifier);

        ownersAffectedByOperationIdentifier.add(_ownerIdentifier);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    this._pendingOperationsToOwnersIdentifier.set(pendingOperationIdentifier, ownersAffectedByOperationIdentifier);
  }
  /**
   * Once pending operation is completed we need to remove it
   * from all tracking maps
   */
  ;

  _proto.complete = function complete(pendingOperation) {
    var pendingOperationIdentifier = pendingOperation.identifier;

    var affectedOwnersIdentifier = this._pendingOperationsToOwnersIdentifier.get(pendingOperationIdentifier);

    if (affectedOwnersIdentifier == null) {
      return;
    } // These were the owners affected only by `pendingOperationIdentifier`


    var completedOwnersIdentifier = new Set(); // These were the owners affected by `pendingOperationIdentifier`
    // and some other operations

    var updatedOwnersIdentifier = new Set();

    var _iterator3 = (0, _createForOfIteratorHelper2$5["default"])(affectedOwnersIdentifier),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var ownerIdentifier = _step3.value;

        var pendingOperationsAffectingOwner = this._ownersToPendingOperationsIdentifier.get(ownerIdentifier);

        if (!pendingOperationsAffectingOwner) {
          continue;
        }

        pendingOperationsAffectingOwner["delete"](pendingOperationIdentifier);

        if (pendingOperationsAffectingOwner.size > 0) {
          updatedOwnersIdentifier.add(ownerIdentifier);
        } else {
          completedOwnersIdentifier.add(ownerIdentifier);
        }
      } // Complete subscriptions for all owners, affected by `pendingOperationIdentifier`

    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    var _iterator4 = (0, _createForOfIteratorHelper2$5["default"])(completedOwnersIdentifier),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _ownerIdentifier2 = _step4.value;

        this._resolveOwnerResolvers(_ownerIdentifier2);

        this._ownersToPendingOperationsIdentifier["delete"](_ownerIdentifier2);
      } // Update all ownerIdentifier that were updated by `pendingOperationIdentifier` but still
      // are affected by other operations

    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    var _iterator5 = (0, _createForOfIteratorHelper2$5["default"])(updatedOwnersIdentifier),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _ownerIdentifier3 = _step5.value;

        this._resolveOwnerResolvers(_ownerIdentifier3);
      } // Finally, remove pending operation identifier

    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    this._pendingOperationsToOwnersIdentifier["delete"](pendingOperationIdentifier);
  };

  _proto._resolveOwnerResolvers = function _resolveOwnerResolvers(ownerIdentifier) {
    var promiseEntry = this._ownersIdentifierToPromise.get(ownerIdentifier);

    if (promiseEntry != null) {
      promiseEntry.resolve();
    }

    this._ownersIdentifierToPromise["delete"](ownerIdentifier);
  };

  _proto.getPromiseForPendingOperationsAffectingOwner = function getPromiseForPendingOperationsAffectingOwner(owner) {
    var ownerIdentifier = owner.identifier;

    if (!this._ownersToPendingOperationsIdentifier.has(ownerIdentifier)) {
      return null;
    }

    var cachedPromiseEntry = this._ownersIdentifierToPromise.get(ownerIdentifier);

    if (cachedPromiseEntry != null) {
      return cachedPromiseEntry.promise;
    }

    var resolve;
    var promise = new Promise(function (r) {
      resolve = r;
    });
    !(resolve != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayOperationTracker: Expected resolver to be defined. If you' + 'are seeing this, it is likely a bug in Relay.') : browser$1(false) : void 0;

    this._ownersIdentifierToPromise.set(ownerIdentifier, {
      promise: promise,
      resolve: resolve
    });

    return promise;
  };

  return RelayOperationTracker;
}();

var RelayOperationTracker_1 = RelayOperationTracker;

var getFragment$1 = GraphQLTag.getFragment;

var getSelector$1 = RelayModernSelector.getSelector;

var contextStack = [];

function withResolverContext(context, cb) {
  contextStack.push(context);

  try {
    return cb();
  } finally {
    contextStack.pop();
  }
} // NOTE: these declarations are copied from 'useFragment'; it would be good
// to figure out how to share the same type signature between the two functions.
// The declarations ensure that the type of the returned data is:
//   - non-nullable if the provided ref type is non-nullable
//   - nullable if the provided ref type is nullable
//   - array of non-nullable if the privoided ref type is an array of
//     non-nullable refs
//   - array of nullable if the privoided ref type is an array of nullable refs


function readFragment(fragmentInput, fragmentRef) {
  if (!contextStack.length) {
    throw new Error('readFragment should be called only from within a Relay Resolver function.');
  }

  var context = contextStack[contextStack.length - 1];
  var fragmentNode = getFragment$1(fragmentInput);
  var fragmentSelector = getSelector$1(fragmentNode, fragmentRef);
  !(fragmentSelector != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, "Expected a selector for the fragment of the resolver ".concat(fragmentNode.name, ", but got null.")) : browser$1(false) : void 0;
  !(fragmentSelector.kind === 'SingularReaderSelector') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, "Expected a singular reader selector for the fragment of the resolver ".concat(fragmentNode.name, ", but it was plural.")) : browser$1(false) : void 0;
  return context.getDataForResolverFragment(fragmentSelector);
}

var ResolverFragments = {
  readFragment: readFragment,
  withResolverContext: withResolverContext
};

var _defineProperty2 = interopRequireDefault(defineProperty);







var CLIENT_EXTENSION$1 = RelayConcreteNode_1.CLIENT_EXTENSION,
    CONDITION$1 = RelayConcreteNode_1.CONDITION,
    DEFER$1 = RelayConcreteNode_1.DEFER,
    FLIGHT_FIELD$1 = RelayConcreteNode_1.FLIGHT_FIELD,
    FRAGMENT_SPREAD$1 = RelayConcreteNode_1.FRAGMENT_SPREAD,
    INLINE_DATA_FRAGMENT_SPREAD = RelayConcreteNode_1.INLINE_DATA_FRAGMENT_SPREAD,
    INLINE_FRAGMENT$1 = RelayConcreteNode_1.INLINE_FRAGMENT,
    LINKED_FIELD$1 = RelayConcreteNode_1.LINKED_FIELD,
    MODULE_IMPORT$1 = RelayConcreteNode_1.MODULE_IMPORT,
    REQUIRED_FIELD = RelayConcreteNode_1.REQUIRED_FIELD,
    RELAY_RESOLVER = RelayConcreteNode_1.RELAY_RESOLVER,
    SCALAR_FIELD$1 = RelayConcreteNode_1.SCALAR_FIELD,
    STREAM$1 = RelayConcreteNode_1.STREAM;

var getReactFlightClientResponse$1 = RelayStoreReactFlightUtils.getReactFlightClientResponse;

var FRAGMENTS_KEY$1 = RelayStoreUtils_1.FRAGMENTS_KEY,
    FRAGMENT_OWNER_KEY$1 = RelayStoreUtils_1.FRAGMENT_OWNER_KEY,
    FRAGMENT_PROP_NAME_KEY = RelayStoreUtils_1.FRAGMENT_PROP_NAME_KEY,
    ID_KEY$2 = RelayStoreUtils_1.ID_KEY,
    MODULE_COMPONENT_KEY = RelayStoreUtils_1.MODULE_COMPONENT_KEY,
    ROOT_ID$2 = RelayStoreUtils_1.ROOT_ID,
    getArgumentValues$2 = RelayStoreUtils_1.getArgumentValues,
    getStorageKey$3 = RelayStoreUtils_1.getStorageKey,
    getModuleComponentKey$2 = RelayStoreUtils_1.getModuleComponentKey;

var withResolverContext$1 = ResolverFragments.withResolverContext;

var generateTypeID$1 = TypeID.generateTypeID;

function read(recordSource, selector) {
  var reader = new RelayReader(recordSource, selector);
  return reader.read();
}
/**
 * @private
 */


var RelayReader = /*#__PURE__*/function () {
  function RelayReader(recordSource, selector) {
    this._isMissingData = false;
    this._isWithinUnmatchedTypeRefinement = false;
    this._missingRequiredFields = null;
    this._owner = selector.owner;
    this._recordSource = recordSource;
    this._seenRecords = new Set();
    this._selector = selector;
    this._variables = selector.variables;
  }

  var _proto = RelayReader.prototype;

  _proto.read = function read() {
    var _this$_selector = this._selector,
        node = _this$_selector.node,
        dataID = _this$_selector.dataID,
        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;
    var abstractKey = node.abstractKey;

    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object
    // did not match the type of the fragment: either the root object has a different
    // concrete type than the fragment (for concrete fragments) or the root object does
    // not conform to the interface/union for abstract fragments.
    // For suspense purposes, however, we want to accurately compute whether any data
    // is missing: but if the fragment type doesn't match (or a parent type didn't
    // match), then no data is expected to be present.
    // By default data is expected to be present unless this selector was read out
    // from within a non-matching type refinement in a parent fragment:


    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not
    // match, then no data is expected to be present.

    if (isDataExpectedToBePresent && abstractKey == null && record != null) {
      var recordType = RelayModernRecord.getType(record);

      if (recordType !== node.type && dataID !== ROOT_ID$2) {
        isDataExpectedToBePresent = false;
      }
    } // If this is an abstract fragment (and the precise refinement GK is enabled)
    // then data is only expected to be present if the record type is known to
    // implement the interface. If we aren't sure whether the record implements
    // the interface, that itself constitutes "expected" data being missing.


    if (isDataExpectedToBePresent && abstractKey != null && record != null && RelayFeatureFlags_1.ENABLE_PRECISE_TYPE_REFINEMENT) {
      var _recordType = RelayModernRecord.getType(record);

      var typeID = generateTypeID$1(_recordType);

      var typeRecord = this._recordSource.get(typeID);

      var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;

      if (implementsInterface === false) {
        // Type known to not implement the interface
        isDataExpectedToBePresent = false;
      } else if (implementsInterface == null) {
        // Don't know if the type implements the interface or not
        this._isMissingData = true;
      }
    }

    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;

    var data = this._traverse(node, dataID, null);

    return {
      data: data,
      isMissingData: this._isMissingData && isDataExpectedToBePresent,
      seenRecords: this._seenRecords,
      selector: this._selector,
      missingRequiredFields: this._missingRequiredFields
    };
  };

  _proto._traverse = function _traverse(node, dataID, prevData) {
    var record = this._recordSource.get(dataID);

    this._seenRecords.add(dataID);

    if (record == null) {
      if (record === undefined) {
        this._isMissingData = true;
      }

      return record;
    }

    var data = prevData || {};

    var hadRequiredData = this._traverseSelections(node.selections, record, data);

    return hadRequiredData ? data : null;
  };

  _proto._getVariableValue = function _getVariableValue(name) {
    !this._variables.hasOwnProperty(name) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReader(): Undefined variable `%s`.', name) : browser$1(false) : void 0; // $FlowFixMe[cannot-write]

    return this._variables[name];
  };

  _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action, record) {
    var _this$_missingRequire;

    if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === 'THROW') {
      // Chained @required directives may cause a parent `@required(action:
      // THROW)` field to become null, so the first missing field we
      // encounter is likely to be the root cause of the error.
      return;
    }

    var owner = this._selector.node.name;

    switch (action) {
      case 'THROW':
        this._missingRequiredFields = {
          action: action,
          field: {
            path: fieldPath,
            owner: owner
          }
        };
        return;

      case 'LOG':
        if (this._missingRequiredFields == null) {
          this._missingRequiredFields = {
            action: action,
            fields: []
          };
        }

        this._missingRequiredFields.fields.push({
          path: fieldPath,
          owner: owner
        });

        return;
    }
  };

  _proto._traverseSelections = function _traverseSelections(selections, record, data)
  /* had all expected data */
  {
    for (var i = 0; i < selections.length; i++) {
      var selection = selections[i];

      switch (selection.kind) {
        case REQUIRED_FIELD:
           process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReader(): Encountered a `@required` directive at path "%s" in `%s` without the `ENABLE_REQUIRED_DIRECTIVES` feature flag enabled.', selection.path, this._selector.node.name) : browser$1(false) ;

          var fieldValue = this._readRequiredField(selection, record, data);

          if (fieldValue == null) {
            var action = selection.action;

            if (action !== 'NONE') {
              this._maybeReportUnexpectedNull(selection.path, action, record);
            } // We are going to throw, or our parent is going to get nulled out.
            // Either way, sibling values are going to be ignored, so we can
            // bail early here as an optimization.


            return false;
          }

          break;

        case SCALAR_FIELD$1:
          this._readScalar(selection, record, data);

          break;

        case LINKED_FIELD$1:
          if (selection.plural) {
            this._readPluralLink(selection, record, data);
          } else {
            this._readLink(selection, record, data);
          }

          break;

        case CONDITION$1:
          var conditionValue = this._getVariableValue(selection.condition);

          if (conditionValue === selection.passingValue) {
            var hasExpectedData = this._traverseSelections(selection.selections, record, data);

            if (!hasExpectedData) {
              return false;
            }
          }

          break;

        case INLINE_FRAGMENT$1:
          {
            var abstractKey = selection.abstractKey;

            if (abstractKey == null) {
              // concrete type refinement: only read data if the type exactly matches
              var typeName = RelayModernRecord.getType(record);

              if (typeName != null && typeName === selection.type) {
                var _hasExpectedData = this._traverseSelections(selection.selections, record, data);

                if (!_hasExpectedData) {
                  return false;
                }
              }
            } else {
              // legacy behavior for abstract refinements: always read even
              // if the type doesn't conform and don't reset isMissingData
              this._traverseSelections(selection.selections, record, data);
            }

            break;
          }

        case RELAY_RESOLVER:
          {
            {
              throw new Error('Relay Resolver fields are not yet supported.');
            }
          }

        case FRAGMENT_SPREAD$1:
          this._createFragmentPointer(selection, record, data);

          break;

        case MODULE_IMPORT$1:
          this._readModuleImport(selection, record, data);

          break;

        case INLINE_DATA_FRAGMENT_SPREAD:
          this._createInlineDataOrResolverFragmentPointer(selection, record, data);

          break;

        case DEFER$1:
        case CLIENT_EXTENSION$1:
          {
            var isMissingData = this._isMissingData;

            var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);

            this._isMissingData = isMissingData;

            if (!_hasExpectedData2) {
              return false;
            }

            break;
          }

        case STREAM$1:
          {
            var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);

            if (!_hasExpectedData3) {
              return false;
            }

            break;
          }

        case FLIGHT_FIELD$1:
          {
            throw new Error('Flight fields are not yet supported.');
          }

        default:
           process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : browser$1(false) ;
      }
    }

    return true;
  };

  _proto._readRequiredField = function _readRequiredField(selection, record, data) {
    switch (selection.field.kind) {
      case SCALAR_FIELD$1:
        return this._readScalar(selection.field, record, data);

      case LINKED_FIELD$1:
        if (selection.field.plural) {
          return this._readPluralLink(selection.field, record, data);
        } else {
          return this._readLink(selection.field, record, data);
        }

      default:
        selection.field.kind;
         process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : browser$1(false) ;
    }
  };

  _proto._readResolverField = function _readResolverField(selection, record, data) {
    var _this = this;

    var name = selection.name,
        alias = selection.alias,
        resolverModule = selection.resolverModule,
        fragment = selection.fragment;
    var key = {
      __id: RelayModernRecord.getDataID(record),
      __fragmentOwner: this._owner,
      __fragments: (0, _defineProperty2["default"])({}, fragment.name, {})
    };
    var resolverContext = {
      getDataForResolverFragment: function getDataForResolverFragment(singularReaderSelector) {
        var _resolverFragmentData;

        var resolverFragmentData = {};

        _this._createInlineDataOrResolverFragmentPointer(singularReaderSelector.node, record, resolverFragmentData);

        var answer = (_resolverFragmentData = resolverFragmentData[FRAGMENTS_KEY$1]) === null || _resolverFragmentData === void 0 ? void 0 : _resolverFragmentData[fragment.name];
        !(typeof answer === 'object' && answer !== null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, "Expected reader data to contain a __fragments property with a property for the fragment named ".concat(fragment.name, ", but it is missing.")) : browser$1(false) : void 0;
        return answer;
      }
    };
    var resolverResult = withResolverContext$1(resolverContext, function () {
      return (// $FlowFixMe[prop-missing] - resolver module's type signature is a lie
        resolverModule(key)
      );
    });
    data[alias !== null && alias !== void 0 ? alias : name] = resolverResult;
    return resolverResult;
  };

  _proto._readFlightField = function _readFlightField(field, record, data) {
    var _field$alias;

    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;
    var storageKey = getStorageKey$3(field, this._variables);
    var reactFlightClientResponseRecordID = RelayModernRecord.getLinkedRecordID(record, storageKey);

    if (reactFlightClientResponseRecordID == null) {
      data[applicationName] = reactFlightClientResponseRecordID;

      if (reactFlightClientResponseRecordID === undefined) {
        this._isMissingData = true;
      }

      return reactFlightClientResponseRecordID;
    }

    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightClientResponseRecordID);

    this._seenRecords.add(reactFlightClientResponseRecordID);

    if (reactFlightClientResponseRecord == null) {
      data[applicationName] = reactFlightClientResponseRecord;

      if (reactFlightClientResponseRecord === undefined) {
        this._isMissingData = true;
      }

      return reactFlightClientResponseRecord;
    }

    var clientResponse = getReactFlightClientResponse$1(reactFlightClientResponseRecord);
    data[applicationName] = clientResponse;
    return clientResponse;
  };

  _proto._readScalar = function _readScalar(field, record, data) {
    var _field$alias2;

    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;
    var storageKey = getStorageKey$3(field, this._variables);
    var value = RelayModernRecord.getValue(record, storageKey);

    if (value === undefined) {
      this._isMissingData = true;
    }

    data[applicationName] = value;
    return value;
  };

  _proto._readLink = function _readLink(field, record, data) {
    var _field$alias3;

    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;
    var storageKey = getStorageKey$3(field, this._variables);
    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);

    if (linkedID == null) {
      data[applicationName] = linkedID;

      if (linkedID === undefined) {
        this._isMissingData = true;
      }

      return linkedID;
    }

    var prevData = data[applicationName];
    !(prevData == null || typeof prevData === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : browser$1(false) : void 0; // $FlowFixMe[incompatible-variance]

    var value = this._traverse(field, linkedID, prevData);

    data[applicationName] = value;
    return value;
  };

  _proto._readPluralLink = function _readPluralLink(field, record, data) {
    var _this2 = this;

    var _field$alias4;

    var applicationName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;
    var storageKey = getStorageKey$3(field, this._variables);
    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);

    if (linkedIDs == null) {
      data[applicationName] = linkedIDs;

      if (linkedIDs === undefined) {
        this._isMissingData = true;
      }

      return linkedIDs;
    }

    var prevData = data[applicationName];
    !(prevData == null || Array.isArray(prevData)) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : browser$1(false) : void 0;
    var linkedArray = prevData || [];
    linkedIDs.forEach(function (linkedID, nextIndex) {
      if (linkedID == null) {
        if (linkedID === undefined) {
          _this2._isMissingData = true;
        } // $FlowFixMe[cannot-write]


        linkedArray[nextIndex] = linkedID;
        return;
      }

      var prevItem = linkedArray[nextIndex];
      !(prevItem == null || typeof prevItem === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : browser$1(false) : void 0; // $FlowFixMe[cannot-write]
      // $FlowFixMe[incompatible-variance]

      linkedArray[nextIndex] = _this2._traverse(field, linkedID, prevItem);
    });
    data[applicationName] = linkedArray;
    return linkedArray;
  }
  /**
   * Reads a ReaderModuleImport, which was generated from using the @module
   * directive.
   */
  ;

  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {
    // Determine the component module from the store: if the field is missing
    // it means we don't know what component to render the match with.
    var componentKey = getModuleComponentKey$2(moduleImport.documentName);
    var component = RelayModernRecord.getValue(record, componentKey);

    if (component == null) {
      if (component === undefined) {
        this._isMissingData = true;
      }

      return;
    } // Otherwise, read the fragment and module associated to the concrete
    // type, and put that data with the result:
    // - For the matched fragment, create the relevant fragment pointer and add
    //   the expected fragmentPropName
    // - For the matched module, create a reference to the module


    this._createFragmentPointer({
      kind: 'FragmentSpread',
      name: moduleImport.fragmentName,
      args: null
    }, record, data);

    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;
    data[MODULE_COMPONENT_KEY] = component;
  };

  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {
    var fragmentPointers = data[FRAGMENTS_KEY$1];

    if (fragmentPointers == null) {
      fragmentPointers = data[FRAGMENTS_KEY$1] = {};
    }

    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : browser$1(false) : void 0;

    if (data[ID_KEY$2] == null) {
      data[ID_KEY$2] = RelayModernRecord.getDataID(record);
    } // $FlowFixMe[cannot-write] - writing into read-only field


    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues$2(fragmentSpread.args, this._variables) : {};
    data[FRAGMENT_OWNER_KEY$1] = this._owner;
  };

  _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {
    var fragmentPointers = data[FRAGMENTS_KEY$1];

    if (fragmentPointers == null) {
      fragmentPointers = data[FRAGMENTS_KEY$1] = {};
    }

    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : browser$1(false) : void 0;

    if (data[ID_KEY$2] == null) {
      data[ID_KEY$2] = RelayModernRecord.getDataID(record);
    }

    var inlineData = {};

    this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData); // $FlowFixMe[cannot-write] - writing into read-only field


    fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;
  };

  return RelayReader;
}();

var RelayReader_1 = {
  read: read
};

var EXISTENT$1 = RelayRecordState_1.EXISTENT;

/**
 * @internal
 *
 * Wrapper API that is an amalgam of the `RelayModernRecord` API and
 * `MutableRecordSource` interface, implementing copy-on-write semantics for records
 * in a record source.
 *
 * Modifications are applied to fresh copies of records:
 * - Records in `base` are never modified.
 * - Modifications cause a fresh version of a record to be created in `sink`.
 *   These sink records contain only modified fields.
 */
var RelayRecordSourceMutator = /*#__PURE__*/function () {
  function RelayRecordSourceMutator(base, sink) {
    this.__sources = [sink, base];
    this._base = base;
    this._sink = sink;
  }
  /**
   * **UNSTABLE**
   * This method is likely to be removed in an upcoming release
   * and should not be relied upon.
   * TODO T41593196: Remove unstable_getRawRecordWithChanges
   */


  var _proto = RelayRecordSourceMutator.prototype;

  _proto.unstable_getRawRecordWithChanges = function unstable_getRawRecordWithChanges(dataID) {
    var baseRecord = this._base.get(dataID);

    var sinkRecord = this._sink.get(dataID);

    if (sinkRecord === undefined) {
      if (baseRecord == null) {
        return baseRecord;
      }

      var nextRecord = RelayModernRecord.clone(baseRecord);

      if (process$1.env.NODE_ENV !== "production") {
        // Prevent mutation of a record from outside the store.
        RelayModernRecord.freeze(nextRecord);
      }

      return nextRecord;
    } else if (sinkRecord === null) {
      return null;
    } else if (baseRecord != null) {
      var _nextRecord = RelayModernRecord.update(baseRecord, sinkRecord);

      if (process$1.env.NODE_ENV !== "production") {
        if (_nextRecord !== baseRecord) {
          // Prevent mutation of a record from outside the store.
          RelayModernRecord.freeze(_nextRecord);
        }
      }

      return _nextRecord;
    } else {
      var _nextRecord2 = RelayModernRecord.clone(sinkRecord);

      if (process$1.env.NODE_ENV !== "production") {
        // Prevent mutation of a record from outside the store.
        RelayModernRecord.freeze(_nextRecord2);
      }

      return _nextRecord2;
    }
  };

  _proto._getSinkRecord = function _getSinkRecord(dataID) {
    var sinkRecord = this._sink.get(dataID);

    if (!sinkRecord) {
      var baseRecord = this._base.get(dataID);

      !baseRecord ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordSourceMutator: Cannot modify non-existent record `%s`.', dataID) : browser$1(false) : void 0;
      sinkRecord = RelayModernRecord.create(dataID, RelayModernRecord.getType(baseRecord));

      this._sink.set(dataID, sinkRecord);
    }

    return sinkRecord;
  };

  _proto.copyFields = function copyFields(sourceID, sinkID) {
    var sinkSource = this._sink.get(sourceID);

    var baseSource = this._base.get(sourceID);

    !(sinkSource || baseSource) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordSourceMutator#copyFields(): Cannot copy fields from ' + 'non-existent record `%s`.', sourceID) : browser$1(false) : void 0;

    var sink = this._getSinkRecord(sinkID);

    if (baseSource) {
      RelayModernRecord.copyFields(baseSource, sink);
    }

    if (sinkSource) {
      RelayModernRecord.copyFields(sinkSource, sink);
    }
  };

  _proto.copyFieldsFromRecord = function copyFieldsFromRecord(record, sinkID) {
    var sink = this._getSinkRecord(sinkID);

    RelayModernRecord.copyFields(record, sink);
  };

  _proto.create = function create(dataID, typeName) {
    !(this._base.getStatus(dataID) !== EXISTENT$1 && this._sink.getStatus(dataID) !== EXISTENT$1) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordSourceMutator#create(): Cannot create a record with id ' + '`%s`, this record already exists.', dataID) : browser$1(false) : void 0;
    var record = RelayModernRecord.create(dataID, typeName);

    this._sink.set(dataID, record);
  };

  _proto["delete"] = function _delete(dataID) {
    this._sink["delete"](dataID);
  };

  _proto.getStatus = function getStatus(dataID) {
    return this._sink.has(dataID) ? this._sink.getStatus(dataID) : this._base.getStatus(dataID);
  };

  _proto.getType = function getType(dataID) {
    for (var ii = 0; ii < this.__sources.length; ii++) {
      var record = this.__sources[ii].get(dataID);

      if (record) {
        return RelayModernRecord.getType(record);
      } else if (record === null) {
        return null;
      }
    }
  };

  _proto.getValue = function getValue(dataID, storageKey) {
    for (var ii = 0; ii < this.__sources.length; ii++) {
      var record = this.__sources[ii].get(dataID);

      if (record) {
        var value = RelayModernRecord.getValue(record, storageKey);

        if (value !== undefined) {
          return value;
        }
      } else if (record === null) {
        return null;
      }
    }
  };

  _proto.setValue = function setValue(dataID, storageKey, value) {
    var sinkRecord = this._getSinkRecord(dataID);

    RelayModernRecord.setValue(sinkRecord, storageKey, value);
  };

  _proto.getLinkedRecordID = function getLinkedRecordID(dataID, storageKey) {
    for (var ii = 0; ii < this.__sources.length; ii++) {
      var record = this.__sources[ii].get(dataID);

      if (record) {
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);

        if (linkedID !== undefined) {
          return linkedID;
        }
      } else if (record === null) {
        return null;
      }
    }
  };

  _proto.setLinkedRecordID = function setLinkedRecordID(dataID, storageKey, linkedID) {
    var sinkRecord = this._getSinkRecord(dataID);

    RelayModernRecord.setLinkedRecordID(sinkRecord, storageKey, linkedID);
  };

  _proto.getLinkedRecordIDs = function getLinkedRecordIDs(dataID, storageKey) {
    for (var ii = 0; ii < this.__sources.length; ii++) {
      var record = this.__sources[ii].get(dataID);

      if (record) {
        var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);

        if (linkedIDs !== undefined) {
          return linkedIDs;
        }
      } else if (record === null) {
        return null;
      }
    }
  };

  _proto.setLinkedRecordIDs = function setLinkedRecordIDs(dataID, storageKey, linkedIDs) {
    var sinkRecord = this._getSinkRecord(dataID);

    RelayModernRecord.setLinkedRecordIDs(sinkRecord, storageKey, linkedIDs);
  };

  return RelayRecordSourceMutator;
}();

var RelayRecordSourceMutator_1 = RelayRecordSourceMutator;

var generateClientID$4 = ClientID.generateClientID;

var getStableStorageKey$2 = RelayStoreUtils_1.getStableStorageKey;

/**
 * @internal
 *
 * A helper class for manipulating a given record from a record source via an
 * imperative/OO-style API.
 */
var RelayRecordProxy = /*#__PURE__*/function () {
  function RelayRecordProxy(source, mutator, dataID) {
    this._dataID = dataID;
    this._mutator = mutator;
    this._source = source;
  }

  var _proto = RelayRecordProxy.prototype;

  _proto.copyFieldsFrom = function copyFieldsFrom(source) {
    this._mutator.copyFields(source.getDataID(), this._dataID);
  };

  _proto.getDataID = function getDataID() {
    return this._dataID;
  };

  _proto.getType = function getType() {
    var type = this._mutator.getType(this._dataID);

    !(type != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordProxy: Cannot get the type of deleted record `%s`.', this._dataID) : browser$1(false) : void 0;
    return type;
  };

  _proto.getValue = function getValue(name, args) {
    var storageKey = getStableStorageKey$2(name, args);
    return this._mutator.getValue(this._dataID, storageKey);
  };

  _proto.setValue = function setValue(value, name, args) {
    !isValidLeafValue(value) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordProxy#setValue(): Expected a scalar or array of scalars, ' + 'got `%s`.', JSON.stringify(value)) : browser$1(false) : void 0;
    var storageKey = getStableStorageKey$2(name, args);

    this._mutator.setValue(this._dataID, storageKey, value);

    return this;
  };

  _proto.getLinkedRecord = function getLinkedRecord(name, args) {
    var storageKey = getStableStorageKey$2(name, args);

    var linkedID = this._mutator.getLinkedRecordID(this._dataID, storageKey);

    return linkedID != null ? this._source.get(linkedID) : linkedID;
  };

  _proto.setLinkedRecord = function setLinkedRecord(record, name, args) {
    !(record instanceof RelayRecordProxy) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordProxy#setLinkedRecord(): Expected a record, got `%s`.', record) : browser$1(false) : void 0;
    var storageKey = getStableStorageKey$2(name, args);
    var linkedID = record.getDataID();

    this._mutator.setLinkedRecordID(this._dataID, storageKey, linkedID);

    return this;
  };

  _proto.getOrCreateLinkedRecord = function getOrCreateLinkedRecord(name, typeName, args) {
    var linkedRecord = this.getLinkedRecord(name, args);

    if (!linkedRecord) {
      var _this$_source$get;

      var storageKey = getStableStorageKey$2(name, args);
      var clientID = generateClientID$4(this.getDataID(), storageKey); // NOTE: it's possible that a client record for this field exists
      // but the field itself was unset.

      linkedRecord = (_this$_source$get = this._source.get(clientID)) !== null && _this$_source$get !== void 0 ? _this$_source$get : this._source.create(clientID, typeName);
      this.setLinkedRecord(linkedRecord, name, args);
    }

    return linkedRecord;
  };

  _proto.getLinkedRecords = function getLinkedRecords(name, args) {
    var _this = this;

    var storageKey = getStableStorageKey$2(name, args);

    var linkedIDs = this._mutator.getLinkedRecordIDs(this._dataID, storageKey);

    if (linkedIDs == null) {
      return linkedIDs;
    }

    return linkedIDs.map(function (linkedID) {
      return linkedID != null ? _this._source.get(linkedID) : linkedID;
    });
  };

  _proto.setLinkedRecords = function setLinkedRecords(records, name, args) {
    !Array.isArray(records) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordProxy#setLinkedRecords(): Expected records to be an array, got `%s`.', records) : browser$1(false) : void 0;
    var storageKey = getStableStorageKey$2(name, args);
    var linkedIDs = records.map(function (record) {
      return record && record.getDataID();
    });

    this._mutator.setLinkedRecordIDs(this._dataID, storageKey, linkedIDs);

    return this;
  };

  _proto.invalidateRecord = function invalidateRecord() {
    this._source.markIDForInvalidation(this._dataID);
  };

  return RelayRecordProxy;
}();

function isValidLeafValue(value) {
  return value == null || typeof value !== 'object' || Array.isArray(value) && value.every(isValidLeafValue);
}

var RelayRecordProxy_1 = RelayRecordProxy;

var EXISTENT$2 = RelayRecordState_1.EXISTENT,
    NONEXISTENT$1 = RelayRecordState_1.NONEXISTENT;

var ROOT_ID$3 = RelayStoreUtils_1.ROOT_ID,
    ROOT_TYPE$2 = RelayStoreUtils_1.ROOT_TYPE;

/**
 * @internal
 *
 * A helper for manipulating a `RecordSource` via an imperative/OO-style API.
 */
var RelayRecordSourceProxy = /*#__PURE__*/function () {
  function RelayRecordSourceProxy(mutator, getDataID, handlerProvider) {
    this.__mutator = mutator;
    this._handlerProvider = handlerProvider || null;
    this._proxies = {};
    this._getDataID = getDataID;
    this._invalidatedStore = false;
    this._idsMarkedForInvalidation = new Set();
  }

  var _proto = RelayRecordSourceProxy.prototype;

  _proto.publishSource = function publishSource(source, fieldPayloads) {
    var _this = this;

    var dataIDs = source.getRecordIDs();
    dataIDs.forEach(function (dataID) {
      var status = source.getStatus(dataID);

      if (status === EXISTENT$2) {
        var sourceRecord = source.get(dataID);

        if (sourceRecord) {
          if (_this.__mutator.getStatus(dataID) !== EXISTENT$2) {
            _this.create(dataID, RelayModernRecord.getType(sourceRecord));
          }

          _this.__mutator.copyFieldsFromRecord(sourceRecord, dataID);
        }
      } else if (status === NONEXISTENT$1) {
        _this["delete"](dataID);
      }
    });

    if (fieldPayloads && fieldPayloads.length) {
      fieldPayloads.forEach(function (fieldPayload) {
        var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);

        !handler ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected a handler to be provided for handle `%s`.', fieldPayload.handle) : browser$1(false) : void 0;
        handler.update(_this, fieldPayload);
      });
    }
  };

  _proto.create = function create(dataID, typeName) {
    this.__mutator.create(dataID, typeName);

    delete this._proxies[dataID];
    var record = this.get(dataID); // For flow

    !record ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordSourceProxy#create(): Expected the created record to exist.') : browser$1(false) : void 0;
    return record;
  };

  _proto["delete"] = function _delete(dataID) {
    !(dataID !== ROOT_ID$3) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordSourceProxy#delete(): Cannot delete the root record.') : browser$1(false) : void 0;
    delete this._proxies[dataID];

    this.__mutator["delete"](dataID);
  };

  _proto.get = function get(dataID) {
    if (!this._proxies.hasOwnProperty(dataID)) {
      var status = this.__mutator.getStatus(dataID);

      if (status === EXISTENT$2) {
        this._proxies[dataID] = new RelayRecordProxy_1(this, this.__mutator, dataID);
      } else {
        this._proxies[dataID] = status === NONEXISTENT$1 ? null : undefined;
      }
    }

    return this._proxies[dataID];
  };

  _proto.getRoot = function getRoot() {
    var root = this.get(ROOT_ID$3);

    if (!root) {
      root = this.create(ROOT_ID$3, ROOT_TYPE$2);
    }

    !(root && root.getType() === ROOT_TYPE$2) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordSourceProxy#getRoot(): Expected the source to contain a ' + 'root record, %s.', root == null ? 'no root record found' : "found a root record of type `".concat(root.getType(), "`")) : browser$1(false) : void 0;
    return root;
  };

  _proto.invalidateStore = function invalidateStore() {
    this._invalidatedStore = true;
  };

  _proto.isStoreMarkedForInvalidation = function isStoreMarkedForInvalidation() {
    return this._invalidatedStore;
  };

  _proto.markIDForInvalidation = function markIDForInvalidation(dataID) {
    this._idsMarkedForInvalidation.add(dataID);
  };

  _proto.getIDsMarkedForInvalidation = function getIDsMarkedForInvalidation() {
    return this._idsMarkedForInvalidation;
  };

  return RelayRecordSourceProxy;
}();

var RelayRecordSourceProxy_1 = RelayRecordSourceProxy;

var getStorageKey$4 = RelayStoreUtils_1.getStorageKey,
    ROOT_TYPE$3 = RelayStoreUtils_1.ROOT_TYPE;

/**
 * @internal
 *
 * A subclass of RecordSourceProxy that provides convenience methods for
 * accessing the root fields of a given query/mutation. These fields accept
 * complex arguments and it can be tedious to re-construct the correct sets of
 * arguments to pass to e.g. `getRoot().getLinkedRecord()`.
 */
var RelayRecordSourceSelectorProxy = /*#__PURE__*/function () {
  function RelayRecordSourceSelectorProxy(mutator, recordSource, readSelector) {
    this.__mutator = mutator;
    this.__recordSource = recordSource;
    this._readSelector = readSelector;
  }

  var _proto = RelayRecordSourceSelectorProxy.prototype;

  _proto.create = function create(dataID, typeName) {
    return this.__recordSource.create(dataID, typeName);
  };

  _proto["delete"] = function _delete(dataID) {
    this.__recordSource["delete"](dataID);
  };

  _proto.get = function get(dataID) {
    return this.__recordSource.get(dataID);
  };

  _proto.getRoot = function getRoot() {
    return this.__recordSource.getRoot();
  };

  _proto.getOperationRoot = function getOperationRoot() {
    var root = this.__recordSource.get(this._readSelector.dataID);

    if (!root) {
      root = this.__recordSource.create(this._readSelector.dataID, ROOT_TYPE$3);
    }

    return root;
  };

  _proto._getRootField = function _getRootField(selector, fieldName, plural) {
    var field = selector.node.selections.find(function (selection) {
      return selection.kind === 'LinkedField' && selection.name === fieldName;
    });
    !(field && field.kind === 'LinkedField') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordSourceSelectorProxy#getRootField(): Cannot find root ' + 'field `%s`, no such field is defined on GraphQL document `%s`.', fieldName, selector.node.name) : browser$1(false) : void 0;
    !(field.plural === plural) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayRecordSourceSelectorProxy#getRootField(): Expected root field ' + '`%s` to be %s.', fieldName, plural ? 'plural' : 'singular') : browser$1(false) : void 0;
    return field;
  };

  _proto.getRootField = function getRootField(fieldName) {
    var field = this._getRootField(this._readSelector, fieldName, false);

    var storageKey = getStorageKey$4(field, this._readSelector.variables);
    return this.getOperationRoot().getLinkedRecord(storageKey);
  };

  _proto.getPluralRootField = function getPluralRootField(fieldName) {
    var field = this._getRootField(this._readSelector, fieldName, true);

    var storageKey = getStorageKey$4(field, this._readSelector.variables);
    return this.getOperationRoot().getLinkedRecords(storageKey);
  };

  _proto.invalidateStore = function invalidateStore() {
    this.__recordSource.invalidateStore();
  };

  return RelayRecordSourceSelectorProxy;
}();

var RelayRecordSourceSelectorProxy_1 = RelayRecordSourceSelectorProxy;

var _global$ErrorUtils$ap, _global$ErrorUtils;















var applyWithGuard = (_global$ErrorUtils$ap = (_global$ErrorUtils = commonjsGlobal.ErrorUtils) === null || _global$ErrorUtils === void 0 ? void 0 : _global$ErrorUtils.applyWithGuard) !== null && _global$ErrorUtils$ap !== void 0 ? _global$ErrorUtils$ap : function (callback, context, args, onError, name) {
  return callback.apply(context, args);
};
/**
 * Coordinates the concurrent modification of a `Store` due to optimistic and
 * non-revertable client updates and server payloads:
 * - Applies optimistic updates.
 * - Reverts optimistic updates, rebasing any subsequent updates.
 * - Commits client updates (typically for client schema extensions).
 * - Commits server updates:
 *   - Normalizes query/mutation/subscription responses.
 *   - Executes handlers for "handle" fields.
 *   - Reverts and reapplies pending optimistic updates.
 */

var RelayPublishQueue = /*#__PURE__*/function () {
  // True if the next `run()` should apply the backup and rerun all optimistic
  // updates performing a rebase.
  // Payloads to apply or Sources to publish to the store with the next `run()`.
  // Optimistic updaters to add with the next `run()`.
  // Optimistic updaters that are already added and might be rerun in order to
  // rebase them.
  // Garbage collection hold, should rerun gc on dispose
  function RelayPublishQueue(store, handlerProvider, getDataID) {
    this._hasStoreSnapshot = false;
    this._handlerProvider = handlerProvider || null;
    this._pendingBackupRebase = false;
    this._pendingData = new Set();
    this._pendingOptimisticUpdates = new Set();
    this._store = store;
    this._appliedOptimisticUpdates = new Set();
    this._gcHold = null;
    this._getDataID = getDataID;
  }
  /**
   * Schedule applying an optimistic updates on the next `run()`.
   */


  var _proto = RelayPublishQueue.prototype;

  _proto.applyUpdate = function applyUpdate(updater) {
    !(!this._appliedOptimisticUpdates.has(updater) && !this._pendingOptimisticUpdates.has(updater)) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayPublishQueue: Cannot apply the same update function more than ' + 'once concurrently.') : browser$1(false) : void 0;

    this._pendingOptimisticUpdates.add(updater);
  }
  /**
   * Schedule reverting an optimistic updates on the next `run()`.
   */
  ;

  _proto.revertUpdate = function revertUpdate(updater) {
    if (this._pendingOptimisticUpdates.has(updater)) {
      // Reverted before it was applied
      this._pendingOptimisticUpdates["delete"](updater);
    } else if (this._appliedOptimisticUpdates.has(updater)) {
      this._pendingBackupRebase = true;

      this._appliedOptimisticUpdates["delete"](updater);
    }
  }
  /**
   * Schedule a revert of all optimistic updates on the next `run()`.
   */
  ;

  _proto.revertAll = function revertAll() {
    this._pendingBackupRebase = true;

    this._pendingOptimisticUpdates.clear();

    this._appliedOptimisticUpdates.clear();
  }
  /**
   * Schedule applying a payload to the store on the next `run()`.
   */
  ;

  _proto.commitPayload = function commitPayload(operation, payload, updater) {
    this._pendingBackupRebase = true;

    this._pendingData.add({
      kind: 'payload',
      operation: operation,
      payload: payload,
      updater: updater
    });
  }
  /**
   * Schedule an updater to mutate the store on the next `run()` typically to
   * update client schema fields.
   */
  ;

  _proto.commitUpdate = function commitUpdate(updater) {
    this._pendingBackupRebase = true;

    this._pendingData.add({
      kind: 'updater',
      updater: updater
    });
  }
  /**
   * Schedule a publish to the store from the provided source on the next
   * `run()`. As an example, to update the store with substituted fields that
   * are missing in the store.
   */
  ;

  _proto.commitSource = function commitSource(source) {
    this._pendingBackupRebase = true;

    this._pendingData.add({
      kind: 'source',
      source: source
    });
  }
  /**
   * Execute all queued up operations from the other public methods.
   */
  ;

  _proto.run = function run(sourceOperation) {
    if (process$1.env.NODE_ENV !== "production") {
      process$1.env.NODE_ENV !== "production" ? warning_1(this._isRunning !== true, 'A store update was detected within another store update. Please ' + "make sure new store updates aren't being executed within an " + 'updater function for a different update.') : void 0;
      this._isRunning = true;
    }

    if (this._pendingBackupRebase) {
      if (this._hasStoreSnapshot) {
        this._store.restore();

        this._hasStoreSnapshot = false;
      }
    }

    var invalidatedStore = this._commitData();

    if (this._pendingOptimisticUpdates.size || this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {
      if (!this._hasStoreSnapshot) {
        this._store.snapshot();

        this._hasStoreSnapshot = true;
      }

      this._applyUpdates();
    }

    this._pendingBackupRebase = false;

    if (this._appliedOptimisticUpdates.size > 0) {
      if (!this._gcHold) {
        this._gcHold = this._store.holdGC();
      }
    } else {
      if (this._gcHold) {
        this._gcHold.dispose();

        this._gcHold = null;
      }
    }

    if (process$1.env.NODE_ENV !== "production") {
      this._isRunning = false;
    }

    return this._store.notify(sourceOperation, invalidatedStore);
  }
  /**
   * _publishSourceFromPayload will return a boolean indicating if the
   * publish caused the store to be globally invalidated.
   */
  ;

  _proto._publishSourceFromPayload = function _publishSourceFromPayload(pendingPayload) {
    var _this = this;

    var payload = pendingPayload.payload,
        operation = pendingPayload.operation,
        updater = pendingPayload.updater;
    var source = payload.source,
        fieldPayloads = payload.fieldPayloads;
    var mutator = new RelayRecordSourceMutator_1(this._store.getSource(), source);
    var recordSourceProxy = new RelayRecordSourceProxy_1(mutator, this._getDataID);

    if (fieldPayloads && fieldPayloads.length) {
      fieldPayloads.forEach(function (fieldPayload) {
        var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);

        !handler ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected a handler to be provided for ' + 'handle `%s`.', fieldPayload.handle) : browser$1(false) : void 0;
        handler.update(recordSourceProxy, fieldPayload);
      });
    }

    if (updater) {
      var selector = operation.fragment;
      !(selector != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected a selector to be provided with updater function.') : browser$1(false) : void 0;
      var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy_1(mutator, recordSourceProxy, selector);
      var selectorData = lookupSelector(source, selector);
      updater(recordSourceSelectorProxy, selectorData);
    }

    var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();

    this._store.publish(source, idsMarkedForInvalidation);

    return recordSourceProxy.isStoreMarkedForInvalidation();
  }
  /**
   * _commitData will return a boolean indicating if any of
   * the pending commits caused the store to be globally invalidated.
   */
  ;

  _proto._commitData = function _commitData() {
    var _this2 = this;

    if (!this._pendingData.size) {
      return false;
    }

    var invalidatedStore = false;

    this._pendingData.forEach(function (data) {
      if (data.kind === 'payload') {
        var payloadInvalidatedStore = _this2._publishSourceFromPayload(data);

        invalidatedStore = invalidatedStore || payloadInvalidatedStore;
      } else if (data.kind === 'source') {
        var source = data.source;

        _this2._store.publish(source);
      } else {
        var updater = data.updater;
        var sink = RelayRecordSource_1.create();
        var mutator = new RelayRecordSourceMutator_1(_this2._store.getSource(), sink);
        var recordSourceProxy = new RelayRecordSourceProxy_1(mutator, _this2._getDataID);
        applyWithGuard(updater, null, [recordSourceProxy], null, 'RelayPublishQueue:commitData');
        invalidatedStore = invalidatedStore || recordSourceProxy.isStoreMarkedForInvalidation();
        var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();

        _this2._store.publish(sink, idsMarkedForInvalidation);
      }
    });

    this._pendingData.clear();

    return invalidatedStore;
  }
  /**
   * Note that unlike _commitData, _applyUpdates will NOT return a boolean
   * indicating if the store was globally invalidated, since invalidating the
   * store during an optimistic update is a no-op.
   */
  ;

  _proto._applyUpdates = function _applyUpdates() {
    var _this3 = this;

    var sink = RelayRecordSource_1.create();
    var mutator = new RelayRecordSourceMutator_1(this._store.getSource(), sink);
    var recordSourceProxy = new RelayRecordSourceProxy_1(mutator, this._getDataID, this._handlerProvider);

    var processUpdate = function processUpdate(optimisticUpdate) {
      if (optimisticUpdate.storeUpdater) {
        var storeUpdater = optimisticUpdate.storeUpdater;
        applyWithGuard(storeUpdater, null, [recordSourceProxy], null, 'RelayPublishQueue:applyUpdates');
      } else {
        var operation = optimisticUpdate.operation,
            payload = optimisticUpdate.payload,
            updater = optimisticUpdate.updater;
        var source = payload.source,
            fieldPayloads = payload.fieldPayloads;
        var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy_1(mutator, recordSourceProxy, operation.fragment);
        var selectorData;

        if (source) {
          recordSourceProxy.publishSource(source, fieldPayloads);
          selectorData = lookupSelector(source, operation.fragment);
        }

        if (updater) {
          applyWithGuard(updater, null, [recordSourceSelectorProxy, selectorData], null, 'RelayPublishQueue:applyUpdates');
        }
      }
    }; // rerun all updaters in case we are running a rebase


    if (this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {
      this._appliedOptimisticUpdates.forEach(processUpdate);
    } // apply any new updaters


    if (this._pendingOptimisticUpdates.size) {
      this._pendingOptimisticUpdates.forEach(function (optimisticUpdate) {
        processUpdate(optimisticUpdate);

        _this3._appliedOptimisticUpdates.add(optimisticUpdate);
      });

      this._pendingOptimisticUpdates.clear();
    }

    this._store.publish(sink);
  };

  return RelayPublishQueue;
}();

function lookupSelector(source, selector) {
  var selectorData = RelayReader_1.read(source, selector).data;

  if (process$1.env.NODE_ENV !== "production") {
    var deepFreeze = deepFreeze_1;

    if (selectorData) {
      deepFreeze(selectorData);
    }
  }

  return selectorData;
}

var RelayPublishQueue_1 = RelayPublishQueue;

var generateClientID$5 = ClientID.generateClientID;

var ROOT_ID$4 = RelayStoreUtils_1.ROOT_ID;

var VIEWER_ID = generateClientID$5(ROOT_ID$4, 'viewer');
var VIEWER_TYPE = 'Viewer';
var ViewerPattern = {
  VIEWER_ID: VIEWER_ID,
  VIEWER_TYPE: VIEWER_TYPE
};

var VIEWER_ID$1 = ViewerPattern.VIEWER_ID,
    VIEWER_TYPE$1 = ViewerPattern.VIEWER_TYPE;

function defaultGetDataID(fieldValue, typeName) {
  if (typeName === VIEWER_TYPE$1) {
    // $FlowFixMe[prop-missing]
    return fieldValue.id == null ? VIEWER_ID$1 : fieldValue.id;
  } // $FlowFixMe[prop-missing]


  return fieldValue.id;
}

var defaultGetDataID_1 = defaultGetDataID;

var defaultRequiredFieldLogger = function defaultRequiredFieldLogger(event) {
  if (process$1.env.NODE_ENV !== "production" && event.kind === 'missing_field.log') {
    throw new Error('Relay Environment Configuration Error (dev only): `@required(action: LOG)` requires that the Relay Environment be configured with a `requiredFieldLogger`.');
  }
};

var defaultRequiredFieldLogger_1 = defaultRequiredFieldLogger;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var id = 100000;

function generateID() {
  return id++;
}

var generateID_1 = generateID;

var _objectSpread2$4 = interopRequireDefault(objectSpread2);

var _toConsumableArray2$3 = interopRequireDefault(toConsumableArray);

var inspect = function inspect() {};

if (process$1.env.NODE_ENV !== "production") {
  var formattersInstalled = false;
  /**
   * Installs a Chrome Developer Tools custom formatter for Relay proxy objects
   * returned by StoreInspector.inspect.
   *
   * bit.ly/object-formatters
   */

  var installDevtoolFormatters = function installDevtoolFormatters() {
    var _window$devtoolsForma;

    if (formattersInstalled) {
      return;
    }

    formattersInstalled = true;

    if (window.devtoolsFormatters == null) {
      window.devtoolsFormatters = [];
    }

    if (!Array.isArray(window.devtoolsFormatters)) {
      return;
    } // eslint-disable-next-line no-console


    console.info('Make sure to select "Enable custom formatters" in the Chrome ' + 'Developer Tools settings, tab "Preferences" under the "Console" ' + 'section.');

    (_window$devtoolsForma = window.devtoolsFormatters).push.apply(_window$devtoolsForma, (0, _toConsumableArray2$3["default"])(createFormatters()));
  };

  var createFormatters = function createFormatters() {
    var listStyle = {
      style: 'list-style-type: none; padding: 0; margin: 0 0 0 12px; font-style: normal'
    };
    var keyStyle = {
      style: 'rgb(136, 19, 145)'
    };
    var nullStyle = {
      style: 'color: #777'
    };

    var reference = function reference(object, config) {
      return object == null ? ['span', nullStyle, 'undefined'] : ['object', {
        object: object,
        config: config
      }];
    };

    var renderRecordHeader = function renderRecordHeader(record) {
      return ['span', {
        style: 'font-style: italic'
      }, record.__typename, ['span', nullStyle, ' {id: "', record.__id, '", }']];
    };

    var isRecord = function isRecord(o) {
      return o != null && typeof o.__id === 'string';
    };

    var RecordEntry = function RecordEntry(key, value) {
      this.key = key;
      this.value = value;
    };

    var renderRecordEntries = function renderRecordEntries(record) {
      var children = Object.keys(record).map(function (key) {
        return ['li', {}, ['object', {
          object: new RecordEntry(key, record[key])
        }]];
      });
      return ['ol', listStyle].concat((0, _toConsumableArray2$3["default"])(children));
    };

    var recordFormatter = {
      header: function header(obj) {
        if (!isRecord(obj)) {
          return null;
        }

        return renderRecordHeader(obj);
      },
      hasBody: function hasBody(obj) {
        return true;
      },
      body: function body(obj) {
        return renderRecordEntries(obj);
      }
    };
    var recordEntryFormatter = {
      header: function header(obj) {
        if (obj instanceof RecordEntry) {
          var value = isRecord(obj.value) ? renderRecordHeader(obj.value) : reference(obj.value);
          return ['span', keyStyle, obj.key, ': ', value];
        }

        return null;
      },
      hasBody: function hasBody(obj) {
        return isRecord(obj.value);
      },
      body: function body(obj) {
        return renderRecordEntries(obj.value);
      }
    };
    return [recordFormatter, recordEntryFormatter];
  };

  var getWrappedRecord = function getWrappedRecord(source, dataID) {
    var record = source.get(dataID);

    if (record == null) {
      return record;
    }

    return new Proxy((0, _objectSpread2$4["default"])({}, record), {
      get: function get(target, prop) {
        var value = target[prop];

        if (value == null) {
          return value;
        }

        if (typeof value === 'object') {
          if (typeof value.__ref === 'string') {
            return getWrappedRecord(source, value.__ref);
          }

          if (Array.isArray(value.__refs)) {
            // $FlowFixMe[incompatible-call]
            return value.__refs.map(function (ref) {
              return getWrappedRecord(source, ref);
            });
          }
        }

        return value;
      }
    });
  };

  inspect = function inspect(environment, dataID) {
    installDevtoolFormatters();
    return getWrappedRecord(environment.getStore().getSource(), dataID !== null && dataID !== void 0 ? dataID : 'client:root');
  };
}

var StoreInspector = {
  inspect: inspect
};

var _objectSpread2$5 = interopRequireDefault(objectSpread2);























var RelayModernEnvironment = /*#__PURE__*/function () {
  function RelayModernEnvironment(config) {
    var _this = this;

    var _config$log, _config$requiredField, _config$UNSTABLE_defa, _config$getDataID, _config$handlerProvid, _config$scheduler, _config$isServer, _config$operationTrac;

    this.configName = config.configName;
    this._treatMissingFieldsAsNull = config.treatMissingFieldsAsNull === true;
    var operationLoader = config.operationLoader;
    var reactFlightPayloadDeserializer = config.reactFlightPayloadDeserializer;
    var reactFlightServerErrorHandler = config.reactFlightServerErrorHandler;

    if (process$1.env.NODE_ENV !== "production") {
      if (operationLoader != null) {
        !(typeof operationLoader === 'object' && typeof operationLoader.get === 'function' && typeof operationLoader.load === 'function') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected `operationLoader` to be an object ' + 'with get() and load() functions, got `%s`.', operationLoader) : browser$1(false) : void 0;
      }

      if (reactFlightPayloadDeserializer != null) {
        !(typeof reactFlightPayloadDeserializer === 'function') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernEnvironment: Expected `reactFlightPayloadDeserializer` ' + ' to be a function, got `%s`.', reactFlightPayloadDeserializer) : browser$1(false) : void 0;
      }
    }

    this.__log = (_config$log = config.log) !== null && _config$log !== void 0 ? _config$log : emptyFunction$1;
    this.requiredFieldLogger = (_config$requiredField = config.requiredFieldLogger) !== null && _config$requiredField !== void 0 ? _config$requiredField : defaultRequiredFieldLogger_1;
    this._defaultRenderPolicy = ((_config$UNSTABLE_defa = config.UNSTABLE_defaultRenderPolicy) !== null && _config$UNSTABLE_defa !== void 0 ? _config$UNSTABLE_defa : RelayFeatureFlags_1.ENABLE_PARTIAL_RENDERING_DEFAULT === true) ? 'partial' : 'full';
    this._operationLoader = operationLoader;
    this._operationExecutions = new Map();
    this._network = this.__wrapNetworkWithLogObserver(config.network);
    this._getDataID = (_config$getDataID = config.getDataID) !== null && _config$getDataID !== void 0 ? _config$getDataID : defaultGetDataID_1;
    this._publishQueue = new RelayPublishQueue_1(config.store, (_config$handlerProvid = config.handlerProvider) !== null && _config$handlerProvid !== void 0 ? _config$handlerProvid : RelayDefaultHandlerProvider_1, this._getDataID);
    this._scheduler = (_config$scheduler = config.scheduler) !== null && _config$scheduler !== void 0 ? _config$scheduler : null;
    this._store = config.store;
    this.options = config.options;
    this._isServer = (_config$isServer = config.isServer) !== null && _config$isServer !== void 0 ? _config$isServer : false;

    this.__setNet = function (newNet) {
      return _this._network = _this.__wrapNetworkWithLogObserver(newNet);
    };

    if (process$1.env.NODE_ENV !== "production") {
      var _require = StoreInspector,
          inspect = _require.inspect;

      this.DEBUG_inspect = function (dataID) {
        return inspect(_this, dataID);
      };
    } // Register this Relay Environment with Relay DevTools if it exists.
    // Note: this must always be the last step in the constructor.


    var _global = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : undefined;

    var devToolsHook = _global && _global.__RELAY_DEVTOOLS_HOOK__;

    if (devToolsHook) {
      devToolsHook.registerEnvironment(this);
    }

    this._missingFieldHandlers = config.missingFieldHandlers;
    this._operationTracker = (_config$operationTrac = config.operationTracker) !== null && _config$operationTrac !== void 0 ? _config$operationTrac : new RelayOperationTracker_1();
    this._reactFlightPayloadDeserializer = reactFlightPayloadDeserializer;
    this._reactFlightServerErrorHandler = reactFlightServerErrorHandler;
    this._shouldProcessClientComponents = config.shouldProcessClientComponents;
  }

  var _proto = RelayModernEnvironment.prototype;

  _proto.getStore = function getStore() {
    return this._store;
  };

  _proto.getNetwork = function getNetwork() {
    return this._network;
  };

  _proto.getOperationTracker = function getOperationTracker() {
    return this._operationTracker;
  };

  _proto.isRequestActive = function isRequestActive(requestIdentifier) {
    var activeState = this._operationExecutions.get(requestIdentifier);

    return activeState === 'active';
  };

  _proto.UNSTABLE_getDefaultRenderPolicy = function UNSTABLE_getDefaultRenderPolicy() {
    return this._defaultRenderPolicy;
  };

  _proto.applyUpdate = function applyUpdate(optimisticUpdate) {
    var _this2 = this;

    var dispose = function dispose() {
      _this2._scheduleUpdates(function () {
        _this2._publishQueue.revertUpdate(optimisticUpdate);

        _this2._publishQueue.run();
      });
    };

    this._scheduleUpdates(function () {
      _this2._publishQueue.applyUpdate(optimisticUpdate);

      _this2._publishQueue.run();
    });

    return {
      dispose: dispose
    };
  };

  _proto.revertUpdate = function revertUpdate(update) {
    var _this3 = this;

    this._scheduleUpdates(function () {
      _this3._publishQueue.revertUpdate(update);

      _this3._publishQueue.run();
    });
  };

  _proto.replaceUpdate = function replaceUpdate(update, newUpdate) {
    var _this4 = this;

    this._scheduleUpdates(function () {
      _this4._publishQueue.revertUpdate(update);

      _this4._publishQueue.applyUpdate(newUpdate);

      _this4._publishQueue.run();
    });
  };

  _proto.applyMutation = function applyMutation(optimisticConfig) {
    var subscription = this._execute({
      createSource: function createSource() {
        return RelayObservable_1.create(function (_sink) {});
      },
      isClientPayload: false,
      operation: optimisticConfig.operation,
      optimisticConfig: optimisticConfig,
      updater: null
    }).subscribe({});

    return {
      dispose: function dispose() {
        return subscription.unsubscribe();
      }
    };
  };

  _proto.check = function check(operation) {
    if (this._missingFieldHandlers == null || this._missingFieldHandlers.length === 0) {
      return this._store.check(operation);
    }

    return this._checkSelectorAndHandleMissingFields(operation, this._missingFieldHandlers);
  };

  _proto.commitPayload = function commitPayload(operation, payload) {
    this._execute({
      createSource: function createSource() {
        return RelayObservable_1.from({
          data: payload
        });
      },
      isClientPayload: true,
      operation: operation,
      optimisticConfig: null,
      updater: null
    }).subscribe({});
  };

  _proto.commitUpdate = function commitUpdate(updater) {
    var _this5 = this;

    this._scheduleUpdates(function () {
      _this5._publishQueue.commitUpdate(updater);

      _this5._publishQueue.run();
    });
  };

  _proto.lookup = function lookup(readSelector) {
    return this._store.lookup(readSelector);
  };

  _proto.subscribe = function subscribe(snapshot, callback) {
    return this._store.subscribe(snapshot, callback);
  };

  _proto.retain = function retain(operation) {
    return this._store.retain(operation);
  };

  _proto.isServer = function isServer() {
    return this._isServer;
  };

  _proto._checkSelectorAndHandleMissingFields = function _checkSelectorAndHandleMissingFields(operation, handlers) {
    var _this6 = this;

    var target = RelayRecordSource_1.create();

    var result = this._store.check(operation, {
      target: target,
      handlers: handlers
    });

    if (target.size() > 0) {
      this._scheduleUpdates(function () {
        _this6._publishQueue.commitSource(target);

        _this6._publishQueue.run();
      });
    }

    return result;
  };

  _proto._scheduleUpdates = function _scheduleUpdates(task) {
    var scheduler = this._scheduler;

    if (scheduler != null) {
      scheduler.schedule(task);
    } else {
      task();
    }
  }
  /**
   * Returns an Observable of GraphQLResponse resulting from executing the
   * provided Query or Subscription operation, each result of which is then
   * normalized and committed to the publish queue.
   *
   * Note: Observables are lazy, so calling this method will do nothing until
   * the result is subscribed to: environment.execute({...}).subscribe({...}).
   */
  ;

  _proto.execute = function execute(_ref) {
    var _this7 = this;

    var operation = _ref.operation,
        updater = _ref.updater;
    return this._execute({
      createSource: function createSource() {
        return _this7._network.execute(operation.request.node.params, operation.request.variables, operation.request.cacheConfig || {}, null);
      },
      isClientPayload: false,
      operation: operation,
      optimisticConfig: null,
      updater: updater
    });
  }
  /**
   * Returns an Observable of GraphQLResponse resulting from executing the
   * provided Mutation operation, the result of which is then normalized and
   * committed to the publish queue along with an optional optimistic response
   * or updater.
   *
   * Note: Observables are lazy, so calling this method will do nothing until
   * the result is subscribed to:
   * environment.executeMutation({...}).subscribe({...}).
   */
  ;

  _proto.executeMutation = function executeMutation(_ref2) {
    var _this8 = this;

    var operation = _ref2.operation,
        optimisticResponse = _ref2.optimisticResponse,
        optimisticUpdater = _ref2.optimisticUpdater,
        updater = _ref2.updater,
        uploadables = _ref2.uploadables;
    var optimisticConfig;

    if (optimisticResponse || optimisticUpdater) {
      optimisticConfig = {
        operation: operation,
        response: optimisticResponse,
        updater: optimisticUpdater
      };
    }

    return this._execute({
      createSource: function createSource() {
        return _this8._network.execute(operation.request.node.params, operation.request.variables, (0, _objectSpread2$5["default"])((0, _objectSpread2$5["default"])({}, operation.request.cacheConfig), {}, {
          force: true
        }), uploadables);
      },
      isClientPayload: false,
      operation: operation,
      optimisticConfig: optimisticConfig,
      updater: updater
    });
  }
  /**
   * Returns an Observable of GraphQLResponse resulting from executing the
   * provided Query or Subscription operation responses, the result of which is
   * then normalized and comitted to the publish queue.
   *
   * Note: Observables are lazy, so calling this method will do nothing until
   * the result is subscribed to:
   * environment.executeWithSource({...}).subscribe({...}).
   */
  ;

  _proto.executeWithSource = function executeWithSource(_ref3) {
    var operation = _ref3.operation,
        source = _ref3.source;
    return this._execute({
      createSource: function createSource() {
        return source;
      },
      isClientPayload: false,
      operation: operation,
      optimisticConfig: null,
      updater: null
    });
  };

  _proto.toJSON = function toJSON() {
    var _this$configName;

    return "RelayModernEnvironment(".concat((_this$configName = this.configName) !== null && _this$configName !== void 0 ? _this$configName : '', ")");
  };

  _proto._execute = function _execute(_ref4) {
    var _this9 = this;

    var createSource = _ref4.createSource,
        isClientPayload = _ref4.isClientPayload,
        operation = _ref4.operation,
        optimisticConfig = _ref4.optimisticConfig,
        updater = _ref4.updater;
    return RelayObservable_1.create(function (sink) {
      var executor = OperationExecutor.execute({
        getDataID: _this9._getDataID,
        isClientPayload: isClientPayload,
        operation: operation,
        operationExecutions: _this9._operationExecutions,
        operationLoader: _this9._operationLoader,
        operationTracker: _this9._operationTracker,
        optimisticConfig: optimisticConfig,
        publishQueue: _this9._publishQueue,
        reactFlightPayloadDeserializer: _this9._reactFlightPayloadDeserializer,
        reactFlightServerErrorHandler: _this9._reactFlightServerErrorHandler,
        scheduler: _this9._scheduler,
        shouldProcessClientComponents: _this9._shouldProcessClientComponents,
        sink: sink,
        // NOTE: Some product tests expect `Network.execute` to be called only
        //       when the Observable is executed.
        source: createSource(),
        store: _this9._store,
        treatMissingFieldsAsNull: _this9._treatMissingFieldsAsNull,
        updater: updater
      });
      return function () {
        return executor.cancel();
      };
    });
  }
  /**
   * Wraps the network with logging to ensure that network requests are
   * always logged. Relying on each network callsite to be wrapped is
   * untenable and will eventually lead to holes in the logging.
   */
  ;

  _proto.__wrapNetworkWithLogObserver = function __wrapNetworkWithLogObserver(network) {
    var that = this;
    return {
      execute: function execute(params, variables, cacheConfig, uploadables) {
        var transactionID = generateID_1();
        var log = that.__log;
        var logObserver = {
          start: function start(subscription) {
            log({
              name: 'network.start',
              transactionID: transactionID,
              params: params,
              variables: variables,
              cacheConfig: cacheConfig
            });
          },
          next: function next(response) {
            log({
              name: 'network.next',
              transactionID: transactionID,
              response: response
            });
          },
          error: function error(_error) {
            log({
              name: 'network.error',
              transactionID: transactionID,
              error: _error
            });
          },
          complete: function complete() {
            log({
              name: 'network.complete',
              transactionID: transactionID
            });
          },
          unsubscribe: function unsubscribe() {
            log({
              name: 'network.unsubscribe',
              transactionID: transactionID
            });
          }
        };

        var logRequestInfo = function logRequestInfo(info) {
          log({
            name: 'network.info',
            transactionID: transactionID,
            info: info
          });
        };

        return network.execute(params, variables, cacheConfig, uploadables, logRequestInfo)["do"](logObserver);
      }
    };
  };

  return RelayModernEnvironment;
}(); // Add a sigil for detection by `isRelayModernEnvironment()` to avoid a
// realm-specific instanceof check, and to aid in module tree-shaking to
// avoid requiring all of RelayRuntime just to detect its environment.


RelayModernEnvironment.prototype['@@RelayModernEnvironment'] = true;

function emptyFunction$1() {}

var RelayModernEnvironment_1 = RelayModernEnvironment;

/**
 * Returns a stable identifier for the given pair of `RequestParameters` +
 * variables.
 */
function getRequestIdentifier(parameters, variables) {
  var requestID = parameters.cacheID != null ? parameters.cacheID : parameters.id;
  !(requestID != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'getRequestIdentifier: Expected request `%s` to have either a ' + 'valid `id` or `cacheID` property', parameters.name) : browser$1(false) : void 0;
  return requestID + JSON.stringify(stableCopy_1(variables));
}

var getRequestIdentifier_1 = getRequestIdentifier;

var getOperationVariables$1 = RelayConcreteVariables.getOperationVariables;

var createNormalizationSelector$3 = RelayModernSelector.createNormalizationSelector,
    createReaderSelector$1 = RelayModernSelector.createReaderSelector;

var ROOT_ID$5 = RelayStoreUtils_1.ROOT_ID;

/**
 * Creates an instance of the `OperationDescriptor` type defined in
 * `RelayStoreTypes` given an operation and some variables. The input variables
 * are filtered to exclude variables that do not match defined arguments on the
 * operation, and default values are populated for null values.
 */
function createOperationDescriptor(request, variables, cacheConfig) {
  var dataID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ROOT_ID$5;
  var operation = request.operation;
  var operationVariables = getOperationVariables$1(operation, variables);
  var requestDescriptor = createRequestDescriptor(request, operationVariables, cacheConfig);
  var operationDescriptor = {
    fragment: createReaderSelector$1(request.fragment, dataID, operationVariables, requestDescriptor),
    request: requestDescriptor,
    root: createNormalizationSelector$3(operation, dataID, operationVariables)
  };

  if (process$1.env.NODE_ENV !== "production") {
    // Freezing properties short-circuits a deepFreeze of snapshots that contain
    // an OperationDescriptor via their selector's owner, avoiding stack
    // overflow on larger queries.
    Object.freeze(operationDescriptor.fragment);
    Object.freeze(operationDescriptor.root);
    Object.freeze(operationDescriptor);
  }

  return operationDescriptor;
}

function createRequestDescriptor(request, variables, cacheConfig) {
  var requestDescriptor = {
    identifier: getRequestIdentifier_1(request.params, variables),
    node: request,
    variables: variables,
    cacheConfig: cacheConfig
  };

  if (process$1.env.NODE_ENV !== "production") {
    deepFreeze_1(variables);
    Object.freeze(request);
    Object.freeze(requestDescriptor);
  }

  return requestDescriptor;
}

var RelayModernOperationDescriptor = {
  createOperationDescriptor: createOperationDescriptor,
  createRequestDescriptor: createRequestDescriptor
};

var LINKED_FIELD$2 = RelayConcreteNode_1.LINKED_FIELD;

var getHandleStorageKey$2 = RelayStoreUtils_1.getHandleStorageKey;

/**
 * @private
 *
 * Creates a clone of the supplied `handleField` by finding the original linked
 * field (on which the handle was declared) among the sibling `selections`, and
 * copying its selections into the clone.
 */
function cloneRelayHandleSourceField(handleField, selections, variables) {
  var sourceField = selections.find(function (source) {
    return source.kind === LINKED_FIELD$2 && source.name === handleField.name && source.alias === handleField.alias && areEqual_1(source.args, handleField.args);
  });
  !(sourceField && sourceField.kind === LINKED_FIELD$2) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'cloneRelayHandleSourceField: Expected a corresponding source field for ' + 'handle `%s`.', handleField.handle) : browser$1(false) : void 0;
  var handleKey = getHandleStorageKey$2(handleField, variables);
  return {
    kind: 'LinkedField',
    alias: sourceField.alias,
    name: handleKey,
    storageKey: handleKey,
    args: null,
    concreteType: sourceField.concreteType,
    plural: sourceField.plural,
    selections: sourceField.selections
  };
}

var cloneRelayHandleSourceField_1 = cloneRelayHandleSourceField;

var SCALAR_FIELD$2 = RelayConcreteNode_1.SCALAR_FIELD;

var getHandleStorageKey$3 = RelayStoreUtils_1.getHandleStorageKey;

/**
 * @private
 *
 * Creates a clone of the supplied `handleField` by finding the original scalar
 * field (on which the handle was declared) among the sibling `selections`.
 */
function cloneRelayScalarHandleSourceField(handleField, selections, variables) {
  var sourceField = selections.find(function (source) {
    return source.kind === SCALAR_FIELD$2 && source.name === handleField.name && source.alias === handleField.alias && areEqual_1(source.args, handleField.args);
  });
  !(sourceField && sourceField.kind === SCALAR_FIELD$2) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'cloneRelayScalarHandleSourceField: Expected a corresponding source field for ' + 'handle `%s`.', handleField.handle) : browser$1(false) : void 0;
  var handleKey = getHandleStorageKey$3(handleField, variables);
  return {
    kind: 'ScalarField',
    alias: sourceField.alias,
    name: handleKey,
    storageKey: handleKey,
    args: null
  };
}

var cloneRelayScalarHandleSourceField_1 = cloneRelayScalarHandleSourceField;

var _createForOfIteratorHelper2$6 = interopRequireDefault(createForOfIteratorHelper);























var isClientID$3 = ClientID.isClientID;

var EXISTENT$3 = RelayRecordState_1.EXISTENT,
    UNKNOWN$1 = RelayRecordState_1.UNKNOWN;

var CONDITION$2 = RelayConcreteNode_1.CONDITION,
    CLIENT_COMPONENT$1 = RelayConcreteNode_1.CLIENT_COMPONENT,
    CLIENT_EXTENSION$2 = RelayConcreteNode_1.CLIENT_EXTENSION,
    DEFER$2 = RelayConcreteNode_1.DEFER,
    FLIGHT_FIELD$2 = RelayConcreteNode_1.FLIGHT_FIELD,
    FRAGMENT_SPREAD$2 = RelayConcreteNode_1.FRAGMENT_SPREAD,
    INLINE_FRAGMENT$2 = RelayConcreteNode_1.INLINE_FRAGMENT,
    LINKED_FIELD$3 = RelayConcreteNode_1.LINKED_FIELD,
    LINKED_HANDLE$1 = RelayConcreteNode_1.LINKED_HANDLE,
    MODULE_IMPORT$2 = RelayConcreteNode_1.MODULE_IMPORT,
    SCALAR_FIELD$3 = RelayConcreteNode_1.SCALAR_FIELD,
    SCALAR_HANDLE$1 = RelayConcreteNode_1.SCALAR_HANDLE,
    STREAM$2 = RelayConcreteNode_1.STREAM,
    TYPE_DISCRIMINATOR$1 = RelayConcreteNode_1.TYPE_DISCRIMINATOR;
var ROOT_ID$6 = RelayStoreUtils_1.ROOT_ID,
    getModuleOperationKey$2 = RelayStoreUtils_1.getModuleOperationKey,
    getStorageKey$5 = RelayStoreUtils_1.getStorageKey,
    getArgumentValues$3 = RelayStoreUtils_1.getArgumentValues;
/**
 * Synchronously check whether the records required to fulfill the given
 * `selector` are present in `source`.
 *
 * If a field is missing, it uses the provided handlers to attempt to substitute
 * data. The `target` will store all records that are modified because of a
 * successful substitution.
 *
 * If all records are present, returns `true`, otherwise `false`.
 */

function check(source, target, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents) {
  var dataID = selector.dataID,
      node = selector.node,
      variables = selector.variables;
  var checker = new DataChecker(source, target, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents);
  return checker.check(node, dataID);
}
/**
 * @private
 */


var DataChecker = /*#__PURE__*/function () {
  function DataChecker(source, target, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents) {
    var mutator = new RelayRecordSourceMutator_1(source, target);
    this._mostRecentlyInvalidatedAt = null;
    this._handlers = handlers;
    this._mutator = mutator;
    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;
    this._recordSourceProxy = new RelayRecordSourceProxy_1(mutator, getDataID);
    this._recordWasMissing = false;
    this._source = source;
    this._variables = variables;
    this._shouldProcessClientComponents = shouldProcessClientComponents;
  }

  var _proto = DataChecker.prototype;

  _proto.check = function check(node, dataID) {
    this._traverse(node, dataID);

    return this._recordWasMissing === true ? {
      status: 'missing',
      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt
    } : {
      status: 'available',
      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt
    };
  };

  _proto._getVariableValue = function _getVariableValue(name) {
    !this._variables.hasOwnProperty(name) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : browser$1(false) : void 0; // $FlowFixMe[cannot-write]

    return this._variables[name];
  };

  _proto._handleMissing = function _handleMissing() {
    this._recordWasMissing = true;
  };

  _proto._getDataForHandlers = function _getDataForHandlers(field, dataID) {
    return {
      args: field.args ? getArgumentValues$3(field.args, this._variables) : {},
      // Getting a snapshot of the record state is potentially expensive since
      // we will need to merge the sink and source records. Since we do not create
      // any new records in this process, it is probably reasonable to provide
      // handlers with a copy of the source record.
      // The only thing that the provided record will not contain is fields
      // added by previous handlers.
      record: this._source.get(dataID)
    };
  };

  _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {
    if (field.name === 'id' && field.alias == null && isClientID$3(dataID)) {
      return undefined;
    }

    var _this$_getDataForHand = this._getDataForHandlers(field, dataID),
        args = _this$_getDataForHand.args,
        record = _this$_getDataForHand.record;

    var _iterator = (0, _createForOfIteratorHelper2$6["default"])(this._handlers),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var handler = _step.value;

        if (handler.kind === 'scalar') {
          var newValue = handler.handle(field, record, args, this._recordSourceProxy);

          if (newValue !== undefined) {
            return newValue;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this._handleMissing();
  };

  _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {
    var _this$_getDataForHand2 = this._getDataForHandlers(field, dataID),
        args = _this$_getDataForHand2.args,
        record = _this$_getDataForHand2.record;

    var _iterator2 = (0, _createForOfIteratorHelper2$6["default"])(this._handlers),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var handler = _step2.value;

        if (handler.kind === 'linked') {
          var newValue = handler.handle(field, record, args, this._recordSourceProxy);

          if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT$3)) {
            return newValue;
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    this._handleMissing();
  };

  _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {
    var _this = this;

    var _this$_getDataForHand3 = this._getDataForHandlers(field, dataID),
        args = _this$_getDataForHand3.args,
        record = _this$_getDataForHand3.record;

    var _iterator3 = (0, _createForOfIteratorHelper2$6["default"])(this._handlers),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var handler = _step3.value;

        if (handler.kind === 'pluralLinked') {
          var newValue = handler.handle(field, record, args, this._recordSourceProxy);

          if (newValue != null) {
            var allItemsKnown = newValue.every(function (linkedID) {
              return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT$3;
            });

            if (allItemsKnown) {
              return newValue;
            }
          } else if (newValue === null) {
            return null;
          }
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    this._handleMissing();
  };

  _proto._traverse = function _traverse(node, dataID) {
    var status = this._mutator.getStatus(dataID);

    if (status === UNKNOWN$1) {
      this._handleMissing();
    }

    if (status === EXISTENT$3) {
      var record = this._source.get(dataID);

      var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);

      if (invalidatedAt != null) {
        this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;
      }

      this._traverseSelections(node.selections, dataID);
    }
  };

  _proto._traverseSelections = function _traverseSelections(selections, dataID) {
    var _this2 = this;

    selections.forEach(function (selection) {
      switch (selection.kind) {
        case SCALAR_FIELD$3:
          _this2._checkScalar(selection, dataID);

          break;

        case LINKED_FIELD$3:
          if (selection.plural) {
            _this2._checkPluralLink(selection, dataID);
          } else {
            _this2._checkLink(selection, dataID);
          }

          break;

        case CONDITION$2:
          var conditionValue = _this2._getVariableValue(selection.condition);

          if (conditionValue === selection.passingValue) {
            _this2._traverseSelections(selection.selections, dataID);
          }

          break;

        case INLINE_FRAGMENT$2:
          {
            var abstractKey = selection.abstractKey;

            if (abstractKey == null) {
              // concrete type refinement: only check data if the type exactly matches
              var typeName = _this2._mutator.getType(dataID);

              if (typeName === selection.type) {
                _this2._traverseSelections(selection.selections, dataID);
              }
            } else {
              // legacy behavior for abstract refinements: always check even
              // if the type doesn't conform
              _this2._traverseSelections(selection.selections, dataID);
            }

            break;
          }

        case LINKED_HANDLE$1:
          {
            // Handles have no selections themselves; traverse the original field
            // where the handle was set-up instead.
            var handleField = cloneRelayHandleSourceField_1(selection, selections, _this2._variables);

            if (handleField.plural) {
              _this2._checkPluralLink(handleField, dataID);
            } else {
              _this2._checkLink(handleField, dataID);
            }

            break;
          }

        case SCALAR_HANDLE$1:
          {
            var _handleField = cloneRelayScalarHandleSourceField_1(selection, selections, _this2._variables);

            _this2._checkScalar(_handleField, dataID);

            break;
          }

        case MODULE_IMPORT$2:
          _this2._checkModuleImport(selection, dataID);

          break;

        case DEFER$2:
        case STREAM$2:
          _this2._traverseSelections(selection.selections, dataID);

          break;
        // $FlowFixMe[incompatible-type]

        case FRAGMENT_SPREAD$2:
          _this2._traverseSelections(selection.fragment.selections, dataID);

          break;

        case CLIENT_EXTENSION$2:
          var recordWasMissing = _this2._recordWasMissing;

          _this2._traverseSelections(selection.selections, dataID);

          _this2._recordWasMissing = recordWasMissing;
          break;

        case TYPE_DISCRIMINATOR$1:

          break;

        case FLIGHT_FIELD$2:
          {
            throw new Error('Flight fields are not yet supported.');
          }

        case CLIENT_COMPONENT$1:
          if (_this2._shouldProcessClientComponents === false) {
            break;
          }

          _this2._traverseSelections(selection.fragment.selections, dataID);

          break;

        default:
           process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : browser$1(false) ;
      }
    });
  };

  _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {
    var operationLoader = this._operationLoader;
    !(operationLoader !== null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : browser$1(false) : void 0;
    var operationKey = getModuleOperationKey$2(moduleImport.documentName);

    var operationReference = this._mutator.getValue(dataID, operationKey);

    if (operationReference == null) {
      if (operationReference === undefined) {
        this._handleMissing();
      }

      return;
    }

    var normalizationRootNode = operationLoader.get(operationReference);

    if (normalizationRootNode != null) {
      var operation = getOperation_1(normalizationRootNode);

      this._traverse(operation, dataID);
    } else {
      // If the fragment is not available, we assume that the data cannot have been
      // processed yet and must therefore be missing.
      this._handleMissing();
    }
  };

  _proto._checkScalar = function _checkScalar(field, dataID) {
    var storageKey = getStorageKey$5(field, this._variables);

    var fieldValue = this._mutator.getValue(dataID, storageKey);

    if (fieldValue === undefined) {
      fieldValue = this._handleMissingScalarField(field, dataID);

      if (fieldValue !== undefined) {
        this._mutator.setValue(dataID, storageKey, fieldValue);
      }
    }
  };

  _proto._checkLink = function _checkLink(field, dataID) {
    var storageKey = getStorageKey$5(field, this._variables);

    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);

    if (linkedID === undefined) {
      linkedID = this._handleMissingLinkField(field, dataID);

      if (linkedID != null) {
        this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);
      } else if (linkedID === null) {
        this._mutator.setValue(dataID, storageKey, null);
      }
    }

    if (linkedID != null) {
      this._traverse(field, linkedID);
    }
  };

  _proto._checkPluralLink = function _checkPluralLink(field, dataID) {
    var _this3 = this;

    var storageKey = getStorageKey$5(field, this._variables);

    var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);

    if (linkedIDs === undefined) {
      linkedIDs = this._handleMissingPluralLinkField(field, dataID);

      if (linkedIDs != null) {
        this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);
      } else if (linkedIDs === null) {
        this._mutator.setValue(dataID, storageKey, null);
      }
    }

    if (linkedIDs) {
      linkedIDs.forEach(function (linkedID) {
        if (linkedID != null) {
          _this3._traverse(field, linkedID);
        }
      });
    }
  };

  _proto._checkFlightField = function _checkFlightField(field, dataID) {
    var storageKey = getStorageKey$5(field, this._variables);

    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);

    if (linkedID == null) {
      if (linkedID === undefined) {
        this._handleMissing();

        return;
      }

      return;
    }

    var tree = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_TREE_STORAGE_KEY);

    var reachableExecutableDefinitions = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY);

    if (tree == null || !Array.isArray(reachableExecutableDefinitions)) {
      this._handleMissing();

      return;
    }

    var operationLoader = this._operationLoader;
    !(operationLoader !== null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'DataChecker: Expected an operationLoader to be configured when using ' + 'React Flight.') : browser$1(false) : void 0; // In Flight, the variables that are in scope for reachable executable
    // definitions aren't the same as what's in scope for the outer query.

    var prevVariables = this._variables; // $FlowFixMe[incompatible-cast]

    var _iterator4 = (0, _createForOfIteratorHelper2$6["default"])(reachableExecutableDefinitions),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var definition = _step4.value;
        this._variables = definition.variables;
        var normalizationRootNode = operationLoader.get(definition.module);

        if (normalizationRootNode != null) {
          var operation = getOperation_1(normalizationRootNode);

          this._traverseSelections(operation.selections, ROOT_ID$6);
        } else {
          // If the fragment is not available, we assume that the data cannot have
          // been processed yet and must therefore be missing.
          this._handleMissing();
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    this._variables = prevVariables;
  };

  return DataChecker;
}();

var DataChecker_1 = {
  check: check
};

var _objectSpread2$6 = interopRequireDefault(objectSpread2);



var UNPUBLISH_RECORD_SENTINEL = Object.freeze({
  __UNPUBLISH_RECORD_SENTINEL: true
});
/**
 * An implementation of MutableRecordSource that represents a base RecordSource
 * with optimistic updates stacked on top: records with optimistic updates
 * shadow the base version of the record rather than updating/replacing them.
 */

var RelayOptimisticRecordSource = /*#__PURE__*/function () {
  function RelayOptimisticRecordSource(base) {
    this._base = base;
    this._sink = RelayRecordSource_1.create();
  }

  var _proto = RelayOptimisticRecordSource.prototype;

  _proto.has = function has(dataID) {
    if (this._sink.has(dataID)) {
      var sinkRecord = this._sink.get(dataID);

      return sinkRecord !== UNPUBLISH_RECORD_SENTINEL;
    } else {
      return this._base.has(dataID);
    }
  };

  _proto.get = function get(dataID) {
    if (this._sink.has(dataID)) {
      var sinkRecord = this._sink.get(dataID);

      if (sinkRecord === UNPUBLISH_RECORD_SENTINEL) {
        return undefined;
      } else {
        return sinkRecord;
      }
    } else {
      return this._base.get(dataID);
    }
  };

  _proto.getStatus = function getStatus(dataID) {
    var record = this.get(dataID);

    if (record === undefined) {
      return 'UNKNOWN';
    } else if (record === null) {
      return 'NONEXISTENT';
    } else {
      return 'EXISTENT';
    }
  };

  _proto.clear = function clear() {
    this._base = RelayRecordSource_1.create();

    this._sink.clear();
  };

  _proto["delete"] = function _delete(dataID) {
    this._sink["delete"](dataID);
  };

  _proto.remove = function remove(dataID) {
    this._sink.set(dataID, UNPUBLISH_RECORD_SENTINEL);
  };

  _proto.set = function set(dataID, record) {
    this._sink.set(dataID, record);
  };

  _proto.getRecordIDs = function getRecordIDs() {
    return Object.keys(this.toJSON());
  };

  _proto.size = function size() {
    return Object.keys(this.toJSON()).length;
  };

  _proto.toJSON = function toJSON() {
    var _this = this;

    var merged = (0, _objectSpread2$6["default"])({}, this._base.toJSON());

    this._sink.getRecordIDs().forEach(function (dataID) {
      var record = _this.get(dataID);

      if (record === undefined) {
        delete merged[dataID];
      } else {
        merged[dataID] = record;
      }
    });

    return merged;
  };

  return RelayOptimisticRecordSource;
}();

function create$1(base) {
  return new RelayOptimisticRecordSource(base);
}

var RelayOptimisticRecordSource_1 = {
  create: create$1
};

var _createForOfIteratorHelper2$7 = interopRequireDefault(createForOfIteratorHelper);

var CONDITION$3 = RelayConcreteNode_1.CONDITION,
    CLIENT_COMPONENT$2 = RelayConcreteNode_1.CLIENT_COMPONENT,
    CLIENT_EXTENSION$3 = RelayConcreteNode_1.CLIENT_EXTENSION,
    DEFER$3 = RelayConcreteNode_1.DEFER,
    FLIGHT_FIELD$3 = RelayConcreteNode_1.FLIGHT_FIELD,
    FRAGMENT_SPREAD$3 = RelayConcreteNode_1.FRAGMENT_SPREAD,
    INLINE_FRAGMENT$3 = RelayConcreteNode_1.INLINE_FRAGMENT,
    LINKED_FIELD$4 = RelayConcreteNode_1.LINKED_FIELD,
    MODULE_IMPORT$3 = RelayConcreteNode_1.MODULE_IMPORT,
    LINKED_HANDLE$2 = RelayConcreteNode_1.LINKED_HANDLE,
    SCALAR_FIELD$4 = RelayConcreteNode_1.SCALAR_FIELD,
    SCALAR_HANDLE$2 = RelayConcreteNode_1.SCALAR_HANDLE,
    STREAM$3 = RelayConcreteNode_1.STREAM,
    TYPE_DISCRIMINATOR$2 = RelayConcreteNode_1.TYPE_DISCRIMINATOR;
var ROOT_ID$7 = RelayStoreUtils_1.ROOT_ID,
    getStorageKey$6 = RelayStoreUtils_1.getStorageKey,
    getModuleOperationKey$3 = RelayStoreUtils_1.getModuleOperationKey;

function mark(recordSource, selector, references, operationLoader, shouldProcessClientComponents) {
  var dataID = selector.dataID,
      node = selector.node,
      variables = selector.variables;
  var marker = new RelayReferenceMarker(recordSource, variables, references, operationLoader, shouldProcessClientComponents);
  marker.mark(node, dataID);
}
/**
 * @private
 */


var RelayReferenceMarker = /*#__PURE__*/function () {
  function RelayReferenceMarker(recordSource, variables, references, operationLoader, shouldProcessClientComponents) {
    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;
    this._operationName = null;
    this._recordSource = recordSource;
    this._references = references;
    this._variables = variables;
    this._shouldProcessClientComponents = shouldProcessClientComponents;
  }

  var _proto = RelayReferenceMarker.prototype;

  _proto.mark = function mark(node, dataID) {
    if (node.kind === 'Operation' || node.kind === 'SplitOperation') {
      this._operationName = node.name;
    }

    this._traverse(node, dataID);
  };

  _proto._traverse = function _traverse(node, dataID) {
    this._references.add(dataID);

    var record = this._recordSource.get(dataID);

    if (record == null) {
      return;
    }

    this._traverseSelections(node.selections, record);
  };

  _proto._getVariableValue = function _getVariableValue(name) {
    !this._variables.hasOwnProperty(name) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReferenceMarker(): Undefined variable `%s`.', name) : browser$1(false) : void 0; // $FlowFixMe[cannot-write]

    return this._variables[name];
  };

  _proto._traverseSelections = function _traverseSelections(selections, record) {
    var _this = this;

    selections.forEach(function (selection) {
      /* eslint-disable no-fallthrough */
      switch (selection.kind) {
        case LINKED_FIELD$4:
          if (selection.plural) {
            _this._traversePluralLink(selection, record);
          } else {
            _this._traverseLink(selection, record);
          }

          break;

        case CONDITION$3:
          var conditionValue = _this._getVariableValue(selection.condition);

          if (conditionValue === selection.passingValue) {
            _this._traverseSelections(selection.selections, record);
          }

          break;

        case INLINE_FRAGMENT$3:
          if (selection.abstractKey == null) {
            var typeName = RelayModernRecord.getType(record);

            if (typeName != null && typeName === selection.type) {
              _this._traverseSelections(selection.selections, record);
            }
          } else {
            _this._traverseSelections(selection.selections, record);
          }

          break;
        // $FlowFixMe[incompatible-type]

        case FRAGMENT_SPREAD$3:
          _this._traverseSelections(selection.fragment.selections, record);

          break;

        case LINKED_HANDLE$2:
          // The selections for a "handle" field are the same as those of the
          // original linked field where the handle was applied. Reference marking
          // therefore requires traversing the original field selections against
          // the synthesized client field.
          //
          // TODO: Instead of finding the source field in `selections`, change
          // the concrete structure to allow shared subtrees, and have the linked
          // handle directly refer to the same selections as the LinkedField that
          // it was split from.
          var handleField = cloneRelayHandleSourceField_1(selection, selections, _this._variables);

          if (handleField.plural) {
            _this._traversePluralLink(handleField, record);
          } else {
            _this._traverseLink(handleField, record);
          }

          break;

        case DEFER$3:
        case STREAM$3:
          _this._traverseSelections(selection.selections, record);

          break;

        case SCALAR_FIELD$4:
        case SCALAR_HANDLE$2:
          break;

        case TYPE_DISCRIMINATOR$2:
          {

            break;
          }

        case MODULE_IMPORT$3:
          _this._traverseModuleImport(selection, record);

          break;

        case CLIENT_EXTENSION$3:
          _this._traverseSelections(selection.selections, record);

          break;

        case FLIGHT_FIELD$3:
          {
            throw new Error('Flight fields are not yet supported.');
          }

        case CLIENT_COMPONENT$2:
          if (_this._shouldProcessClientComponents === false) {
            break;
          }

          _this._traverseSelections(selection.fragment.selections, record);

          break;

        default:
           process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReferenceMarker: Unknown AST node `%s`.', selection) : browser$1(false) ;
      }
    });
  };

  _proto._traverseModuleImport = function _traverseModuleImport(moduleImport, record) {
    var _this$_operationName;

    var operationLoader = this._operationLoader;
    !(operationLoader !== null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReferenceMarker: Expected an operationLoader to be configured when using `@module`. ' + 'Could not load fragment `%s` in operation `%s`.', moduleImport.fragmentName, (_this$_operationName = this._operationName) !== null && _this$_operationName !== void 0 ? _this$_operationName : '(unknown)') : browser$1(false) : void 0;
    var operationKey = getModuleOperationKey$3(moduleImport.documentName);
    var operationReference = RelayModernRecord.getValue(record, operationKey);

    if (operationReference == null) {
      return;
    }

    var normalizationRootNode = operationLoader.get(operationReference);

    if (normalizationRootNode != null) {
      var selections = getOperation_1(normalizationRootNode).selections;

      this._traverseSelections(selections, record);
    } // Otherwise, if the operation is not available, we assume that the data
    // cannot have been processed yet and therefore isn't in the store to
    // begin with.

  };

  _proto._traverseLink = function _traverseLink(field, record) {
    var storageKey = getStorageKey$6(field, this._variables);
    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);

    if (linkedID == null) {
      return;
    }

    this._traverse(field, linkedID);
  };

  _proto._traversePluralLink = function _traversePluralLink(field, record) {
    var _this2 = this;

    var storageKey = getStorageKey$6(field, this._variables);
    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);

    if (linkedIDs == null) {
      return;
    }

    linkedIDs.forEach(function (linkedID) {
      if (linkedID != null) {
        _this2._traverse(field, linkedID);
      }
    });
  };

  _proto._traverseFlightField = function _traverseFlightField(field, record) {
    var storageKey = getStorageKey$6(field, this._variables);
    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);

    if (linkedID == null) {
      return;
    }

    this._references.add(linkedID);

    var reactFlightClientResponseRecord = this._recordSource.get(linkedID);

    if (reactFlightClientResponseRecord == null) {
      return;
    }

    var reachableExecutableDefinitions = RelayModernRecord.getValue(reactFlightClientResponseRecord, RelayStoreReactFlightUtils.REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY);

    if (!Array.isArray(reachableExecutableDefinitions)) {
      return;
    }

    var operationLoader = this._operationLoader;
    !(operationLoader !== null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'DataChecker: Expected an operationLoader to be configured when using ' + 'React Flight') : browser$1(false) : void 0; // In Flight, the variables that are in scope for reachable executable
    // definitions aren't the same as what's in scope for the outer query.

    var prevVariables = this._variables; // $FlowFixMe[incompatible-cast]

    var _iterator = (0, _createForOfIteratorHelper2$7["default"])(reachableExecutableDefinitions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var definition = _step.value;
        this._variables = definition.variables;
        var operationReference = definition.module;
        var normalizationRootNode = operationLoader.get(operationReference);

        if (normalizationRootNode != null) {
          var operation = getOperation_1(normalizationRootNode);

          this._traverse(operation, ROOT_ID$7);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this._variables = prevVariables;
  };

  return RelayReferenceMarker;
}();

var RelayReferenceMarker_1 = {
  mark: mark
};

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var ITERATOR_KEY = Symbol.iterator;

function hasOverlappingIDs(seenRecords, updatedRecordIDs) {
  // $FlowFixMe: Set is an iterable type, accessing its iterator is allowed.
  var iterator = seenRecords[ITERATOR_KEY]();
  var next = iterator.next();

  while (!next.done) {
    var key = next.value;

    if (updatedRecordIDs.has(key)) {
      return true;
    }

    next = iterator.next();
  }

  return false;
}

var hasOverlappingIDs_1 = hasOverlappingIDs;

var hasWeakSetDefined = typeof WeakSet !== 'undefined';
var hasWeakMapDefined = typeof WeakMap !== 'undefined';
/**
 * Recycles subtrees from `prevData` by replacing equal subtrees in `nextData`.
 */

function recycleNodesInto(prevData, nextData) {
  if (prevData === nextData || typeof prevData !== 'object' || prevData instanceof Set || prevData instanceof Map || hasWeakSetDefined && prevData instanceof WeakSet || hasWeakMapDefined && prevData instanceof WeakMap || !prevData || typeof nextData !== 'object' || nextData instanceof Set || nextData instanceof Map || hasWeakSetDefined && nextData instanceof WeakSet || hasWeakMapDefined && nextData instanceof WeakMap || !nextData) {
    return nextData;
  }

  var canRecycle = false; // Assign local variables to preserve Flow type refinement.

  var prevArray = Array.isArray(prevData) ? prevData : null;
  var nextArray = Array.isArray(nextData) ? nextData : null;

  if (prevArray && nextArray) {
    canRecycle = nextArray.reduce(function (wasEqual, nextItem, ii) {
      var prevValue = prevArray[ii];
      var nextValue = recycleNodesInto(prevValue, nextItem);

      if (nextValue !== nextArray[ii]) {
        if (process$1.env.NODE_ENV !== "production") {
          if (!Object.isFrozen(nextArray)) {
            nextArray[ii] = nextValue;
          }
        } else {
          nextArray[ii] = nextValue;
        }
      }

      return wasEqual && nextValue === prevArray[ii];
    }, true) && prevArray.length === nextArray.length;
  } else if (!prevArray && !nextArray) {
    // Assign local variables to preserve Flow type refinement.
    var prevObject = prevData;
    var nextObject = nextData;
    var prevKeys = Object.keys(prevObject);
    var nextKeys = Object.keys(nextObject);
    canRecycle = nextKeys.reduce(function (wasEqual, key) {
      var prevValue = prevObject[key];
      var nextValue = recycleNodesInto(prevValue, nextObject[key]);

      if (nextValue !== nextObject[key]) {
        if (process$1.env.NODE_ENV !== "production") {
          if (!Object.isFrozen(nextObject)) {
            // $FlowFixMe[cannot-write]
            nextObject[key] = nextValue;
          }
        } else {
          // $FlowFixMe[cannot-write]
          nextObject[key] = nextValue;
        }
      }

      return wasEqual && nextValue === prevObject[key];
    }, true) && prevKeys.length === nextKeys.length;
  }

  return canRecycle ? prevData : nextData;
}

var recycleNodesInto_1 = recycleNodesInto;

var RelayStoreSubscriptions = /*#__PURE__*/function () {
  function RelayStoreSubscriptions(log) {
    this._subscriptions = new Set();
    this.__log = log;
  }

  var _proto = RelayStoreSubscriptions.prototype;

  _proto.subscribe = function subscribe(snapshot, callback) {
    var _this = this;

    var subscription = {
      backup: null,
      callback: callback,
      snapshot: snapshot,
      stale: false
    };

    var dispose = function dispose() {
      _this._subscriptions["delete"](subscription);
    };

    this._subscriptions.add(subscription);

    return {
      dispose: dispose
    };
  };

  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {
    this._subscriptions.forEach(function (subscription) {
      // Backup occurs after writing a new "final" payload(s) and before (re)applying
      // optimistic changes. Each subscription's `snapshot` represents what was *last
      // published to the subscriber*, which notably may include previous optimistic
      // updates. Therefore a subscription can be in any of the following states:
      // - stale=true: This subscription was restored to a different value than
      //   `snapshot`. That means this subscription has changes relative to its base,
      //   but its base has changed (we just applied a final payload): recompute
      //   a backup so that we can later restore to the state the subscription
      //   should be in.
      // - stale=false: This subscription was restored to the same value as
      //   `snapshot`. That means this subscription does *not* have changes relative
      //   to its base, so the current `snapshot` is valid to use as a backup.
      if (!subscription.stale) {
        subscription.backup = subscription.snapshot;
        return;
      }

      var snapshot = subscription.snapshot;
      var backup = RelayReader_1.read(source, snapshot.selector);
      var nextData = recycleNodesInto_1(snapshot.data, backup.data);
      backup.data = nextData; // backup owns the snapshot and can safely mutate

      subscription.backup = backup;
    });
  };

  _proto.restoreSubscriptions = function restoreSubscriptions() {
    this._subscriptions.forEach(function (subscription) {
      var backup = subscription.backup;
      subscription.backup = null;

      if (backup) {
        if (backup.data !== subscription.snapshot.data) {
          subscription.stale = true;
        }

        subscription.snapshot = {
          data: subscription.snapshot.data,
          isMissingData: backup.isMissingData,
          seenRecords: backup.seenRecords,
          selector: backup.selector,
          missingRequiredFields: backup.missingRequiredFields
        };
      } else {
        subscription.stale = true;
      }
    });
  };

  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {
    var _this2 = this;

    var hasUpdatedRecords = updatedRecordIDs.size !== 0;

    this._subscriptions.forEach(function (subscription) {
      var owner = _this2._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);

      if (owner != null) {
        updatedOwners.push(owner);
      }
    });
  }
  /**
   * Notifies the callback for the subscription if the data for the associated
   * snapshot has changed.
   * Additionally, updates the subscription snapshot with the latest snapshot,
   * and marks it as not stale.
   * Returns the owner (RequestDescriptor) if the subscription was affected by the
   * latest update, or null if it was not affected.
   */
  ;

  _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {
    var backup = subscription.backup,
        callback = subscription.callback,
        snapshot = subscription.snapshot,
        stale = subscription.stale;
    var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs_1(snapshot.seenRecords, updatedRecordIDs);

    if (!stale && !hasOverlappingUpdates) {
      return;
    }

    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader_1.read(source, snapshot.selector) : backup;
    var nextData = recycleNodesInto_1(snapshot.data, nextSnapshot.data);
    nextSnapshot = {
      data: nextData,
      isMissingData: nextSnapshot.isMissingData,
      seenRecords: nextSnapshot.seenRecords,
      selector: nextSnapshot.selector,
      missingRequiredFields: nextSnapshot.missingRequiredFields
    };

    if (process$1.env.NODE_ENV !== "production") {
      deepFreeze_1(nextSnapshot);
    }

    subscription.snapshot = nextSnapshot;
    subscription.stale = false;

    if (nextSnapshot.data !== snapshot.data) {
      if (this.__log && RelayFeatureFlags_1.ENABLE_NOTIFY_SUBSCRIPTION) {
        this.__log({
          name: 'store.notify.subscription',
          sourceOperation: sourceOperation,
          snapshot: snapshot,
          nextSnapshot: nextSnapshot
        });
      }

      callback(nextSnapshot);
      return snapshot.selector.owner;
    }
  };

  return RelayStoreSubscriptions;
}();

var RelayStoreSubscriptions_1 = RelayStoreSubscriptions;

var _createForOfIteratorHelper2$8 = interopRequireDefault(createForOfIteratorHelper);

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var resolvedPromise = Promise.resolve();
/**
 * An alternative to setImmediate based on Promise.
 */

function resolveImmediate(callback) {
  resolvedPromise.then(callback)["catch"](throwNext);
}

function throwNext(error) {
  setTimeout(function () {
    throw error;
  }, 0);
}

var resolveImmediate_1 = resolveImmediate;

var _createForOfIteratorHelper2$9 = interopRequireDefault(createForOfIteratorHelper);

var _defineProperty2$1 = interopRequireDefault(defineProperty);





























var _require = RelayStoreUtils_1,
    ROOT_ID$8 = _require.ROOT_ID,
    ROOT_TYPE$4 = _require.ROOT_TYPE;

var DEFAULT_RELEASE_BUFFER_SIZE = 10;
/**
 * @public
 *
 * An implementation of the `Store` interface defined in `RelayStoreTypes`.
 *
 * Note that a Store takes ownership of all records provided to it: other
 * objects may continue to hold a reference to such records but may not mutate
 * them. The static Relay core is architected to avoid mutating records that may have been
 * passed to a store: operations that mutate records will either create fresh
 * records or clone existing records and modify the clones. Record immutability
 * is also enforced in development mode by freezing all records passed to a store.
 */

var RelayModernStore = /*#__PURE__*/function () {
  function RelayModernStore(source, options) {
    var _this = this;

    var _options$gcReleaseBuf, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa;

    (0, _defineProperty2$1["default"])(this, "_gcStep", function () {
      if (_this._gcRun) {
        if (_this._gcRun.next().done) {
          _this._gcRun = null;
        } else {
          _this._gcScheduler(_this._gcStep);
        }
      }
    });

    // Prevent mutation of a record from outside the store.
    if (process$1.env.NODE_ENV !== "production") {
      var storeIDs = source.getRecordIDs();

      for (var ii = 0; ii < storeIDs.length; ii++) {
        var record = source.get(storeIDs[ii]);

        if (record) {
          RelayModernRecord.freeze(record);
        }
      }
    }

    this._currentWriteEpoch = 0;
    this._gcHoldCounter = 0;
    this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;
    this._gcRun = null;
    this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate_1;
    this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID_1;
    this._globalInvalidationEpoch = null;
    this._invalidationSubscriptions = new Set();
    this._invalidatedRecordIDs = new Set();
    this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;
    this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;
    this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;
    this._optimisticSource = null;
    this._recordSource = source;
    this._releaseBuffer = [];
    this._roots = new Map();
    this._shouldScheduleGC = false;
    this._storeSubscriptions =  new RelayStoreSubscriptions_1(options === null || options === void 0 ? void 0 : options.log);
    this._updatedRecordIDs = new Set();
    this._shouldProcessClientComponents = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents;
    initializeRecordSource(this._recordSource);
  }

  var _proto = RelayModernStore.prototype;

  _proto.getSource = function getSource() {
    var _this$_optimisticSour;

    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;
  };

  _proto.check = function check(operation, options) {
    var _this$_optimisticSour2, _options$target, _options$handlers;

    var selector = operation.root;
    var source = (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;
    var globalInvalidationEpoch = this._globalInvalidationEpoch;

    var rootEntry = this._roots.get(operation.request.identifier);

    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated

    if (globalInvalidationEpoch != null) {
      // If so, check if the operation we're checking was last written
      // before or after invalidation occured.
      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {
        // If the operation was written /before/ global invalidation occurred,
        // or if this operation has never been written to the store before,
        // we will consider the data for this operation to be stale
        // (i.e. not resolvable from the store).
        return {
          status: 'stale'
        };
      }
    }

    var target = (_options$target = options === null || options === void 0 ? void 0 : options.target) !== null && _options$target !== void 0 ? _options$target : source;
    var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];
    var operationAvailability = DataChecker_1.check(source, target, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents);
    return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);
  };

  _proto.retain = function retain(operation) {
    var _this2 = this;

    var id = operation.request.identifier;
    var disposed = false;

    var dispose = function dispose() {
      // Ensure each retain can only dispose once
      if (disposed) {
        return;
      }

      disposed = true; // For Flow: guard against the entry somehow not existing

      var rootEntry = _this2._roots.get(id);

      if (rootEntry == null) {
        return;
      } // Decrement the ref count: if it becomes zero it is eligible
      // for release.


      rootEntry.refCount--;

      if (rootEntry.refCount === 0) {
        var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;

        var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;

        if (rootEntryIsStale) {
          _this2._roots["delete"](id);

          _this2.scheduleGC();
        } else {
          _this2._releaseBuffer.push(id); // If the release buffer is now over-full, remove the least-recently
          // added entry and schedule a GC. Note that all items in the release
          // buffer have a refCount of 0.


          if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {
            var _id = _this2._releaseBuffer.shift();

            _this2._roots["delete"](_id);

            _this2.scheduleGC();
          }
        }
      }
    };

    var rootEntry = this._roots.get(id);

    if (rootEntry != null) {
      if (rootEntry.refCount === 0) {
        // This entry should be in the release buffer, but it no longer belongs
        // there since it's retained. Remove it to maintain the invariant that
        // all release buffer entries have a refCount of 0.
        this._releaseBuffer = this._releaseBuffer.filter(function (_id) {
          return _id !== id;
        });
      } // If we've previously retained this operation, increment the refCount


      rootEntry.refCount += 1;
    } else {
      // Otherwise create a new entry for the operation
      this._roots.set(id, {
        operation: operation,
        refCount: 1,
        epoch: null,
        fetchTime: null
      });
    }

    return {
      dispose: dispose
    };
  };

  _proto.lookup = function lookup(selector) {
    var source = this.getSource();
    var snapshot = RelayReader_1.read(source, selector);

    if (process$1.env.NODE_ENV !== "production") {
      deepFreeze_1(snapshot);
    }

    return snapshot;
  } // This method will return a list of updated owners from the subscriptions
  ;

  _proto.notify = function notify(sourceOperation, invalidateStore) {
    var _this3 = this;

    var log = this.__log;

    if (log != null) {
      log({
        name: 'store.notify.start',
        sourceOperation: sourceOperation
      });
    } // Increment the current write when notifying after executing
    // a set of changes to the store.


    this._currentWriteEpoch++;

    if (invalidateStore === true) {
      this._globalInvalidationEpoch = this._currentWriteEpoch;
    }

    var source = this.getSource();
    var updatedOwners = [];

    this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);

    this._invalidationSubscriptions.forEach(function (subscription) {
      _this3._updateInvalidationSubscription(subscription, invalidateStore === true);
    });

    if (log != null) {
      log({
        name: 'store.notify.complete',
        sourceOperation: sourceOperation,
        updatedRecordIDs: this._updatedRecordIDs,
        invalidatedRecordIDs: this._invalidatedRecordIDs
      });
    }

    this._updatedRecordIDs.clear();

    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation
    // that produced this update to the store), record the current epoch
    // at which this operation was written.


    if (sourceOperation != null) {
      // We only track the epoch at which the operation was written if
      // it was previously retained, to keep the size of our operation
      // epoch map bounded. If a query wasn't retained, we assume it can
      // may be deleted at any moment and thus is not relevant for us to track
      // for the purposes of invalidation.
      var id = sourceOperation.request.identifier;

      var rootEntry = this._roots.get(id);

      if (rootEntry != null) {
        rootEntry.epoch = this._currentWriteEpoch;
        rootEntry.fetchTime = Date.now();
      } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {
        // The operation isn't retained but there is space in the release buffer:
        // temporarily track this operation in case the data can be reused soon.
        var temporaryRootEntry = {
          operation: sourceOperation,
          refCount: 0,
          epoch: this._currentWriteEpoch,
          fetchTime: Date.now()
        };

        this._releaseBuffer.push(id);

        this._roots.set(id, temporaryRootEntry);
      }
    }

    return updatedOwners;
  };

  _proto.publish = function publish(source, idsMarkedForInvalidation) {
    var _this$_optimisticSour3;

    var target = (_this$_optimisticSour3 = this._optimisticSource) !== null && _this$_optimisticSour3 !== void 0 ? _this$_optimisticSour3 : this._recordSource;
    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,
    // in notify(). Here, we pass what will be the incremented value of
    // the epoch to use to write to invalidated records.
    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs); // NOTE: log *after* processing the source so that even if a bad log function
    // mutates the source, it doesn't affect Relay processing of it.

    var log = this.__log;

    if (log != null) {
      log({
        name: 'store.publish',
        source: source,
        optimistic: target === this._optimisticSource
      });
    }
  };

  _proto.subscribe = function subscribe(snapshot, callback) {
    return this._storeSubscriptions.subscribe(snapshot, callback);
  };

  _proto.holdGC = function holdGC() {
    var _this4 = this;

    if (this._gcRun) {
      this._gcRun = null;
      this._shouldScheduleGC = true;
    }

    this._gcHoldCounter++;

    var dispose = function dispose() {
      if (_this4._gcHoldCounter > 0) {
        _this4._gcHoldCounter--;

        if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {
          _this4.scheduleGC();

          _this4._shouldScheduleGC = false;
        }
      }
    };

    return {
      dispose: dispose
    };
  };

  _proto.toJSON = function toJSON() {
    return 'RelayModernStore()';
  } // Internal API
  ;

  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {
    return this._updatedRecordIDs;
  };

  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {
    var _this5 = this;

    var invalidations = new Map();
    dataIDs.forEach(function (dataID) {
      var _RelayModernRecord$ge;

      var record = _this5.getSource().get(dataID);

      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);
    });
    invalidations.set('global', this._globalInvalidationEpoch);
    return {
      dataIDs: dataIDs,
      invalidations: invalidations
    };
  };

  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {
    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);
    var currentInvalidations = latestInvalidationState.invalidations;
    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed

    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {
      return true;
    } // Check if the invalidation state for any of the ids has changed.


    var _iterator = (0, _createForOfIteratorHelper2$9["default"])(prevInvalidationState.dataIDs),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var dataID = _step.value;

        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {
          return true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return false;
  };

  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {
    var _this6 = this;

    var subscription = {
      callback: callback,
      invalidationState: invalidationState
    };

    var dispose = function dispose() {
      _this6._invalidationSubscriptions["delete"](subscription);
    };

    this._invalidationSubscriptions.add(subscription);

    return {
      dispose: dispose
    };
  };

  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {
    var _this7 = this;

    var callback = subscription.callback,
        invalidationState = subscription.invalidationState;
    var dataIDs = invalidationState.dataIDs;
    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {
      return _this7._invalidatedRecordIDs.has(dataID);
    });

    if (!isSubscribedToInvalidatedIDs) {
      return;
    }

    callback();
  };

  _proto.snapshot = function snapshot() {
    !(this._optimisticSource == null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : browser$1(false) : void 0;
    var log = this.__log;

    if (log != null) {
      log({
        name: 'store.snapshot'
      });
    }

    this._storeSubscriptions.snapshotSubscriptions(this.getSource());

    if (this._gcRun) {
      this._gcRun = null;
      this._shouldScheduleGC = true;
    }

    this._optimisticSource = RelayOptimisticRecordSource_1.create(this.getSource());
  };

  _proto.restore = function restore() {
    !(this._optimisticSource != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : browser$1(false) : void 0;
    var log = this.__log;

    if (log != null) {
      log({
        name: 'store.restore'
      });
    }

    this._optimisticSource = null;

    if (this._shouldScheduleGC) {
      this.scheduleGC();
    }

    this._storeSubscriptions.restoreSubscriptions();
  };

  _proto.scheduleGC = function scheduleGC() {
    if (this._gcHoldCounter > 0) {
      this._shouldScheduleGC = true;
      return;
    }

    if (this._gcRun) {
      return;
    }

    this._gcRun = this._collect();

    this._gcScheduler(this._gcStep);
  }
  /**
   * Run a full GC synchronously.
   */
  ;

  _proto.__gc = function __gc() {
    // Don't run GC while there are optimistic updates applied
    if (this._optimisticSource != null) {
      return;
    }

    var gcRun = this._collect();

    while (!gcRun.next().done) {}
  };

  _proto._collect = function* _collect() {
    /* eslint-disable no-labels */
    top: while (true) {
      var startEpoch = this._currentWriteEpoch;
      var references = new Set(); // Mark all records that are traversable from a root

      var _iterator2 = (0, _createForOfIteratorHelper2$9["default"])(this._roots.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var operation = _step2.value.operation;
          var selector = operation.root;
          RelayReferenceMarker_1.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents); // Yield for other work after each operation

          yield; // If the store was updated, restart

          if (startEpoch !== this._currentWriteEpoch) {
            continue top;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var log = this.__log;

      if (log != null) {
        log({
          name: 'store.gc',
          references: references
        });
      } // Sweep records without references


      if (references.size === 0) {
        // Short-circuit if *nothing* is referenced
        this._recordSource.clear();
      } else {
        // Evict any unreferenced nodes
        var storeIDs = this._recordSource.getRecordIDs();

        for (var ii = 0; ii < storeIDs.length; ii++) {
          var dataID = storeIDs[ii];

          if (!references.has(dataID)) {
            this._recordSource.remove(dataID);
          }
        }
      }

      return;
    }
  };

  return RelayModernStore;
}();

function initializeRecordSource(target) {
  if (!target.has(ROOT_ID$8)) {
    var rootRecord = RelayModernRecord.create(ROOT_ID$8, ROOT_TYPE$4);
    target.set(ROOT_ID$8, rootRecord);
  }
}
/**
 * Updates the target with information from source, also updating a mapping of
 * which records in the target were changed as a result.
 * Additionally, will mark records as invalidated at the current write epoch
 * given the set of record ids marked as stale in this update.
 */


function updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {
  // First, update any records that were marked for invalidation.
  // For each provided dataID that was invalidated, we write the
  // INVALIDATED_AT_KEY on the record, indicating
  // the epoch at which the record was invalidated.
  if (idsMarkedForInvalidation) {
    idsMarkedForInvalidation.forEach(function (dataID) {
      var targetRecord = target.get(dataID);
      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),
      // we don't need to count it as an invalidated id

      if (sourceRecord === null) {
        return;
      }

      var nextRecord;

      if (targetRecord != null) {
        // If the target record exists, use it to set the epoch
        // at which it was invalidated. This record will be updated with
        // any changes from source in the section below
        // where we update the target records based on the source.
        nextRecord = RelayModernRecord.clone(targetRecord);
      } else {
        // If the target record doesn't exist, it means that a new record
        // in the source was created (and also invalidated), so we use that
        // record to set the epoch at which it was invalidated. This record
        // will be updated with any changes from source in the section below
        // where we update the target records based on the source.
        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;
      }

      if (!nextRecord) {
        return;
      }

      RelayModernRecord.setValue(nextRecord, RelayStoreUtils_1.INVALIDATED_AT_KEY, currentWriteEpoch);
      invalidatedRecordIDs.add(dataID); // $FlowFixMe[incompatible-call]

      target.set(dataID, nextRecord);
    });
  } // Update the target based on the changes present in source


  var dataIDs = source.getRecordIDs();

  for (var ii = 0; ii < dataIDs.length; ii++) {
    var dataID = dataIDs[ii];
    var sourceRecord = source.get(dataID);
    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.

    if (process$1.env.NODE_ENV !== "production") {
      if (sourceRecord) {
        RelayModernRecord.freeze(sourceRecord);
      }
    }

    if (sourceRecord && targetRecord) {
      // ReactFlightClientResponses are lazy and only materialize when readRoot
      // is called when we read the field, so if the record is a Flight field
      // we always use the new record's data regardless of whether
      // it actually changed. Let React take care of reconciliation instead.
      var nextRecord = RelayModernRecord.getType(targetRecord) === RelayStoreReactFlightUtils.REACT_FLIGHT_TYPE_NAME ? sourceRecord : RelayModernRecord.update(targetRecord, sourceRecord);

      if (nextRecord !== targetRecord) {
        // Prevent mutation of a record from outside the store.
        if (process$1.env.NODE_ENV !== "production") {
          RelayModernRecord.freeze(nextRecord);
        }

        updatedRecordIDs.add(dataID);
        target.set(dataID, nextRecord);
      }
    } else if (sourceRecord === null) {
      target["delete"](dataID);

      if (targetRecord !== null) {
        updatedRecordIDs.add(dataID);
      }
    } else if (sourceRecord) {
      target.set(dataID, sourceRecord);
      updatedRecordIDs.add(dataID);
    } // don't add explicit undefined

  }
}
/**
 * Returns an OperationAvailability given the Availability returned
 * by checking an operation, and when that operation was last written to the store.
 * Specifically, the provided Availability of an operation will contain the
 * value of when a record referenced by the operation was most recently
 * invalidated; given that value, and given when this operation was last
 * written to the store, this function will return the overall
 * OperationAvailability for the operation.
 */


function getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {
  var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt,
      status = operationAvailability.status;

  if (typeof mostRecentlyInvalidatedAt === 'number') {
    // If some record referenced by this operation is stale, then the operation itself is stale
    // if either the operation itself was never written *or* the operation was last written
    // before the most recent invalidation of its reachable records.
    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {
      return {
        status: 'stale'
      };
    }
  }

  if (status === 'missing') {
    return {
      status: 'missing'
    };
  }

  if (operationFetchTime != null && queryCacheExpirationTime != null) {
    var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;

    if (isStale) {
      return {
        status: 'stale'
      };
    }
  } // There were no invalidations of any reachable records *or* the operation is known to have
  // been fetched after the most recent record invalidation.


  return {
    status: 'available',
    fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null
  };
}

var RelayModernStore_1 = RelayModernStore;

/**
 * Converts a FetchFunction into an ExecuteFunction for use by RelayNetwork.
 */
function convertFetch(fn) {
  return function fetch(request, variables, cacheConfig, uploadables, logRequestInfo) {
    var result = fn(request, variables, cacheConfig, uploadables, logRequestInfo); // Note: We allow FetchFunction to directly return Error to indicate
    // a failure to fetch. To avoid handling this special case throughout the
    // Relay codebase, it is explicitly handled here.

    if (result instanceof Error) {
      return RelayObservable_1.create(function (sink) {
        return sink.error(result);
      });
    }

    return RelayObservable_1.from(result);
  };
}

var ConvertToExecuteFunction = {
  convertFetch: convertFetch
};

var convertFetch$1 = ConvertToExecuteFunction.convertFetch;

/**
 * Creates an implementation of the `Network` interface defined in
 * `RelayNetworkTypes` given `fetch` and `subscribe` functions.
 */
function create$2(fetchFn, subscribe) {
  // Convert to functions that returns RelayObservable.
  var observeFetch = convertFetch$1(fetchFn);

  function execute(request, variables, cacheConfig, uploadables, logRequestInfo) {
    if (request.operationKind === 'subscription') {
      !subscribe ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayNetwork: This network layer does not support Subscriptions. ' + 'To use Subscriptions, provide a custom network layer.') : browser$1(false) : void 0;
      !!uploadables ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayNetwork: Cannot provide uploadables while subscribing.') : browser$1(false) : void 0;
      return subscribe(request, variables, cacheConfig);
    }

    var pollInterval = cacheConfig.poll;

    if (pollInterval != null) {
      !!uploadables ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayNetwork: Cannot provide uploadables while polling.') : browser$1(false) : void 0;
      return observeFetch(request, variables, {
        force: true
      }).poll(pollInterval);
    }

    return observeFetch(request, variables, cacheConfig, uploadables, logRequestInfo);
  }

  return {
    execute: execute
  };
}

var RelayNetwork = {
  create: create$2
};

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

var profileHandlersByName = {};
var defaultProfiler = {
  stop: function stop() {}
};
/**
 * @public
 *
 * Instruments methods to allow profiling various parts of Relay. Profiling code
 * in Relay consists of three steps:
 *
 *  - Instrument the function to be profiled.
 *  - Attach handlers to the instrumented function.
 *  - Run the code which triggers the handlers.
 *
 * Handlers attached to instrumented methods are called with an instrumentation
 * name and a callback that must be synchronously executed:
 *
 *   instrumentedMethod.attachHandler(function(name, callback) {
 *     const start = performance.now();
 *     callback();
 *     console.log('Duration', performance.now() - start);
 *   });
 *
 * Handlers for profiles are callbacks that return a stop method:
 *
 *   RelayProfiler.attachProfileHandler('profileName', (name, state) => {
 *     const start = performance.now();
 *     return function stop(name, state) {
 *       console.log(`Duration (${name})`, performance.now() - start);
 *     }
 *   });
 */

var RelayProfiler = {
  /**
   * Instruments profiling for arbitrarily asynchronous code by a name.
   *
   *   const timerProfiler = RelayProfiler.profile('timeout');
   *   setTimeout(function() {
   *     timerProfiler.stop();
   *   }, 1000);
   *
   *   RelayProfiler.attachProfileHandler('timeout', ...);
   *
   * Arbitrary state can also be passed into `profile` as a second argument. The
   * attached profile handlers will receive this as the second argument.
   */
  profile: function profile(name, state) {
    var handlers = profileHandlersByName[name];

    if (handlers && handlers.length > 0) {
      var stopHandlers = [];

      for (var ii = handlers.length - 1; ii >= 0; ii--) {
        var stopHandler = handlers[ii](name, state);
        stopHandlers.unshift(stopHandler);
      }

      return {
        stop: function stop(error) {
          stopHandlers.forEach(function (stopHandler) {
            return stopHandler(error);
          });
        }
      };
    }

    return defaultProfiler;
  },

  /**
   * Attaches a handler to profiles with the supplied name.
   */
  attachProfileHandler: function attachProfileHandler(name, handler) {
    if (!profileHandlersByName.hasOwnProperty(name)) {
      profileHandlersByName[name] = [];
    }

    profileHandlersByName[name].push(handler);
  },

  /**
   * Detaches a handler attached via `attachProfileHandler`.
   */
  detachProfileHandler: function detachProfileHandler(name, handler) {
    if (profileHandlersByName.hasOwnProperty(name)) {
      removeFromArray(profileHandlersByName[name], handler);
    }
  }
};

function removeFromArray(array, element) {
  var index = array.indexOf(element);

  if (index !== -1) {
    array.splice(index, 1);
  }
}

var RelayProfiler_1 = RelayProfiler;

var _objectSpread2$7 = interopRequireDefault(objectSpread2);





/**
 * A cache for storing query responses, featuring:
 * - `get` with TTL
 * - cache size limiting, with least-recently *updated* entries purged first
 */
var RelayQueryResponseCache = /*#__PURE__*/function () {
  function RelayQueryResponseCache(_ref) {
    var size = _ref.size,
        ttl = _ref.ttl;
    !(size > 0) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayQueryResponseCache: Expected the max cache size to be > 0, got ' + '`%s`.', size) : browser$1(false) : void 0;
    !(ttl > 0) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayQueryResponseCache: Expected the max ttl to be > 0, got `%s`.', ttl) : browser$1(false) : void 0;
    this._responses = new Map();
    this._size = size;
    this._ttl = ttl;
  }

  var _proto = RelayQueryResponseCache.prototype;

  _proto.clear = function clear() {
    this._responses.clear();
  };

  _proto.get = function get(queryID, variables) {
    var _this = this;

    var cacheKey = getCacheKey(queryID, variables);

    this._responses.forEach(function (response, key) {
      if (!isCurrent(response.fetchTime, _this._ttl)) {
        _this._responses["delete"](key);
      }
    });

    var response = this._responses.get(cacheKey);

    return response != null ? // $FlowFixMe[speculation-ambiguous]
    (0, _objectSpread2$7["default"])((0, _objectSpread2$7["default"])({}, response.payload), {}, {
      extensions: (0, _objectSpread2$7["default"])((0, _objectSpread2$7["default"])({}, response.payload.extensions), {}, {
        cacheTimestamp: response.fetchTime
      })
    }) : null;
  };

  _proto.set = function set(queryID, variables, payload) {
    var fetchTime = Date.now();
    var cacheKey = getCacheKey(queryID, variables);

    this._responses["delete"](cacheKey); // deletion resets key ordering


    this._responses.set(cacheKey, {
      fetchTime: fetchTime,
      payload: payload
    }); // Purge least-recently updated key when max size reached


    if (this._responses.size > this._size) {
      var firstKey = this._responses.keys().next();

      if (!firstKey.done) {
        this._responses["delete"](firstKey.value);
      }
    }
  };

  return RelayQueryResponseCache;
}();

function getCacheKey(queryID, variables) {
  return JSON.stringify(stableCopy_1({
    queryID: queryID,
    variables: variables
  }));
}
/**
 * Determine whether a response fetched at `fetchTime` is still valid given
 * some `ttl`.
 */


function isCurrent(fetchTime, ttl) {
  return fetchTime + ttl >= Date.now();
}

var RelayQueryResponseCache_1 = RelayQueryResponseCache;

var _defineProperty2$2 = interopRequireDefault(defineProperty);





/**
 * An implementation of a `ReplaySubject` for Relay Observables.
 *
 * Records events provided and synchronously plays them back to new subscribers,
 * as well as forwarding new asynchronous events.
 */
var RelayReplaySubject = /*#__PURE__*/function () {
  function RelayReplaySubject() {
    var _this = this;

    (0, _defineProperty2$2["default"])(this, "_complete", false);
    (0, _defineProperty2$2["default"])(this, "_events", []);
    (0, _defineProperty2$2["default"])(this, "_sinks", new Set());
    (0, _defineProperty2$2["default"])(this, "_subscription", null);
    this._observable = RelayObservable_1.create(function (sink) {
      _this._sinks.add(sink);

      var events = _this._events;

      for (var i = 0; i < events.length; i++) {
        if (sink.closed) {
          // Bail if an event made the observer unsubscribe.
          break;
        }

        var event = events[i];

        switch (event.kind) {
          case 'complete':
            sink.complete();
            break;

          case 'error':
            sink.error(event.error);
            break;

          case 'next':
            sink.next(event.data);
            break;

          default:
            event.kind;
             process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayReplaySubject: Unknown event kind `%s`.', event.kind) : browser$1(false) ;
        }
      }

      return function () {
        _this._sinks["delete"](sink);
      };
    });
  }

  var _proto = RelayReplaySubject.prototype;

  _proto.complete = function complete() {
    if (this._complete === true) {
      return;
    }

    this._complete = true;

    this._events.push({
      kind: 'complete'
    });

    this._sinks.forEach(function (sink) {
      return sink.complete();
    });
  };

  _proto.error = function error(_error) {
    if (this._complete === true) {
      return;
    }

    this._complete = true;

    this._events.push({
      kind: 'error',
      error: _error
    });

    this._sinks.forEach(function (sink) {
      return sink.error(_error);
    });
  };

  _proto.next = function next(data) {
    if (this._complete === true) {
      return;
    }

    this._events.push({
      kind: 'next',
      data: data
    });

    this._sinks.forEach(function (sink) {
      return sink.next(data);
    });
  };

  _proto.subscribe = function subscribe(observer) {
    this._subscription = this._observable.subscribe(observer);
    return this._subscription;
  };

  _proto.unsubscribe = function unsubscribe() {
    if (this._subscription) {
      this._subscription.unsubscribe();

      this._subscription = null;
    }
  };

  _proto.getObserverCount = function getObserverCount() {
    return this._sinks.size;
  };

  return RelayReplaySubject;
}();

var RelayReplaySubject_1 = RelayReplaySubject;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
/**
 * Determine if a given value is an object that implements the `Environment`
 * interface defined in `RelayStoreTypes`.
 *
 * Use a sigil for detection to avoid a realm-specific instanceof check, and to
 * aid in module tree-shaking to avoid requiring all of RelayRuntime just to
 * detect its environment.
 */

function isRelayModernEnvironment(environment) {
  return Boolean(environment && environment['@@RelayModernEnvironment']);
}

var isRelayModernEnvironment_1 = isRelayModernEnvironment;

var getRequest$1 = GraphQLTag.getRequest;

var createOperationDescriptor$1 = RelayModernOperationDescriptor.createOperationDescriptor;

/**
 * Higher-level helper function to execute a mutation against a specific
 * environment.
 */
function applyOptimisticMutation(environment, config) {
  !isRelayModernEnvironment_1(environment) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'commitMutation: expected `environment` to be an instance of ' + '`RelayModernEnvironment`.') : browser$1(false) : void 0;
  var mutation = getRequest$1(config.mutation);

  if (mutation.params.operationKind !== 'mutation') {
    throw new Error('commitMutation: Expected mutation operation');
  }

  var optimisticUpdater = config.optimisticUpdater;
  var configs = config.configs,
      optimisticResponse = config.optimisticResponse,
      variables = config.variables;
  var operation = createOperationDescriptor$1(mutation, variables);

  if (configs) {
    var _RelayDeclarativeMuta = RelayDeclarativeMutationConfig.convert(configs, mutation, optimisticUpdater);

    optimisticUpdater = _RelayDeclarativeMuta.optimisticUpdater;
  }

  return environment.applyMutation({
    operation: operation,
    response: optimisticResponse,
    updater: optimisticUpdater
  });
}

var applyOptimisticMutation_1 = applyOptimisticMutation;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

function commitLocalUpdate(environment, updater) {
  environment.commitUpdate(updater);
}

var commitLocalUpdate_1 = commitLocalUpdate;

var _objectSpread2$8 = interopRequireDefault(objectSpread2);



var hasOwnProperty = Object.prototype.hasOwnProperty;

var CONDITION$4 = RelayConcreteNode_1.CONDITION,
    CLIENT_COMPONENT$3 = RelayConcreteNode_1.CLIENT_COMPONENT,
    CLIENT_EXTENSION$4 = RelayConcreteNode_1.CLIENT_EXTENSION,
    DEFER$4 = RelayConcreteNode_1.DEFER,
    FLIGHT_FIELD$4 = RelayConcreteNode_1.FLIGHT_FIELD,
    FRAGMENT_SPREAD$4 = RelayConcreteNode_1.FRAGMENT_SPREAD,
    INLINE_FRAGMENT$4 = RelayConcreteNode_1.INLINE_FRAGMENT,
    LINKED_FIELD$5 = RelayConcreteNode_1.LINKED_FIELD,
    LINKED_HANDLE$3 = RelayConcreteNode_1.LINKED_HANDLE,
    MODULE_IMPORT$4 = RelayConcreteNode_1.MODULE_IMPORT,
    SCALAR_FIELD$5 = RelayConcreteNode_1.SCALAR_FIELD,
    SCALAR_HANDLE$3 = RelayConcreteNode_1.SCALAR_HANDLE,
    STREAM$4 = RelayConcreteNode_1.STREAM,
    TYPE_DISCRIMINATOR$3 = RelayConcreteNode_1.TYPE_DISCRIMINATOR;

var validateMutation = function validateMutation() {};

if (process$1.env.NODE_ENV !== "production") {
  var addFieldToDiff = function addFieldToDiff(path, diff, isScalar) {
    var deepLoc = diff;
    path.split('.').forEach(function (key, index, arr) {
      if (deepLoc[key] == null) {
        deepLoc[key] = {};
      }

      if (isScalar && index === arr.length - 1) {
        deepLoc[key] = '<scalar>';
      }

      deepLoc = deepLoc[key];
    });
  };

  validateMutation = function validateMutation(optimisticResponse, mutation, variables) {
    var operationName = mutation.operation.name;
    var context = {
      path: 'ROOT',
      visitedPaths: new Set(),
      variables: variables || {},
      missingDiff: {},
      extraDiff: {},
      moduleImportPaths: new Set()
    };
    validateSelections(optimisticResponse, mutation.operation.selections, context);
    validateOptimisticResponse(optimisticResponse, context);
    process$1.env.NODE_ENV !== "production" ? warning_1(context.missingDiff.ROOT == null, 'Expected `optimisticResponse` to match structure of server response for mutation `%s`, please define fields for all of\n%s', operationName, JSON.stringify(context.missingDiff.ROOT, null, 2)) : void 0;
    process$1.env.NODE_ENV !== "production" ? warning_1(context.extraDiff.ROOT == null, 'Expected `optimisticResponse` to match structure of server response for mutation `%s`, please remove all fields of\n%s', operationName, JSON.stringify(context.extraDiff.ROOT, null, 2)) : void 0;
  };

  var validateSelections = function validateSelections(optimisticResponse, selections, context) {
    selections.forEach(function (selection) {
      return validateSelection(optimisticResponse, selection, context);
    });
  };

  var validateSelection = function validateSelection(optimisticResponse, selection, context) {
    switch (selection.kind) {
      case CONDITION$4:
        validateSelections(optimisticResponse, selection.selections, context);
        return;

      case CLIENT_COMPONENT$3:
      case FRAGMENT_SPREAD$4:
        validateSelections(optimisticResponse, selection.fragment.selections, context);
        return;

      case SCALAR_FIELD$5:
      case LINKED_FIELD$5:
      case FLIGHT_FIELD$4:
        return validateField(optimisticResponse, selection, context);

      case INLINE_FRAGMENT$4:
        var type = selection.type;
        var isConcreteType = selection.abstractKey == null;
        selection.selections.forEach(function (subselection) {
          if (isConcreteType && optimisticResponse.__typename !== type) {
            return;
          }

          validateSelection(optimisticResponse, subselection, context);
        });
        return;

      case CLIENT_EXTENSION$4:
        selection.selections.forEach(function (subselection) {
          validateSelection(optimisticResponse, subselection, context);
        });
        return;

      case MODULE_IMPORT$4:
        return validateModuleImport(context);

      case LINKED_HANDLE$3:
      case SCALAR_HANDLE$3:
      case DEFER$4:
      case STREAM$4:
      case TYPE_DISCRIMINATOR$3:
        {
          // TODO(T35864292) - Add missing validations for these types
          return;
        }

      default:
        return;
    }
  };

  var validateModuleImport = function validateModuleImport(context) {
    context.moduleImportPaths.add(context.path);
  };

  var validateField = function validateField(optimisticResponse, field, context) {
    var fieldName = field.alias || field.name;
    var path = "".concat(context.path, ".").concat(fieldName);
    context.visitedPaths.add(path);

    switch (field.kind) {
      case SCALAR_FIELD$5:
        if (hasOwnProperty.call(optimisticResponse, fieldName) === false) {
          addFieldToDiff(path, context.missingDiff, true);
        }

        return;

      case LINKED_FIELD$5:
        var selections = field.selections;

        if (optimisticResponse[fieldName] === null || hasOwnProperty.call(optimisticResponse, fieldName) && optimisticResponse[fieldName] === undefined) {
          return;
        }

        if (field.plural) {
          if (Array.isArray(optimisticResponse[fieldName])) {
            optimisticResponse[fieldName].forEach(function (r) {
              if (r !== null) {
                validateSelections(r, selections, (0, _objectSpread2$8["default"])((0, _objectSpread2$8["default"])({}, context), {}, {
                  path: path
                }));
              }
            });
            return;
          } else {
            addFieldToDiff(path, context.missingDiff);
            return;
          }
        } else {
          if (optimisticResponse[fieldName] instanceof Object) {
            validateSelections(optimisticResponse[fieldName], selections, (0, _objectSpread2$8["default"])((0, _objectSpread2$8["default"])({}, context), {}, {
              path: path
            }));
            return;
          } else {
            addFieldToDiff(path, context.missingDiff);
            return;
          }
        }

      case FLIGHT_FIELD$4:
        if (optimisticResponse[fieldName] === null || hasOwnProperty.call(optimisticResponse, fieldName) && optimisticResponse[fieldName] === undefined) {
          return;
        }

        throw new Error('validateMutation: Flight fields are not compatible with ' + 'optimistic updates, as React does not have the component code ' + 'necessary to process new data on the client. Instead, you ' + 'should update your code to require a full refetch of the Flight ' + 'field so your UI can be updated.');
    }
  };

  var validateOptimisticResponse = function validateOptimisticResponse(optimisticResponse, context) {
    if (Array.isArray(optimisticResponse)) {
      optimisticResponse.forEach(function (r) {
        if (r instanceof Object) {
          validateOptimisticResponse(r, context);
        }
      });
      return;
    }

    Object.keys(optimisticResponse).forEach(function (key) {
      var value = optimisticResponse[key];
      var path = "".concat(context.path, ".").concat(key); // if it's a module import path we don't have an ast so we cannot validate it

      if (context.moduleImportPaths.has(path)) {
        return;
      }

      if (!context.visitedPaths.has(path)) {
        addFieldToDiff(path, context.extraDiff);
        return;
      }

      if (value instanceof Object) {
        validateOptimisticResponse(value, (0, _objectSpread2$8["default"])((0, _objectSpread2$8["default"])({}, context), {}, {
          path: path
        }));
      }
    });
  };
}

var validateMutation_1 = validateMutation;

var _toConsumableArray2$4 = interopRequireDefault(toConsumableArray);











var getRequest$2 = GraphQLTag.getRequest;

var generateUniqueClientID$1 = ClientID.generateUniqueClientID;

var createOperationDescriptor$2 = RelayModernOperationDescriptor.createOperationDescriptor;

/**
 * Higher-level helper function to execute a mutation against a specific
 * environment.
 */
function commitMutation(environment, config) {
  !isRelayModernEnvironment_1(environment) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'commitMutation: expected `environment` to be an instance of ' + '`RelayModernEnvironment`.') : browser$1(false) : void 0;
  var mutation = getRequest$2(config.mutation);

  if (mutation.params.operationKind !== 'mutation') {
    throw new Error('commitMutation: Expected mutation operation');
  }

  if (mutation.kind !== 'Request') {
    throw new Error('commitMutation: Expected mutation to be of type request');
  }

  var optimisticResponse = config.optimisticResponse,
      optimisticUpdater = config.optimisticUpdater,
      updater = config.updater;
  var configs = config.configs,
      cacheConfig = config.cacheConfig,
      onError = config.onError,
      onUnsubscribe = config.onUnsubscribe,
      variables = config.variables,
      uploadables = config.uploadables;
  var operation = createOperationDescriptor$2(mutation, variables, cacheConfig, generateUniqueClientID$1()); // TODO: remove this check after we fix flow.

  if (typeof optimisticResponse === 'function') {
    optimisticResponse = optimisticResponse();
    process$1.env.NODE_ENV !== "production" ? warning_1(false, 'commitMutation: Expected `optimisticResponse` to be an object, ' + 'received a function.') : void 0;
  }

  if (process$1.env.NODE_ENV !== "production") {
    if (optimisticResponse instanceof Object) {
      validateMutation_1(optimisticResponse, mutation, variables);
    }
  }

  if (configs) {
    var _RelayDeclarativeMuta = RelayDeclarativeMutationConfig.convert(configs, mutation, optimisticUpdater, updater);

    optimisticUpdater = _RelayDeclarativeMuta.optimisticUpdater;
    updater = _RelayDeclarativeMuta.updater;
  }

  var errors = [];
  var subscription = environment.executeMutation({
    operation: operation,
    optimisticResponse: optimisticResponse,
    optimisticUpdater: optimisticUpdater,
    updater: updater,
    uploadables: uploadables
  }).subscribe({
    next: function next(payload) {
      if (Array.isArray(payload)) {
        payload.forEach(function (item) {
          if (item.errors) {
            errors.push.apply(errors, (0, _toConsumableArray2$4["default"])(item.errors));
          }
        });
      } else {
        if (payload.errors) {
          errors.push.apply(errors, (0, _toConsumableArray2$4["default"])(payload.errors));
        }
      }
    },
    complete: function complete() {
      var onCompleted = config.onCompleted;

      if (onCompleted) {
        var snapshot = environment.lookup(operation.fragment);
        onCompleted(snapshot.data, errors.length !== 0 ? errors : null);
      }
    },
    error: onError,
    unsubscribe: onUnsubscribe
  });
  return {
    dispose: subscription.unsubscribe
  };
}

var commitMutation_1 = commitMutation;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
/**
 * A fast test to determine if two values are equal scalars:
 * - compares scalars such as booleans, strings, numbers by value
 * - compares functions by identity
 * - returns false for complex values, since these cannot be cheaply tested for
 *   equality (use `areEquals` instead)
 */

function isScalarAndEqual(valueA, valueB) {
  return valueA === valueB && (valueA === null || typeof valueA !== 'object');
}

var isScalarAndEqual_1 = isScalarAndEqual;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */

function reportMissingRequiredFields(environment, missingRequiredFields) {
  switch (missingRequiredFields.action) {
    case 'THROW':
      {
        var _missingRequiredField = missingRequiredFields.field,
            path = _missingRequiredField.path,
            owner = _missingRequiredField.owner; // This gives the consumer the chance to throw their own error if they so wish.

        environment.requiredFieldLogger({
          kind: 'missing_field.throw',
          owner: owner,
          fieldPath: path
        });
        throw new Error("Relay: Missing @required value at path '".concat(path, "' in '").concat(owner, "'."));
      }

    case 'LOG':
      missingRequiredFields.fields.forEach(function (_ref) {
        var path = _ref.path,
            owner = _ref.owner;
        environment.requiredFieldLogger({
          kind: 'missing_field.log',
          owner: owner,
          fieldPath: path
        });
      });
      break;

    default:
      {
        missingRequiredFields.action;
      }
  }
}

var reportMissingRequiredFields_1 = reportMissingRequiredFields;

var WEAKMAP_SUPPORTED = typeof WeakMap === 'function';
var requestCachesByEnvironment = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();
/**
 * Fetches the given query and variables on the provided environment,
 * and de-dupes identical in-flight requests.
 *
 * Observing a request:
 * ====================
 * fetchQuery returns an Observable which you can call .subscribe()
 * on. subscribe() takes an Observer, which you can provide to
 * observe network events:
 *
 * ```
 * fetchQuery(environment, query, variables).subscribe({
 *   // Called when network requests starts
 *   start: (subscription) => {},
 *
 *   // Called after a payload is received and written to the local store
 *   next: (payload) => {},
 *
 *   // Called when network requests errors
 *   error: (error) => {},
 *
 *   // Called when network requests fully completes
 *   complete: () => {},
 *
 *   // Called when network request is unsubscribed
 *   unsubscribe: (subscription) => {},
 * });
 * ```
 *
 * In-flight request de-duping:
 * ============================
 * By default, calling fetchQuery multiple times with the same
 * environment, query and variables will not initiate a new request if a request
 * for those same parameters is already in flight.
 *
 * A request is marked in-flight from the moment it starts until the moment it
 * fully completes, regardless of error or successful completion.
 *
 * NOTE: If the request completes _synchronously_, calling fetchQuery
 * a second time with the same arguments in the same tick will _NOT_ de-dupe
 * the request given that it will no longer be in-flight.
 *
 *
 * Data Retention:
 * ===============
 * This function will not retain any query data outside the scope of the
 * request, which means it is not guaranteed that it won't be garbage
 * collected after the request completes.
 * If you need to retain data, you can do so manually with environment.retain().
 *
 * Cancelling requests:
 * ====================
 * If the subscription returned by subscribe is called while the
 * request is in-flight, the request will be cancelled.
 *
 * ```
 * const subscription = fetchQuery(...).subscribe(...);
 *
 * // This will cancel the request if it is in-flight.
 * subscription.unsubscribe();
 * ```
 */

function fetchQuery(environment, operation) {
  return fetchQueryDeduped(environment, operation.request.identifier, function () {
    return environment.execute({
      operation: operation
    });
  });
}
/**
 * Low-level implementation details of `fetchQuery`.
 *
 * `fetchQueryDeduped` can also be used to share a single cache for
 * requests that aren't using `fetchQuery` directly (e.g. because they don't
 * have an `OperationDescriptor` when they are called).
 */


function fetchQueryDeduped(environment, identifier, fetchFn) {
  return RelayObservable_1.create(function (sink) {
    var requestCache = getRequestCache(environment);
    var cachedRequest = requestCache.get(identifier);

    if (!cachedRequest) {
      fetchFn()["finally"](function () {
        return requestCache["delete"](identifier);
      }).subscribe({
        start: function start(subscription) {
          cachedRequest = {
            identifier: identifier,
            subject: new RelayReplaySubject_1(),
            subjectForInFlightStatus: new RelayReplaySubject_1(),
            subscription: subscription
          };
          requestCache.set(identifier, cachedRequest);
        },
        next: function next(response) {
          var cachedReq = getCachedRequest(requestCache, identifier);
          cachedReq.subject.next(response);
          cachedReq.subjectForInFlightStatus.next(response);
        },
        error: function error(_error) {
          var cachedReq = getCachedRequest(requestCache, identifier);
          cachedReq.subject.error(_error);
          cachedReq.subjectForInFlightStatus.error(_error);
        },
        complete: function complete() {
          var cachedReq = getCachedRequest(requestCache, identifier);
          cachedReq.subject.complete();
          cachedReq.subjectForInFlightStatus.complete();
        },
        unsubscribe: function unsubscribe(subscription) {
          var cachedReq = getCachedRequest(requestCache, identifier);
          cachedReq.subject.unsubscribe();
          cachedReq.subjectForInFlightStatus.unsubscribe();
        }
      });
    }

    !(cachedRequest != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, '[fetchQueryInternal] fetchQueryDeduped: Expected `start` to be ' + 'called synchronously') : browser$1(false) : void 0;
    return getObservableForCachedRequest(requestCache, cachedRequest).subscribe(sink);
  });
}
/**
 * @private
 */


function getObservableForCachedRequest(requestCache, cachedRequest) {
  return RelayObservable_1.create(function (sink) {
    var subscription = cachedRequest.subject.subscribe(sink);
    return function () {
      subscription.unsubscribe();
      var cachedRequestInstance = requestCache.get(cachedRequest.identifier);

      if (cachedRequestInstance) {
        var requestSubscription = cachedRequestInstance.subscription;

        if (requestSubscription != null && cachedRequestInstance.subject.getObserverCount() === 0) {
          requestSubscription.unsubscribe();
          requestCache["delete"](cachedRequest.identifier);
        }
      }
    };
  });
}
/**
 * @private
 */


function getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest) {
  return RelayObservable_1.create(function (sink) {
    var subscription = cachedRequest.subjectForInFlightStatus.subscribe({
      error: sink.error,
      next: function next(response) {
        if (!environment.isRequestActive(cachedRequest.identifier)) {
          sink.complete();
          return;
        }

        sink.next();
      },
      complete: sink.complete,
      unsubscribe: sink.complete
    });
    return function () {
      subscription.unsubscribe();
    };
  });
}
/**
 * If a request is active for the given query, variables and environment,
 * this function will return a Promise that will resolve when that request
 * stops being active (receives a final payload), and the data has been saved
 * to the store.
 * If no request is active, null will be returned
 */


function getPromiseForActiveRequest(environment, request) {
  var requestCache = getRequestCache(environment);
  var cachedRequest = requestCache.get(request.identifier);

  if (!cachedRequest) {
    return null;
  }

  if (!environment.isRequestActive(cachedRequest.identifier)) {
    return null;
  }

  return new Promise(function (resolve, reject) {
    var resolveOnNext = false;
    getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest).subscribe({
      complete: resolve,
      error: reject,
      next: function next(response) {
        /*
         * The underlying `RelayReplaySubject` will synchronously replay events
         * as soon as we subscribe, but since we want the *next* asynchronous
         * one, we'll ignore them until the replay finishes.
         */
        if (resolveOnNext) {
          resolve(response);
        }
      }
    });
    resolveOnNext = true;
  });
}
/**
 * If there is a pending request for the given query, returns an Observable of
 * *all* its responses. Existing responses are published synchronously and
 * subsequent responses are published asynchronously. Returns null if there is
 * no pending request. This is similar to fetchQuery() except that it will not
 * issue a fetch if there isn't already one pending.
 */


function getObservableForActiveRequest(environment, request) {
  var requestCache = getRequestCache(environment);
  var cachedRequest = requestCache.get(request.identifier);

  if (!cachedRequest) {
    return null;
  }

  if (!environment.isRequestActive(cachedRequest.identifier)) {
    return null;
  }

  return getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest);
}
/**
 * @private
 */


function getRequestCache(environment) {
  var cached = requestCachesByEnvironment.get(environment);

  if (cached != null) {
    return cached;
  }

  var requestCache = new Map();
  requestCachesByEnvironment.set(environment, requestCache);
  return requestCache;
}
/**
 * @private
 */


function getCachedRequest(requestCache, identifier) {
  var cached = requestCache.get(identifier);
  !(cached != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, '[fetchQueryInternal] getCachedRequest: Expected request to be cached') : browser$1(false) : void 0;
  return cached;
}

var fetchQueryInternal = {
  fetchQuery: fetchQuery,
  fetchQueryDeduped: fetchQueryDeduped,
  getPromiseForActiveRequest: getPromiseForActiveRequest,
  getObservableForActiveRequest: getObservableForActiveRequest
};

var _objectSpread2$9 = interopRequireDefault(objectSpread2);

var _defineProperty2$3 = interopRequireDefault(defineProperty);













var getPromiseForActiveRequest$1 = fetchQueryInternal.getPromiseForActiveRequest;

var createRequestDescriptor$1 = RelayModernOperationDescriptor.createRequestDescriptor;

var areEqualSelectors$1 = RelayModernSelector.areEqualSelectors,
    createReaderSelector$2 = RelayModernSelector.createReaderSelector,
    getSelectorsFromObject$1 = RelayModernSelector.getSelectorsFromObject;

/**
 * A utility for resolving and subscribing to the results of a fragment spec
 * (key -> fragment mapping) given some "props" that determine the root ID
 * and variables to use when reading each fragment. When props are changed via
 * `setProps()`, the resolver will update its results and subscriptions
 * accordingly. Internally, the resolver:
 * - Converts the fragment map & props map into a map of `Selector`s.
 * - Removes any resolvers for any props that became null.
 * - Creates resolvers for any props that became non-null.
 * - Updates resolvers with the latest props.
 *
 * This utility is implemented as an imperative, stateful API for performance
 * reasons: reusing previous resolvers, callback functions, and subscriptions
 * all helps to reduce object allocation and thereby decrease GC time.
 *
 * The `resolve()` function is also lazy and memoized: changes in the store mark
 * the resolver as stale and notify the caller, and the actual results are
 * recomputed the first time `resolve()` is called.
 */
var RelayModernFragmentSpecResolver = /*#__PURE__*/function () {
  function RelayModernFragmentSpecResolver(context, fragments, props, callback, rootIsQueryRenderer) {
    var _this = this;

    (0, _defineProperty2$3["default"])(this, "_onChange", function () {
      _this._stale = true;

      if (typeof _this._callback === 'function') {
        _this._callback();
      }
    });
    this._callback = callback;
    this._context = context;
    this._data = {};
    this._fragments = fragments;
    this._props = {};
    this._resolvers = {};
    this._stale = false;
    this._rootIsQueryRenderer = rootIsQueryRenderer;
    this.setProps(props);
  }

  var _proto = RelayModernFragmentSpecResolver.prototype;

  _proto.dispose = function dispose() {
    for (var _key in this._resolvers) {
      if (this._resolvers.hasOwnProperty(_key)) {
        disposeCallback(this._resolvers[_key]);
      }
    }
  };

  _proto.resolve = function resolve() {
    if (this._stale) {
      // Avoid mapping the object multiple times, which could occur if data for
      // multiple keys changes in the same event loop.
      var prevData = this._data;
      var nextData;

      for (var _key2 in this._resolvers) {
        if (this._resolvers.hasOwnProperty(_key2)) {
          var resolver = this._resolvers[_key2];
          var prevItem = prevData[_key2];

          if (resolver) {
            var nextItem = resolver.resolve();

            if (nextData || nextItem !== prevItem) {
              nextData = nextData || (0, _objectSpread2$9["default"])({}, prevData);
              nextData[_key2] = nextItem;
            }
          } else {
            var prop = this._props[_key2];

            var _nextItem = prop !== undefined ? prop : null;

            if (nextData || !isScalarAndEqual_1(_nextItem, prevItem)) {
              nextData = nextData || (0, _objectSpread2$9["default"])({}, prevData);
              nextData[_key2] = _nextItem;
            }
          }
        }
      }

      this._data = nextData || prevData;
      this._stale = false;
    }

    return this._data;
  };

  _proto.setCallback = function setCallback(callback) {
    this._callback = callback;
  };

  _proto.setProps = function setProps(props) {
    var ownedSelectors = getSelectorsFromObject$1(this._fragments, props);
    this._props = {};

    for (var _key3 in ownedSelectors) {
      if (ownedSelectors.hasOwnProperty(_key3)) {
        var ownedSelector = ownedSelectors[_key3];
        var resolver = this._resolvers[_key3];

        if (ownedSelector == null) {
          if (resolver != null) {
            resolver.dispose();
          }

          resolver = null;
        } else if (ownedSelector.kind === 'PluralReaderSelector') {
          if (resolver == null) {
            resolver = new SelectorListResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._onChange);
          } else {
            !(resolver instanceof SelectorListResolver) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an array.', _key3) : browser$1(false) : void 0;
            resolver.setSelector(ownedSelector);
          }
        } else {
          if (resolver == null) {
            resolver = new SelectorResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._onChange);
          } else {
            !(resolver instanceof SelectorResolver) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an object.', _key3) : browser$1(false) : void 0;
            resolver.setSelector(ownedSelector);
          }
        }

        this._props[_key3] = props[_key3];
        this._resolvers[_key3] = resolver;
      }
    }

    this._stale = true;
  };

  _proto.setVariables = function setVariables(variables, request) {
    for (var _key4 in this._resolvers) {
      if (this._resolvers.hasOwnProperty(_key4)) {
        var resolver = this._resolvers[_key4];

        if (resolver) {
          resolver.setVariables(variables, request);
        }
      }
    }

    this._stale = true;
  };

  return RelayModernFragmentSpecResolver;
}();
/**
 * A resolver for a single Selector.
 */


var SelectorResolver = /*#__PURE__*/function () {
  function SelectorResolver(environment, rootIsQueryRenderer, selector, callback) {
    var _this2 = this;

    (0, _defineProperty2$3["default"])(this, "_onChange", function (snapshot) {
      _this2._data = snapshot.data;
      _this2._isMissingData = snapshot.isMissingData;
      _this2._missingRequiredFields = snapshot.missingRequiredFields;

      _this2._callback();
    });

    var _snapshot = environment.lookup(selector);

    this._callback = callback;
    this._data = _snapshot.data;
    this._isMissingData = _snapshot.isMissingData;
    this._missingRequiredFields = _snapshot.missingRequiredFields;
    this._environment = environment;
    this._rootIsQueryRenderer = rootIsQueryRenderer;
    this._selector = selector;
    this._subscription = environment.subscribe(_snapshot, this._onChange);
  }

  var _proto2 = SelectorResolver.prototype;

  _proto2.dispose = function dispose() {
    if (this._subscription) {
      this._subscription.dispose();

      this._subscription = null;
    }
  };

  _proto2.resolve = function resolve() {
    if ( this._isMissingData === true) {
      var _getPromiseForActiveR;

      // NOTE: This branch exists to handle the case in which:
      // - A RelayModern container is rendered as a descendant of a Relay Hook
      //   root using a "partial" renderPolicy (this means that eargerly
      //   reading any cached data that is available instead of blocking
      //   at the root until the whole query is fetched).
      // - A parent Relay Hook didnt' suspend earlier on data being fetched,
      //   either because the fragment data for the parent was available, or
      //   the parent fragment didn't have any data dependencies.
      // Even though our Flow types reflect the possiblity of null data, there
      // might still be cases where it's not handled at runtime becuase the
      // Flow types are being ignored, or simply not being used (for example,
      // the case reported here: https://fburl.com/srnbucf8, was due to
      // misuse of Flow types here: https://fburl.com/g3m0mqqh).
      // Additionally, even though the null data might be handled without a
      // runtime error, we might not suspend when we intended to if a parent
      // Relay Hook (e.g. that is using @defer) decided not to suspend becuase
      // it's immediate data was already available (even if it was deferred),
      // or it didn't actually need any data (was just spreading other fragments).
      // This should eventually go away with something like @optional, where we only
      // suspend at specific boundaries depending on whether the boundary
      // can be fulfilled or not.
      var promise = (_getPromiseForActiveR = getPromiseForActiveRequest$1(this._environment, this._selector.owner)) !== null && _getPromiseForActiveR !== void 0 ? _getPromiseForActiveR : this._environment.getOperationTracker().getPromiseForPendingOperationsAffectingOwner(this._selector.owner);

      if (promise != null) {
        if (this._rootIsQueryRenderer) {
          process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Relay Container for fragment `%s` has missing data and ' + 'would suspend. When using features such as @defer or @module, ' + 'use `useFragment` instead of a Relay Container.', this._selector.node.name) : void 0;
        } else {
          process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Relay Container for fragment `%s` suspended. When using ' + 'features such as @defer or @module, use `useFragment` instead ' + 'of a Relay Container.', this._selector.node.name) : void 0;
          throw promise;
        }
      }
    }

    if (this._missingRequiredFields != null) {
      reportMissingRequiredFields_1(this._environment, this._missingRequiredFields);
    }

    return this._data;
  };

  _proto2.setSelector = function setSelector(selector) {
    if (this._subscription != null && areEqualSelectors$1(selector, this._selector)) {
      return;
    }

    this.dispose();

    var snapshot = this._environment.lookup(selector);

    this._data = snapshot.data;
    this._isMissingData = snapshot.isMissingData;
    this._missingRequiredFields = snapshot.missingRequiredFields;
    this._selector = selector;
    this._subscription = this._environment.subscribe(snapshot, this._onChange);
  };

  _proto2.setVariables = function setVariables(variables, request) {
    if (areEqual_1(variables, this._selector.variables)) {
      // If we're not actually setting new variables, we don't actually want
      // to create a new fragment owner, since areEqualSelectors relies on
      // owner identity.
      // In fact, we don't even need to try to attempt to set a new selector.
      // When fragment ownership is not enabled, setSelector will also bail
      // out since the selector doesn't really change, so we're doing it here
      // earlier.
      return;
    } // NOTE: We manually create the request descriptor here instead of
    // calling createOperationDescriptor() because we want to set a
    // descriptor with *unaltered* variables as the fragment owner.
    // This is a hack that allows us to preserve existing (broken)
    // behavior of RelayModern containers while using fragment ownership
    // to propagate variables instead of Context.
    // For more details, see the summary of D13999308


    var requestDescriptor = createRequestDescriptor$1(request, variables);
    var selector = createReaderSelector$2(this._selector.node, this._selector.dataID, variables, requestDescriptor);
    this.setSelector(selector);
  };

  return SelectorResolver;
}();
/**
 * A resolver for an array of Selectors.
 */


var SelectorListResolver = /*#__PURE__*/function () {
  function SelectorListResolver(environment, rootIsQueryRenderer, selector, callback) {
    var _this3 = this;

    (0, _defineProperty2$3["default"])(this, "_onChange", function (data) {
      _this3._stale = true;

      _this3._callback();
    });
    this._callback = callback;
    this._data = [];
    this._environment = environment;
    this._resolvers = [];
    this._stale = true;
    this._rootIsQueryRenderer = rootIsQueryRenderer;
    this.setSelector(selector);
  }

  var _proto3 = SelectorListResolver.prototype;

  _proto3.dispose = function dispose() {
    this._resolvers.forEach(disposeCallback);
  };

  _proto3.resolve = function resolve() {
    if (this._stale) {
      // Avoid mapping the array multiple times, which could occur if data for
      // multiple indices changes in the same event loop.
      var prevData = this._data;
      var nextData;

      for (var ii = 0; ii < this._resolvers.length; ii++) {
        var prevItem = prevData[ii];

        var nextItem = this._resolvers[ii].resolve();

        if (nextData || nextItem !== prevItem) {
          nextData = nextData || prevData.slice(0, ii);
          nextData.push(nextItem);
        }
      }

      if (!nextData && this._resolvers.length !== prevData.length) {
        nextData = prevData.slice(0, this._resolvers.length);
      }

      this._data = nextData || prevData;
      this._stale = false;
    }

    return this._data;
  };

  _proto3.setSelector = function setSelector(selector) {
    var selectors = selector.selectors;

    while (this._resolvers.length > selectors.length) {
      var resolver = this._resolvers.pop();

      resolver.dispose();
    }

    for (var ii = 0; ii < selectors.length; ii++) {
      if (ii < this._resolvers.length) {
        this._resolvers[ii].setSelector(selectors[ii]);
      } else {
        this._resolvers[ii] = new SelectorResolver(this._environment, this._rootIsQueryRenderer, selectors[ii], this._onChange);
      }
    }

    this._stale = true;
  };

  _proto3.setVariables = function setVariables(variables, request) {
    this._resolvers.forEach(function (resolver) {
      return resolver.setVariables(variables, request);
    });

    this._stale = true;
  };

  return SelectorListResolver;
}();

function disposeCallback(disposable) {
  disposable && disposable.dispose();
}

var RelayModernFragmentSpecResolver_1 = RelayModernFragmentSpecResolver;

function createFragmentSpecResolver(context, containerName, fragments, props, rootIsQueryRenderer, callback) {
  if (process$1.env.NODE_ENV !== "production") {
    var fragmentNames = Object.keys(fragments);
    fragmentNames.forEach(function (fragmentName) {
      var propValue = props[fragmentName];
      process$1.env.NODE_ENV !== "production" ? warning_1(propValue !== undefined, 'createFragmentSpecResolver: Expected prop `%s` to be supplied to `%s`, but ' + 'got `undefined`. Pass an explicit `null` if this is intentional.', fragmentName, containerName) : void 0;
    });
  }

  return new RelayModernFragmentSpecResolver_1(context, fragments, props, callback, rootIsQueryRenderer);
}

var createFragmentSpecResolver_1 = createFragmentSpecResolver;

var _objectSpread2$a = interopRequireDefault(objectSpread2);

var getModuleComponentKey$3 = RelayStoreUtils_1.getModuleComponentKey,
    getModuleOperationKey$4 = RelayStoreUtils_1.getModuleOperationKey;

function createPayloadFor3DField(name, operation, component, response) {
  var data = (0, _objectSpread2$a["default"])({}, response);
  data[getModuleComponentKey$3(name)] = component;
  data[getModuleOperationKey$4(name)] = operation;
  return data;
}

var createPayloadFor3DField_1 = createPayloadFor3DField;

var relayContext;
var firstReact;

function createRelayContext(react) {
  if (!relayContext) {
    relayContext = react.createContext(null);

    if (process$1.env.NODE_ENV !== "production") {
      relayContext.displayName = 'RelayContext';
    }

    firstReact = react;
  }

  !(react === firstReact) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, '[createRelayContext]: You passing a different instance of React', react.version) : browser$1(false) : void 0;
  return relayContext;
}

var createRelayContext_1 = createRelayContext;

var _objectSpread2$b = interopRequireDefault(objectSpread2);









var createOperationDescriptor$3 = RelayModernOperationDescriptor.createOperationDescriptor;

var getRequest$3 = GraphQLTag.getRequest;

/**
 * Fetches the given query and variables on the provided environment,
 * and de-dupes identical in-flight requests.
 *
 * Observing a request:
 * ====================
 * fetchQuery returns an Observable which you can call .subscribe()
 * on. Subscribe optionally takes an Observer, which you can provide to
 * observe network events:
 *
 * ```
 * fetchQuery(environment, query, variables).subscribe({
 *   // Called when network requests starts
 *   start: (subsctiption) => {},
 *
 *   // Called after a payload is received and written to the local store
 *   next: (payload) => {},
 *
 *   // Called when network requests errors
 *   error: (error) => {},
 *
 *   // Called when network requests fully completes
 *   complete: () => {},
 *
 *   // Called when network request is unsubscribed
 *   unsubscribe: (subscription) => {},
 * });
 * ```
 *
 * Request Promise:
 * ================
 * The obervable can be converted to a Promise with .toPromise(), which will
 * resolve to a snapshot of the query data when the first response is received
 * from the server.
 *
 * ```
 * fetchQuery(environment, query, variables).toPromise().then((data) => {
 *   // ...
 * });
 * ```
 *
 * In-flight request de-duping:
 * ============================
 * By default, calling fetchQuery multiple times with the same
 * environment, query and variables will not initiate a new request if a request
 * for those same parameters is already in flight.
 *
 * A request is marked in-flight from the moment it starts until the moment it
 * fully completes, regardless of error or successful completion.
 *
 * NOTE: If the request completes _synchronously_, calling fetchQuery
 * a second time with the same arguments in the same tick will _NOT_ de-dupe
 * the request given that it will no longer be in-flight.
 *
 *
 * Data Retention:
 * ===============
 * This function will NOT retain query data, meaning that it is not guaranteed
 * that the fetched data will remain in the Relay store after the request has
 * completed.
 * If you need to retain the query data outside of the network request,
 * you need to use `environment.retain()`.
 *
 *
 * Cancelling requests:
 * ====================
 * If the disposable returned by subscribe is called while the
 * request is in-flight, the request will be cancelled.
 *
 * ```
 * const disposable = fetchQuery(...).subscribe(...);
 *
 * // This will cancel the request if it is in-flight.
 * disposable.dispose();
 * ```
 * NOTE: When using .toPromise(), the request cannot be cancelled.
 */
function fetchQuery$1(environment, query, variables, options) {
  var _options$fetchPolicy;

  var queryNode = getRequest$3(query);
  !(queryNode.params.operationKind === 'query') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'fetchQuery: Expected query operation') : browser$1(false) : void 0;
  var networkCacheConfig = (0, _objectSpread2$b["default"])({
    force: true
  }, options === null || options === void 0 ? void 0 : options.networkCacheConfig);
  var operation = createOperationDescriptor$3(queryNode, variables, networkCacheConfig);
  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'network-only';

  function readData(snapshot) {
    if (snapshot.missingRequiredFields != null) {
      reportMissingRequiredFields_1(environment, snapshot.missingRequiredFields);
    }

    return snapshot.data;
  }

  switch (fetchPolicy) {
    case 'network-only':
      {
        return getNetworkObservable(environment, operation).map(readData);
      }

    case 'store-or-network':
      {
        if (environment.check(operation).status === 'available') {
          return RelayObservable_1.from(environment.lookup(operation.fragment)).map(readData);
        }

        return getNetworkObservable(environment, operation).map(readData);
      }

    default:
      throw new Error('fetchQuery: Invalid fetchPolicy ' + fetchPolicy);
  }
}

function getNetworkObservable(environment, operation) {
  return fetchQueryInternal.fetchQuery(environment, operation).map(function () {
    return environment.lookup(operation.fragment);
  });
}

var fetchQuery_1 = fetchQuery$1;

var createOperationDescriptor$4 = RelayModernOperationDescriptor.createOperationDescriptor;

var getRequest$4 = GraphQLTag.getRequest;

/**
 * A helper function to fetch the results of a query. Note that results for
 * fragment spreads are masked: fields must be explicitly listed in the query in
 * order to be accessible in the result object.
 */
function fetchQuery_DEPRECATED(environment, taggedNode, variables, cacheConfig) {
  var query = getRequest$4(taggedNode);

  if (query.params.operationKind !== 'query') {
    throw new Error('fetchQuery: Expected query operation');
  }

  var operation = createOperationDescriptor$4(query, variables, cacheConfig);
  return environment.execute({
    operation: operation
  }).map(function () {
    return environment.lookup(operation.fragment).data;
  }).toPromise();
}

var fetchQuery_DEPRECATED_1 = fetchQuery_DEPRECATED;

var getDataIDsFromFragment$1 = RelayModernSelector.getDataIDsFromFragment,
    getVariablesFromFragment$1 = RelayModernSelector.getVariablesFromFragment,
    getSelector$2 = RelayModernSelector.getSelector;

function getFragmentIdentifier(fragmentNode, fragmentRef) {
  var selector = getSelector$2(fragmentNode, fragmentRef);
  var fragmentOwnerIdentifier = selector == null ? 'null' : selector.kind === 'SingularReaderSelector' ? selector.owner.identifier : '[' + selector.selectors.map(function (sel) {
    return sel.owner.identifier;
  }).join(',') + ']';
  var fragmentVariables = getVariablesFromFragment$1(fragmentNode, fragmentRef);
  var dataIDs = getDataIDsFromFragment$1(fragmentNode, fragmentRef);

  {
    var _JSON$stringify;

    return fragmentOwnerIdentifier + '/' + fragmentNode.name + '/' + JSON.stringify(stableCopy_1(fragmentVariables)) + '/' + ((_JSON$stringify = JSON.stringify(dataIDs)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'missing');
  }
}

var getFragmentIdentifier_1 = getFragmentIdentifier;

var getInlineDataFragment$1 = GraphQLTag.getInlineDataFragment;

var FRAGMENTS_KEY$2 = RelayStoreUtils_1.FRAGMENTS_KEY;

function readInlineData(fragment, fragmentRef) {
  var _fragmentRef$FRAGMENT;

  var inlineDataFragment = getInlineDataFragment$1(fragment);

  if (fragmentRef == null) {
    return fragmentRef;
  }

  !(typeof fragmentRef === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'readInlineData(): Expected an object, got `%s`.', typeof fragmentRef) : browser$1(false) : void 0; // $FlowFixMe[incompatible-use]

  var inlineData = (_fragmentRef$FRAGMENT = fragmentRef[FRAGMENTS_KEY$2]) === null || _fragmentRef$FRAGMENT === void 0 ? void 0 : _fragmentRef$FRAGMENT[inlineDataFragment.name];
  !(inlineData != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'readInlineData(): Expected fragment `%s` to be spread in the parent ' + 'fragment.', inlineDataFragment.name) : browser$1(false) : void 0;
  return inlineData;
}

var readInlineData_1 = readInlineData;

var getRequest$5 = GraphQLTag.getRequest;

var createOperationDescriptor$5 = RelayModernOperationDescriptor.createOperationDescriptor;

function requestSubscription(environment, config) {
  var subscription = getRequest$5(config.subscription);

  if (subscription.params.operationKind !== 'subscription') {
    throw new Error('requestSubscription: Must use Subscription operation');
  }

  var configs = config.configs,
      onCompleted = config.onCompleted,
      onError = config.onError,
      onNext = config.onNext,
      variables = config.variables,
      cacheConfig = config.cacheConfig;
  var operation = createOperationDescriptor$5(subscription, variables, cacheConfig,  undefined);
  process$1.env.NODE_ENV !== "production" ? warning_1(!(config.updater && configs), 'requestSubscription: Expected only one of `updater` and `configs` to be provided') : void 0;

  var _ref = configs ? RelayDeclarativeMutationConfig.convert(configs, subscription, null
  /* optimisticUpdater */
  , config.updater) : config,
      updater = _ref.updater;

  var sub = environment.execute({
    operation: operation,
    updater: updater
  }).map(function (responses) {
    var selector = operation.fragment;

    var data = environment.lookup(selector).data; // $FlowFixMe[incompatible-cast]

    return data;
  }).subscribe({
    next: onNext,
    error: onError,
    complete: onCompleted
  });
  return {
    dispose: sub.unsubscribe
  };
}

var requestSubscription_1 = requestSubscription;

var generateClientID$6 = ClientID.generateClientID,
    generateUniqueClientID$2 = ClientID.generateUniqueClientID,
    isClientID$4 = ClientID.isClientID;

// As early as possible, check for the existence of the JavaScript globals which
// Relay Runtime relies upon, and produce a clear message if they do not exist.
if (process$1.env.NODE_ENV !== "production") {
  var mapStr = typeof Map !== 'function' ? 'Map' : null;
  var setStr = typeof Set !== 'function' ? 'Set' : null;
  var promiseStr = typeof Promise !== 'function' ? 'Promise' : null;
  var objStr = typeof Object.assign !== 'function' ? 'Object.assign' : null;

  if (mapStr || setStr || promiseStr || objStr) {
    throw new Error("relay-runtime requires ".concat([mapStr, setStr, promiseStr, objStr].filter(Boolean).join(', and '), " to exist. ") + 'Use a polyfill to provide these for older browsers.');
  }
}
/**
 * The public interface to Relay Runtime.
 */


var lib = {
  // Core API
  Environment: RelayModernEnvironment_1,
  Network: RelayNetwork,
  Observable: RelayObservable_1,
  QueryResponseCache: RelayQueryResponseCache_1,
  RecordSource: RelayRecordSource_1,
  Record: RelayModernRecord,
  ReplaySubject: RelayReplaySubject_1,
  Store: RelayModernStore_1,
  areEqualSelectors: RelayModernSelector.areEqualSelectors,
  createFragmentSpecResolver: createFragmentSpecResolver_1,
  createNormalizationSelector: RelayModernSelector.createNormalizationSelector,
  createOperationDescriptor: RelayModernOperationDescriptor.createOperationDescriptor,
  createReaderSelector: RelayModernSelector.createReaderSelector,
  createRequestDescriptor: RelayModernOperationDescriptor.createRequestDescriptor,
  getDataIDsFromFragment: RelayModernSelector.getDataIDsFromFragment,
  getDataIDsFromObject: RelayModernSelector.getDataIDsFromObject,
  getNode: GraphQLTag.getNode,
  getFragment: GraphQLTag.getFragment,
  getInlineDataFragment: GraphQLTag.getInlineDataFragment,
  getModuleComponentKey: RelayStoreUtils_1.getModuleComponentKey,
  getModuleOperationKey: RelayStoreUtils_1.getModuleOperationKey,
  getPaginationFragment: GraphQLTag.getPaginationFragment,
  getPluralSelector: RelayModernSelector.getPluralSelector,
  getRefetchableFragment: GraphQLTag.getRefetchableFragment,
  getRequest: GraphQLTag.getRequest,
  getRequestIdentifier: getRequestIdentifier_1,
  getSelector: RelayModernSelector.getSelector,
  getSelectorsFromObject: RelayModernSelector.getSelectorsFromObject,
  getSingularSelector: RelayModernSelector.getSingularSelector,
  getStorageKey: RelayStoreUtils_1.getStorageKey,
  getVariablesFromFragment: RelayModernSelector.getVariablesFromFragment,
  getVariablesFromObject: RelayModernSelector.getVariablesFromObject,
  getVariablesFromPluralFragment: RelayModernSelector.getVariablesFromPluralFragment,
  getVariablesFromSingularFragment: RelayModernSelector.getVariablesFromSingularFragment,
  reportMissingRequiredFields: reportMissingRequiredFields_1,
  graphql: GraphQLTag.graphql,
  isFragment: GraphQLTag.isFragment,
  isInlineDataFragment: GraphQLTag.isInlineDataFragment,
  isRequest: GraphQLTag.isRequest,
  readInlineData: readInlineData_1,
  // Declarative mutation API
  MutationTypes: RelayDeclarativeMutationConfig.MutationTypes,
  RangeOperations: RelayDeclarativeMutationConfig.RangeOperations,
  // Extensions
  DefaultHandlerProvider: RelayDefaultHandlerProvider_1,
  ConnectionHandler: ConnectionHandler,
  MutationHandlers: MutationHandlers,
  VIEWER_ID: ViewerPattern.VIEWER_ID,
  VIEWER_TYPE: ViewerPattern.VIEWER_TYPE,
  // Helpers (can be implemented via the above API)
  applyOptimisticMutation: applyOptimisticMutation_1,
  commitLocalUpdate: commitLocalUpdate_1,
  commitMutation: commitMutation_1,
  fetchQuery: fetchQuery_1,
  fetchQuery_DEPRECATED: fetchQuery_DEPRECATED_1,
  isRelayModernEnvironment: isRelayModernEnvironment_1,
  requestSubscription: requestSubscription_1,
  // Configuration interface for legacy or special uses
  ConnectionInterface: ConnectionInterface_1,
  // Utilities
  PreloadableQueryRegistry: PreloadableQueryRegistry_1,
  RelayProfiler: RelayProfiler_1,
  createPayloadFor3DField: createPayloadFor3DField_1,
  // INTERNAL-ONLY: These exports might be removed at any point.
  RelayConcreteNode: RelayConcreteNode_1,
  RelayError: RelayError,
  RelayFeatureFlags: RelayFeatureFlags_1,
  DEFAULT_HANDLE_KEY: RelayDefaultHandleKey.DEFAULT_HANDLE_KEY,
  FRAGMENTS_KEY: RelayStoreUtils_1.FRAGMENTS_KEY,
  FRAGMENT_OWNER_KEY: RelayStoreUtils_1.FRAGMENT_OWNER_KEY,
  ID_KEY: RelayStoreUtils_1.ID_KEY,
  REF_KEY: RelayStoreUtils_1.REF_KEY,
  REFS_KEY: RelayStoreUtils_1.REFS_KEY,
  ROOT_ID: RelayStoreUtils_1.ROOT_ID,
  ROOT_TYPE: RelayStoreUtils_1.ROOT_TYPE,
  TYPENAME_KEY: RelayStoreUtils_1.TYPENAME_KEY,
  deepFreeze: deepFreeze_1,
  generateClientID: generateClientID$6,
  generateUniqueClientID: generateUniqueClientID$2,
  getRelayHandleKey: getRelayHandleKey_1,
  isClientID: isClientID$4,
  isPromise: isPromise_1,
  isScalarAndEqual: isScalarAndEqual_1,
  recycleNodesInto: recycleNodesInto_1,
  stableCopy: stableCopy_1,
  getFragmentIdentifier: getFragmentIdentifier_1,
  __internal: {
    OperationTracker: RelayOperationTracker_1,
    createRelayContext: createRelayContext_1,
    getOperationVariables: RelayConcreteVariables.getOperationVariables,
    fetchQuery: fetchQueryInternal.fetchQuery,
    fetchQueryDeduped: fetchQueryInternal.fetchQueryDeduped,
    getPromiseForActiveRequest: fetchQueryInternal.getPromiseForActiveRequest,
    getObservableForActiveRequest: fetchQueryInternal.getObservableForActiveRequest
  }
};

/**
 * Relay v11.0.2
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var relayRuntime = lib;

var createRelayContext$1 = relayRuntime.__internal.createRelayContext;

var ReactRelayContext = createRelayContext$1(React__default['default']);

/**
 * Relay v11.0.2
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactRelayContext$1 = ReactRelayContext;

var useContext = React__default['default'].useContext;

function useRelayEnvironment() {
  var context = useContext(ReactRelayContext$1);
  !(context != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'useRelayEnvironment: Expected to have found a Relay environment provided by ' + 'a `RelayEnvironmentProvider` component. ' + 'This usually means that useRelayEnvironment was used in a ' + 'component that is not a descendant of a `RelayEnvironmentProvider`. ' + 'Please make sure a `RelayEnvironmentProvider` has been rendered somewhere ' + 'as a parent or ancestor of your component.') : browser$1(false) : void 0;
  return context.environment;
}

var useRelayEnvironment_1 = useRelayEnvironment;

var _require$1 = React__default['default'],
    useContext$1 = _require$1.useContext,
    useEffect = _require$1.useEffect;

function EntryPointContainer(_ref) {
  var entryPointReference = _ref.entryPointReference,
      props = _ref.props;
  process$1.env.NODE_ENV !== "production" ? warning_1(entryPointReference.isDisposed === false, '<EntryPointContainer>: Expected entryPointReference to not be disposed ' + 'yet. This is because disposing the entrypoint marks it for future garbage ' + 'collection, and as such may no longer be present in the Relay store. ' + 'In the future, this will become a hard error.') : void 0;
  var getComponent = entryPointReference.getComponent,
      queries = entryPointReference.queries,
      entryPoints = entryPointReference.entryPoints,
      extraProps = entryPointReference.extraProps,
      rootModuleID = entryPointReference.rootModuleID;
  var Component = getComponent();
  var profilerContext = useContext$1(ProfilerContext_1);
  var environment = useRelayEnvironment_1();
  useEffect(function () {
    environment.__log({
      name: 'entrypoint.root.consume',
      profilerContext: profilerContext,
      rootModuleID: rootModuleID
    });
  }, [environment, profilerContext, rootModuleID]);
  return /*#__PURE__*/React__default['default'].createElement(Component, {
    entryPoints: entryPoints,
    extraProps: extraProps,
    props: props,
    queries: queries
  });
}

var EntryPointContainer_react = EntryPointContainer;

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var assertThisInitialized = _assertThisInitialized;

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var inheritsLoose = _inheritsLoose;

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

var ReactRelayQueryRendererContext = React__default['default'].createContext({
  rootIsQueryRenderer: false
});

/**
 * Fail fast if the user supplies invalid fragments as input.
 */
function assertFragmentMap(componentName, fragmentSpec) {
  !(fragmentSpec && typeof fragmentSpec === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Could not create Relay Container for `%s`. ' + 'Expected a set of GraphQL fragments, got `%s` instead.', componentName, fragmentSpec) : browser$1(false) : void 0;

  for (var key in fragmentSpec) {
    if (fragmentSpec.hasOwnProperty(key)) {
      var fragment = fragmentSpec[key];
      !(fragment && (typeof fragment === 'object' || typeof fragment === 'function')) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Could not create Relay Container for `%s`. ' + 'The value of fragment `%s` was expected to be a fragment, got `%s` instead.', componentName, key, fragment) : browser$1(false) : void 0;
    }
  }
}

var assertFragmentMap_1 = assertFragmentMap;

var _React$__SECRET_INTER =
/* $FlowFixMe[prop-missing] Flow doesn't know about React's internals for
 * good reason, but for now, Relay needs the dispatcher to read context. */
React__default['default'].__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    ReactCurrentDispatcher = _React$__SECRET_INTER.ReactCurrentDispatcher,
    ReactCurrentOwner = _React$__SECRET_INTER.ReactCurrentOwner;

function readContext(Context) {
  var dispatcher = ReactCurrentDispatcher != null ? ReactCurrentDispatcher.current : ReactCurrentOwner.currentDispatcher;
  return dispatcher.readContext(Context);
}

var readContext_1 = readContext;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

function getComponentName(component) {
  return component.displayName || component.name || 'Component';
}

function getContainerName(Component) {
  return 'Relay(' + getComponentName(Component) + ')';
}

var ReactRelayContainerUtils = {
  getComponentName: getComponentName,
  getContainerName: getContainerName
};

var _extends2 = interopRequireDefault(_extends_1);













var getComponentName$1 = ReactRelayContainerUtils.getComponentName,
    getContainerName$1 = ReactRelayContainerUtils.getContainerName;

var getFragment$2 = relayRuntime.getFragment;

/**
 * Helper to create the Relay HOCs with ref forwarding, setting the displayName
 * and reading the React context.
 */
function buildReactRelayContainer(ComponentClass, fragmentSpec, createContainerWithFragments) {
  // Sanity-check user-defined fragment input
  var containerName = getContainerName$1(ComponentClass);
  assertFragmentMap_1(getComponentName$1(ComponentClass), fragmentSpec);
  var fragments = {};

  for (var key in fragmentSpec) {
    fragments[key] = getFragment$2(fragmentSpec[key]);
  }

  var Container = createContainerWithFragments(ComponentClass, fragments);
  Container.displayName = containerName;

  function forwardRef(props, ref) {
    var _queryRendererContext;

    var context = readContext_1(ReactRelayContext);
    !(context != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, '`%s` tried to render a context that was not valid this means that ' + '`%s` was rendered outside of a query renderer.', containerName, containerName) : browser$1(false) : void 0;
    var queryRendererContext = readContext_1(ReactRelayQueryRendererContext);
    return /*#__PURE__*/React__default['default'].createElement(Container, (0, _extends2["default"])({}, props, {
      __relayContext: context,
      __rootIsQueryRenderer: (_queryRendererContext = queryRendererContext === null || queryRendererContext === void 0 ? void 0 : queryRendererContext.rootIsQueryRenderer) !== null && _queryRendererContext !== void 0 ? _queryRendererContext : false,
      componentRef: props.componentRef || ref
    }));
  }

  forwardRef.displayName = containerName;
  var ForwardContainer = React__default['default'].forwardRef(forwardRef);

  if (process$1.env.NODE_ENV !== "production") {
    // Used by RelayModernTestUtils
    ForwardContainer.__ComponentClass = ComponentClass;
    ForwardContainer.displayName = containerName;
  } // $FlowFixMe[incompatible-return]


  return ForwardContainer;
}

var buildReactRelayContainer_1 = buildReactRelayContainer;

var _objectSpread2$c = interopRequireDefault(objectSpread2);

var getSelector$3 = relayRuntime.getSelector;

function getRootVariablesForFragments(fragments, props) {
  var rootVariables = {}; // NOTE: For extra safety, we make sure the rootVariables include the
  // variables from all owners in this fragmentSpec, even though they
  // should all point to the same owner

  Object.keys(fragments).forEach(function (key) {
    var _selector$selectors$, _selector$selectors$2, _selector$owner$varia;

    var fragmentNode = fragments[key];
    var fragmentRef = props[key];
    var selector = getSelector$3(fragmentNode, fragmentRef);
    var fragmentOwnerVariables = selector != null && selector.kind === 'PluralReaderSelector' ? (_selector$selectors$ = (_selector$selectors$2 = selector.selectors[0]) === null || _selector$selectors$2 === void 0 ? void 0 : _selector$selectors$2.owner.variables) !== null && _selector$selectors$ !== void 0 ? _selector$selectors$ : {} : (_selector$owner$varia = selector === null || selector === void 0 ? void 0 : selector.owner.variables) !== null && _selector$owner$varia !== void 0 ? _selector$owner$varia : {}; // $FlowFixMe[cannot-spread-interface]

    rootVariables = (0, _objectSpread2$c["default"])((0, _objectSpread2$c["default"])({}, rootVariables), fragmentOwnerVariables);
  });
  return rootVariables;
}

var getRootVariablesForFragments_1 = getRootVariablesForFragments;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
/**
 * Determine if a given value is an object that implements the `Environment`
 * interface defined in `RelayEnvironmentTypes`.
 */

function isRelayEnvironment(environment) {
  return typeof environment === 'object' && environment !== null && // TODO: add applyMutation/sendMutation once ready in both cores
  typeof environment.check === 'function' && typeof environment.lookup === 'function' && typeof environment.retain === 'function' && typeof environment.execute === 'function' && typeof environment.subscribe === 'function';
}

var isRelayEnvironment_1 = isRelayEnvironment;

/**
 * Asserts that the input is a matches the `RelayContext` type defined in
 * `RelayEnvironmentTypes` and returns it as that type.
 */
function assertRelayContext(relay) {
  !isRelayContext(relay) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'RelayContext: Expected `context.relay` to be an object conforming to ' + 'the `RelayContext` interface, got `%s`.', relay) : browser$1(false) : void 0;
  return relay;
}
/**
 * Determine if the input is a plain object that matches the `RelayContext`
 * type defined in `RelayEnvironmentTypes`.
 */


function isRelayContext(context) {
  return typeof context === 'object' && context !== null && !Array.isArray(context) && isRelayEnvironment_1(context.environment);
}

var RelayContext = {
  assertRelayContext: assertRelayContext,
  isRelayContext: isRelayContext
};

var _objectSpread2$d = interopRequireDefault(objectSpread2);

var _objectWithoutPropertiesLoose2 = interopRequireDefault(objectWithoutPropertiesLoose);

var _assertThisInitialized2 = interopRequireDefault(assertThisInitialized);

var _inheritsLoose2 = interopRequireDefault(inheritsLoose);

var _defineProperty2$4 = interopRequireDefault(defineProperty);









var getContainerName$2 = ReactRelayContainerUtils.getContainerName;

var assertRelayContext$1 = RelayContext.assertRelayContext;

var createFragmentSpecResolver$1 = relayRuntime.createFragmentSpecResolver,
    getDataIDsFromObject$1 = relayRuntime.getDataIDsFromObject,
    isScalarAndEqual$1 = relayRuntime.isScalarAndEqual;

/**
 * Composes a React component class, returning a new class that intercepts
 * props, resolving them with the provided fragments and subscribing for
 * updates.
 */
function createContainerWithFragments(Component, fragments) {
  var _class, _temp;

  var containerName = getContainerName$2(Component);
  return _temp = _class = /*#__PURE__*/function (_React$Component) {
    (0, _inheritsLoose2["default"])(_class, _React$Component);

    function _class(props) {
      var _props$__rootIsQueryR, _this;

      _this = _React$Component.call(this, props) || this;
      (0, _defineProperty2$4["default"])((0, _assertThisInitialized2["default"])(_this), "_handleFragmentDataUpdate", function () {
        var resolverFromThisUpdate = _this.state.resolver;

        _this.setState(function (updatedState) {
          return (// If this event belongs to the current data source, update.
            // Otherwise we should ignore it.
            resolverFromThisUpdate === updatedState.resolver ? {
              data: updatedState.resolver.resolve(),
              relayProp: getRelayProp(updatedState.relayProp.environment)
            } : null
          );
        });
      });
      var relayContext = assertRelayContext$1(props.__relayContext);
      var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false; // Do not provide a subscription/callback here.
      // It is possible for this render to be interrupted or aborted,
      // In which case the subscription would cause a leak.
      // We will add the subscription in componentDidMount().

      var resolver = createFragmentSpecResolver$1(relayContext, containerName, fragments, props, rootIsQueryRenderer);
      _this.state = {
        data: resolver.resolve(),
        prevProps: props,
        prevPropsContext: relayContext,
        relayProp: getRelayProp(relayContext.environment),
        resolver: resolver
      };
      return _this;
    }
    /**
     * When new props are received, read data for the new props and subscribe
     * for updates. Props may be the same in which case previous data and
     * subscriptions can be reused.
     */


    _class.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$__rootIsQu;

      // Any props change could impact the query, so we mirror props in state.
      // This is an unusual pattern, but necessary for this container usecase.
      var prevProps = prevState.prevProps;
      var relayContext = assertRelayContext$1(nextProps.__relayContext);
      var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;
      var prevIDs = getDataIDsFromObject$1(fragments, prevProps);
      var nextIDs = getDataIDsFromObject$1(fragments, nextProps);
      var resolver = prevState.resolver; // If the environment has changed or props point to new records then
      // previously fetched data and any pending fetches no longer apply:
      // - Existing references are on the old environment.
      // - Existing references are based on old variables.
      // - Pending fetches are for the previous records.

      if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual_1(prevIDs, nextIDs)) {
        // Do not provide a subscription/callback here.
        // It is possible for this render to be interrupted or aborted,
        // In which case the subscription would cause a leak.
        // We will add the subscription in componentDidUpdate().
        resolver = createFragmentSpecResolver$1(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);
        return {
          data: resolver.resolve(),
          prevPropsContext: relayContext,
          prevProps: nextProps,
          relayProp: getRelayProp(relayContext.environment),
          resolver: resolver
        };
      } else {
        resolver.setProps(nextProps);
        var data = resolver.resolve();

        if (data !== prevState.data) {
          return {
            data: data,
            prevProps: nextProps,
            prevPropsContext: relayContext,
            relayProp: getRelayProp(relayContext.environment)
          };
        }
      }

      return null;
    };

    var _proto = _class.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this._subscribeToNewResolver();

      this._rerenderIfStoreHasChanged();
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      if (this.state.resolver !== prevState.resolver) {
        prevState.resolver.dispose();

        this._subscribeToNewResolver();
      }

      this._rerenderIfStoreHasChanged();
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.state.resolver.dispose();
    };

    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
      // Short-circuit if any Relay-related data has changed
      if (nextState.data !== this.state.data) {
        return true;
      } // Otherwise, for convenience short-circuit if all non-Relay props
      // are scalar and equal


      var keys = Object.keys(nextProps);

      for (var ii = 0; ii < keys.length; ii++) {
        var _key = keys[ii];

        if (_key === '__relayContext') {
          if (nextState.prevPropsContext.environment !== this.state.prevPropsContext.environment) {
            return true;
          }
        } else {
          if (!fragments.hasOwnProperty(_key) && !isScalarAndEqual$1(nextProps[_key], this.props[_key])) {
            return true;
          }
        }
      }

      return false;
    }
    /**
     * Render new data for the existing props/context.
     */
    ;

    _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {
      var _this$state = this.state,
          data = _this$state.data,
          resolver = _this$state.resolver; // External values could change between render and commit.
      // Check for this case, even though it requires an extra store read.

      var maybeNewData = resolver.resolve();

      if (data !== maybeNewData) {
        this.setState({
          data: maybeNewData
        });
      }
    };

    _proto._subscribeToNewResolver = function _subscribeToNewResolver() {
      var resolver = this.state.resolver; // Event listeners are only safe to add during the commit phase,
      // So they won't leak if render is interrupted or errors.

      resolver.setCallback(this._handleFragmentDataUpdate);
    };

    _proto.render = function render() {
      var _this$props = this.props,
          componentRef = _this$props.componentRef,
          __relayContext = _this$props.__relayContext,
          __rootIsQueryRenderer = _this$props.__rootIsQueryRenderer,
          props = (0, _objectWithoutPropertiesLoose2["default"])(_this$props, ["componentRef", "__relayContext", "__rootIsQueryRenderer"]);
      return React__default['default'].createElement(Component, (0, _objectSpread2$d["default"])((0, _objectSpread2$d["default"])((0, _objectSpread2$d["default"])({}, props), this.state.data), {}, {
        ref: componentRef,
        relay: this.state.relayProp
      }));
    };

    return _class;
  }(React__default['default'].Component), (0, _defineProperty2$4["default"])(_class, "displayName", containerName), _temp;
}

function getRelayProp(environment) {
  return {
    environment: environment
  };
}
/**
 * Wrap the basic `createContainer()` function with logic to adapt to the
 * `context.relay.environment` in which it is rendered. Specifically, the
 * extraction of the environment-specific version of fragments in the
 * `fragmentSpec` is memoized once per environment, rather than once per
 * instance of the container constructed/rendered.
 */


function createContainer(Component, fragmentSpec) {
  // $FlowFixMe[incompatible-return]
  return buildReactRelayContainer_1(Component, fragmentSpec, createContainerWithFragments);
}

var ReactRelayFragmentContainer = {
  createContainer: createContainer
};

var useLayoutEffect = React__default['default'].useLayoutEffect,
    useState = React__default['default'].useState,
    useRef = React__default['default'].useRef,
    useMemo = React__default['default'].useMemo;

var createOperationDescriptor$6 = relayRuntime.createOperationDescriptor,
    deepFreeze$1 = relayRuntime.deepFreeze,
    getRequest$6 = relayRuntime.getRequest;



var queryRendererContext = {
  rootIsQueryRenderer: true
};

function useDeepCompare(value) {
  var latestValue = React__default['default'].useRef(value);

  if (!areEqual_1(latestValue.current, value)) {
    if (process$1.env.NODE_ENV !== "production") {
      deepFreeze$1(value);
    }

    latestValue.current = value;
  }

  return latestValue.current;
}

function ReactRelayLocalQueryRenderer(props) {
  var environment = props.environment,
      query = props.query,
      variables = props.variables,
      render = props.render;
  var latestVariables = useDeepCompare(variables);
  var operation = useMemo(function () {
    var request = getRequest$6(query);
    return createOperationDescriptor$6(request, latestVariables);
  }, [query, latestVariables]);
  var relayContext = useMemo(function () {
    return {
      environment: environment
    };
  }, [environment]); // Use a ref to prevent rendering twice when data changes
  // because of props change

  var dataRef = useRef(null);

  var _useState = useState(null),
      forceUpdate = _useState[1];

  var cleanupFnRef = useRef(null);
  var snapshot = useMemo(function () {
    environment.check(operation);
    var res = environment.lookup(operation.fragment);
    dataRef.current = res.data; // Run effects here so that the data can be retained
    // and subscribed before the component commits

    var retainDisposable = environment.retain(operation);
    var subscribeDisposable = environment.subscribe(res, function (newSnapshot) {
      dataRef.current = newSnapshot.data;
      forceUpdate(dataRef.current);
    });
    var disposed = false;

    function nextCleanupFn() {
      if (!disposed) {
        disposed = true;
        cleanupFnRef.current = null;
        retainDisposable.dispose();
        subscribeDisposable.dispose();
      }
    }

    if (cleanupFnRef.current) {
      cleanupFnRef.current();
    }

    cleanupFnRef.current = nextCleanupFn;
    return res;
  }, [environment, operation]);
  useLayoutEffect(function () {
    var cleanupFn = cleanupFnRef.current;
    return function () {
      cleanupFn && cleanupFn();
    };
  }, [snapshot]);
  return /*#__PURE__*/React__default['default'].createElement(ReactRelayContext.Provider, {
    value: relayContext
  }, /*#__PURE__*/React__default['default'].createElement(ReactRelayQueryRendererContext.Provider, {
    value: queryRendererContext
  }, render({
    props: dataRef.current
  })));
}

var ReactRelayLocalQueryRenderer_1 = ReactRelayLocalQueryRenderer;

var _defineProperty2$5 = interopRequireDefault(defineProperty);



var createOperationDescriptor$7 = relayRuntime.createOperationDescriptor,
    isRelayModernEnvironment$1 = relayRuntime.isRelayModernEnvironment,
    fetchQuery$2 = relayRuntime.__internal.fetchQuery;

var ReactRelayQueryFetcher = /*#__PURE__*/function () {
  function ReactRelayQueryFetcher(args) {
    (0, _defineProperty2$5["default"])(this, "_selectionReferences", []);
    (0, _defineProperty2$5["default"])(this, "_callOnDataChangeWhenSet", false);

    if (args != null) {
      this._cacheSelectionReference = args.cacheSelectionReference;
      this._selectionReferences = args.selectionReferences;
    }
  }

  var _proto = ReactRelayQueryFetcher.prototype;

  _proto.getSelectionReferences = function getSelectionReferences() {
    return {
      cacheSelectionReference: this._cacheSelectionReference,
      selectionReferences: this._selectionReferences
    };
  };

  _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {
    if (fetchPolicy === 'store-and-network' || fetchPolicy === 'store-or-network') {
      if (environment.check(operation).status === 'available') {
        this._retainCachedOperation(environment, operation);

        return environment.lookup(operation.fragment);
      }
    }

    return null;
  };

  _proto.execute = function execute(_ref) {
    var _this = this;

    var environment = _ref.environment,
        operation = _ref.operation,
        _ref$preservePrevious = _ref.preservePreviousReferences,
        preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;
    var reference = environment.retain(operation);

    var error = function error() {
      // We may have partially fulfilled the request, so let the next request
      // or the unmount dispose of the references.
      _this._selectionReferences = _this._selectionReferences.concat(reference);
    };

    var complete = function complete() {
      if (!preservePreviousReferences) {
        _this.disposeSelectionReferences();
      }

      _this._selectionReferences = _this._selectionReferences.concat(reference);
    };

    var unsubscribe = function unsubscribe() {
      // Let the next request or the unmount code dispose of the references.
      // We may have partially fulfilled the request.
      _this._selectionReferences = _this._selectionReferences.concat(reference);
    };

    if (!isRelayModernEnvironment$1(environment)) {
      return environment.execute({
        operation: operation
      })["do"]({
        error: error,
        complete: complete,
        unsubscribe: unsubscribe
      });
    }

    return fetchQuery$2(environment, operation)["do"]({
      error: error,
      complete: complete,
      unsubscribe: unsubscribe
    });
  };

  _proto.setOnDataChange = function setOnDataChange(onDataChange) {
    !this._fetchOptions ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : browser$1(false) : void 0;

    if (typeof onDataChange === 'function') {
      // Mutate the most recent fetchOptions in place,
      // So that in-progress requests can access the updated callback.
      this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];

      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);

      if (this._callOnDataChangeWhenSet) {
        // We don't reset '_callOnDataChangeWhenSet' because another callback may be set
        if (this._error != null) {
          onDataChange({
            error: this._error
          });
        } else if (this._snapshot != null) {
          onDataChange({
            snapshot: this._snapshot
          });
        }
      }
    }
  }
  /**
   * `fetch` fetches the data for the given operation.
   * If a result is immediately available synchronously, it will be synchronously
   * returned by this function.
   *
   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.
   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),
   * and then subsequently whenever the data changes.
   */
  ;

  _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {
    var _this2 = this;

    var environment = fetchOptions.environment,
        operation = fetchOptions.operation,
        onDataChange = fetchOptions.onDataChange;
    var fetchHasReturned = false;

    var _error;

    this.disposeRequest();
    var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;
    this._fetchOptions = {
      environment: environment,
      onDataChangeCallbacks: oldOnDataChangeCallbacks || [],
      operation: operation
    };

    if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {
      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);
    }

    var operationOverride = cacheConfigOverride ? createOperationDescriptor$7(operation.request.node, operation.request.variables, cacheConfigOverride) : operation;
    var request = this.execute({
      environment: environment,
      operation: operationOverride
    })["finally"](function () {
      _this2._pendingRequest = null;
    }).subscribe({
      next: function next() {
        // If we received a response,
        // Make a note that to notify the callback when it's later added.
        _this2._callOnDataChangeWhenSet = true;
        _this2._error = null; // Only notify of the first result if `next` is being called **asynchronously**
        // (i.e. after `fetch` has returned).

        _this2._onQueryDataAvailable({
          notifyFirstResult: fetchHasReturned
        });
      },
      error: function error(err) {
        // If we received a response when we didn't have a change callback,
        // Make a note that to notify the callback when it's later added.
        _this2._callOnDataChangeWhenSet = true;
        _this2._error = err;
        _this2._snapshot = null;
        var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks; // Only notify of error if `error` is being called **asynchronously**
        // (i.e. after `fetch` has returned).

        if (fetchHasReturned) {
          if (onDataChangeCallbacks) {
            onDataChangeCallbacks.forEach(function (onDataChange) {
              onDataChange({
                error: err
              });
            });
          }
        } else {
          _error = err;
        }
      }
    });
    this._pendingRequest = {
      dispose: function dispose() {
        request.unsubscribe();
      }
    };
    fetchHasReturned = true;

    if (_error) {
      throw _error;
    }

    return this._snapshot;
  };

  _proto.retry = function retry(cacheConfigOverride) {
    !this._fetchOptions ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : browser$1(false) : void 0;
    return this.fetch({
      environment: this._fetchOptions.environment,
      operation: this._fetchOptions.operation,
      onDataChange: null // If there are onDataChangeCallbacks they will be reused

    }, cacheConfigOverride);
  };

  _proto.dispose = function dispose() {
    this.disposeRequest();
    this.disposeSelectionReferences();
  };

  _proto.disposeRequest = function disposeRequest() {
    this._error = null;
    this._snapshot = null; // order is important, dispose of pendingFetch before selectionReferences

    if (this._pendingRequest) {
      this._pendingRequest.dispose();
    }

    if (this._rootSubscription) {
      this._rootSubscription.dispose();

      this._rootSubscription = null;
    }
  };

  _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {
    this._disposeCacheSelectionReference();

    this._cacheSelectionReference = environment.retain(operation);
  };

  _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {
    this._cacheSelectionReference && this._cacheSelectionReference.dispose();
    this._cacheSelectionReference = null;
  };

  _proto.disposeSelectionReferences = function disposeSelectionReferences() {
    this._disposeCacheSelectionReference();

    this._selectionReferences.forEach(function (r) {
      return r.dispose();
    });

    this._selectionReferences = [];
  };

  _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {
    var _this3 = this;

    var notifyFirstResult = _ref2.notifyFirstResult;
    !this._fetchOptions ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : browser$1(false) : void 0;
    var _this$_fetchOptions = this._fetchOptions,
        environment = _this$_fetchOptions.environment,
        onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks,
        operation = _this$_fetchOptions.operation; // `_onQueryDataAvailable` can be called synchronously the first time and can be called
    // multiple times by network layers that support data subscriptions.
    // Wait until the first payload to call `onDataChange` and subscribe for data updates.

    if (this._snapshot) {
      return;
    }

    this._snapshot = environment.lookup(operation.fragment); // Subscribe to changes in the data of the root fragment

    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {
      // Read from this._fetchOptions in case onDataChange() was lazily added.
      if (_this3._fetchOptions != null) {
        var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;

        if (Array.isArray(maybeNewOnDataChangeCallbacks)) {
          maybeNewOnDataChangeCallbacks.forEach(function (onDataChange) {
            return onDataChange({
              snapshot: snapshot
            });
          });
        }
      }
    });

    if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {
      var snapshot = this._snapshot;
      onDataChangeCallbacks.forEach(function (onDataChange) {
        return onDataChange({
          snapshot: snapshot
        });
      });
    }
  };

  return ReactRelayQueryFetcher;
}();

var ReactRelayQueryFetcher_1 = ReactRelayQueryFetcher;

var _extends2$1 = interopRequireDefault(_extends_1);

var _objectWithoutPropertiesLoose2$1 = interopRequireDefault(objectWithoutPropertiesLoose);

var _assertThisInitialized2$1 = interopRequireDefault(assertThisInitialized);

var _inheritsLoose2$1 = interopRequireDefault(inheritsLoose);

var _defineProperty2$6 = interopRequireDefault(defineProperty);

var _objectSpread3 = interopRequireDefault(objectSpread2);

















var getComponentName$2 = ReactRelayContainerUtils.getComponentName,
    getContainerName$3 = ReactRelayContainerUtils.getContainerName;

var assertRelayContext$2 = RelayContext.assertRelayContext;

var ConnectionInterface$1 = relayRuntime.ConnectionInterface,
    Observable = relayRuntime.Observable,
    createFragmentSpecResolver$2 = relayRuntime.createFragmentSpecResolver,
    createOperationDescriptor$8 = relayRuntime.createOperationDescriptor,
    getDataIDsFromObject$2 = relayRuntime.getDataIDsFromObject,
    getRequest$7 = relayRuntime.getRequest,
    getVariablesFromObject$1 = relayRuntime.getVariablesFromObject,
    isScalarAndEqual$2 = relayRuntime.isScalarAndEqual;

var FORWARD = 'forward';

/**
 * Extends the functionality of RelayFragmentContainer by providing a mechanism
 * to load more data from a connection.
 *
 * # Configuring a PaginationContainer
 *
 * PaginationContainer accepts the standard FragmentContainer arguments and an
 * additional `connectionConfig` argument:
 *
 * - `Component`: the component to be wrapped/rendered.
 * - `fragments`: an object whose values are `graphql` fragments. The object
 *   keys determine the prop names by which fragment data is available.
 * - `connectionConfig`: an object that determines how to load more connection
 *   data. Details below.
 *
 * # Loading More Data
 *
 * Use `props.relay.hasMore()` to determine if there are more items to load.
 *
 * ```
 * hasMore(): boolean
 * ```
 *
 * Use `props.relay.isLoading()` to determine if a previous call to `loadMore()`
 * is still pending. This is convenient for avoiding duplicate load calls.
 *
 * ```
 * isLoading(): boolean
 * ```
 *
 * Use `props.relay.loadMore()` to load more items. This will return null if
 * there are no more items to fetch, otherwise it will fetch more items and
 * return a Disposable that can be used to cancel the fetch.
 *
 * `pageSize` should be the number of *additional* items to fetch (not the
 * total).
 *
 * ```
 * loadMore(pageSize: number, callback: ?(error: ?Error) => void): ?Disposable
 * ```
 *
 * A complete example:
 *
 * ```
 * class Foo extends React.Component {
 *   ...
 *   _onEndReached() {
 *     if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {
 *       return;
 *     }
 *     this.props.relay.loadMore(10);
 *   }
 *   ...
 * }
 * ```
 *
 * # Connection Config
 *
 * Here's an example, followed by details of each config property:
 *
 * ```
 * ReactRelayPaginationContainer.createContainer(
 *   Component,
 *   {
 *     user: graphql`fragment FriendsFragment on User {
 *       friends(after: $afterCursor first: $count) @connection {
 *         edges { ... }
 *         pageInfo {
 *           startCursor
 *           endCursor
 *           hasNextPage
 *           hasPreviousPage
 *         }
 *       }
 *     }`,
 *   },
 *   {
 *     direction: 'forward',
 *     getConnectionFromProps(props) {
 *       return props.user && props.user.friends;
 *     },
 *     getFragmentVariables(vars, totalCount) {
 *       // The component presumably wants *all* edges, not just those after
 *       // the cursor, so notice that we don't set $afterCursor here.
 *       return {
 *         ...vars,
 *         count: totalCount,
 *       };
 *     },
 *     getVariables(props, {count, cursor}, fragmentVariables) {
 *       return {
 *         id: props.user.id,
 *         afterCursor: cursor,
 *         count,
 *       },
 *     },
 *     query: graphql`
 *       query FriendsQuery($id: ID!, $afterCursor: ID, $count: Int!) {
 *         node(id: $id) {
 *           ...FriendsFragment
 *         }
 *       }
 *     `,
 *   }
 * );
 * ```
 *
 * ## Config Properties
 *
 * - `direction`: Either "forward" to indicate forward pagination using
 *   after/first, or "backward" to indicate backward pagination using
 *   before/last.
 * - `getConnectionFromProps(props)`: PaginationContainer doesn't magically know
 *   which connection data you mean to fetch more of (a container might fetch
 *   multiple connections, but can only paginate one of them). This function is
 *   given the fragment props only (not full props), and should return the
 *   connection data. See the above example that returns the friends data via
 *   `props.user.friends`.
 * - `getFragmentVariables(previousVars, totalCount)`: Given the previous variables
 *   and the new total number of items, get the variables to use when reading
 *   your fragments. Typically this means setting whatever your local "count"
 *   variable is to the value of `totalCount`. See the example.
 * - `getVariables(props, {count, cursor})`: Get the variables to use when
 *   fetching the pagination `query`. You may determine the root object id from
 *   props (see the example that uses `props.user.id`) and may also set whatever
 *   variables you use for the after/first/before/last calls based on the count
 *   and cursor.
 * - `query`: A query to use when fetching more connection data. This should
 *   typically reference one of the container's fragment (as in the example)
 *   to ensure that all the necessary fields for sub-components are fetched.
 */
function createGetConnectionFromProps(metadata) {
  var path = metadata.path;
  !path ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getConnectionFromProps function.') : browser$1(false) : void 0;
  return function (props) {
    var data = props[metadata.fragmentName];

    for (var i = 0; i < path.length; i++) {
      if (!data || typeof data !== 'object') {
        return null;
      }

      data = data[path[i]];
    }

    return data;
  };
}

function createGetFragmentVariables(metadata) {
  var countVariable = metadata.count;
  !countVariable ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getFragmentVariables function.') : browser$1(false) : void 0; // $FlowFixMe[cannot-spread-interface]

  return function (prevVars, totalCount) {
    return (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, prevVars), {}, (0, _defineProperty2$6["default"])({}, countVariable, totalCount));
  };
}

function findConnectionMetadata(fragments) {
  var foundConnectionMetadata = null;
  var isRelayModern = false;

  for (var fragmentName in fragments) {
    var fragment = fragments[fragmentName];
    var connectionMetadata = fragment.metadata && fragment.metadata.connection; // HACK: metadata is always set to `undefined` in classic. In modern, even
    // if empty, it is set to null (never undefined). We use that knowlege to
    // check if we're dealing with classic or modern

    if (fragment.metadata !== undefined) {
      isRelayModern = true;
    }

    if (connectionMetadata) {
      !(connectionMetadata.length === 1) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: Only a single @connection is ' + 'supported, `%s` has %s.', fragmentName, connectionMetadata.length) : browser$1(false) : void 0;
      !!foundConnectionMetadata ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: Only a single fragment with ' + '@connection is supported.') : browser$1(false) : void 0;
      foundConnectionMetadata = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, connectionMetadata[0]), {}, {
        fragmentName: fragmentName
      });
    }
  }

  !(!isRelayModern || foundConnectionMetadata !== null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: A @connection directive must be present.') : browser$1(false) : void 0;
  return foundConnectionMetadata || {};
}

function toObserver(observerOrCallback) {
  return typeof observerOrCallback === 'function' ? {
    error: observerOrCallback,
    complete: observerOrCallback,
    unsubscribe: function unsubscribe(subscription) {
      typeof observerOrCallback === 'function' && observerOrCallback();
    }
  } : observerOrCallback || {};
}

function createContainerWithFragments$1(Component, fragments, connectionConfig) {
  var _class, _temp;

  var componentName = getComponentName$2(Component);
  var containerName = getContainerName$3(Component);
  var metadata = findConnectionMetadata(fragments);
  var getConnectionFromProps = connectionConfig.getConnectionFromProps || createGetConnectionFromProps(metadata);
  var direction = connectionConfig.direction || metadata.direction;
  !direction ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: Unable to infer direction of the ' + 'connection, possibly because both first and last are provided.') : browser$1(false) : void 0;
  var getFragmentVariables = connectionConfig.getFragmentVariables || createGetFragmentVariables(metadata);
  return _temp = _class = /*#__PURE__*/function (_React$Component) {
    (0, _inheritsLoose2$1["default"])(_class, _React$Component);

    function _class(props) {
      var _props$__rootIsQueryR, _this;

      _this = _React$Component.call(this, props) || this;
      (0, _defineProperty2$6["default"])((0, _assertThisInitialized2$1["default"])(_this), "_handleFragmentDataUpdate", function () {
        _this.setState({
          data: _this._resolver.resolve()
        });
      });
      (0, _defineProperty2$6["default"])((0, _assertThisInitialized2$1["default"])(_this), "_hasMore", function () {
        var connectionData = _this._getConnectionData();

        return !!(connectionData && connectionData.hasMore && connectionData.cursor);
      });
      (0, _defineProperty2$6["default"])((0, _assertThisInitialized2$1["default"])(_this), "_isLoading", function () {
        return !!_this._refetchSubscription;
      });
      (0, _defineProperty2$6["default"])((0, _assertThisInitialized2$1["default"])(_this), "_refetchConnection", function (totalCount, observerOrCallback, refetchVariables) {
        if (!_this._canFetchPage('refetchConnection')) {
          return {
            dispose: function dispose() {}
          };
        }

        _this._refetchVariables = refetchVariables;
        var paginatingVariables = {
          count: totalCount,
          cursor: null,
          totalCount: totalCount
        };

        var fetch = _this._fetchPage(paginatingVariables, toObserver(observerOrCallback), {
          force: true
        });

        return {
          dispose: fetch.unsubscribe
        };
      });
      (0, _defineProperty2$6["default"])((0, _assertThisInitialized2$1["default"])(_this), "_loadMore", function (pageSize, observerOrCallback, options) {
        if (!_this._canFetchPage('loadMore')) {
          return {
            dispose: function dispose() {}
          };
        }

        var observer = toObserver(observerOrCallback);

        var connectionData = _this._getConnectionData();

        if (!connectionData) {
          Observable.create(function (sink) {
            return sink.complete();
          }).subscribe(observer);
          return null;
        }

        var totalCount = connectionData.edgeCount + pageSize;

        if (options && options.force) {
          return _this._refetchConnection(totalCount, observerOrCallback);
        }

        var _ConnectionInterface$ = ConnectionInterface$1.get(),
            END_CURSOR = _ConnectionInterface$.END_CURSOR,
            START_CURSOR = _ConnectionInterface$.START_CURSOR;

        var cursor = connectionData.cursor;
        process$1.env.NODE_ENV !== "production" ? warning_1(cursor != null && cursor !== '', 'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)', direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;
        var paginatingVariables = {
          count: pageSize,
          cursor: cursor,
          totalCount: totalCount
        };

        var fetch = _this._fetchPage(paginatingVariables, observer, options);

        return {
          dispose: fetch.unsubscribe
        };
      });
      var relayContext = assertRelayContext$2(props.__relayContext);
      var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;
      _this._isARequestInFlight = false;
      _this._refetchSubscription = null;
      _this._refetchVariables = null;
      _this._resolver = createFragmentSpecResolver$2(relayContext, containerName, fragments, props, rootIsQueryRenderer, _this._handleFragmentDataUpdate);
      _this.state = {
        data: _this._resolver.resolve(),
        prevContext: relayContext,
        contextForChildren: relayContext,
        relayProp: _this._buildRelayProp(relayContext)
      };
      _this._isUnmounted = false;
      _this._hasFetched = false;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this._isUnmounted = false;
    }
    /**
     * When new props are received, read data for the new props and subscribe
     * for updates. Props may be the same in which case previous data and
     * subscriptions can be reused.
     */
    ;

    _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
      var _nextProps$__rootIsQu;

      var relayContext = assertRelayContext$2(nextProps.__relayContext);
      var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;
      var prevIDs = getDataIDsFromObject$2(fragments, this.props);
      var nextIDs = getDataIDsFromObject$2(fragments, nextProps);
      var prevRootVariables = getRootVariablesForFragments_1(fragments, this.props);
      var nextRootVariables = getRootVariablesForFragments_1(fragments, nextProps); // If the environment has changed or props point to new records then
      // previously fetched data and any pending fetches no longer apply:
      // - Existing references are on the old environment.
      // - Existing references are based on old variables.
      // - Pending fetches are for the previous records.

      if (relayContext.environment !== this.state.prevContext.environment || !areEqual_1(prevRootVariables, nextRootVariables) || !areEqual_1(prevIDs, nextIDs)) {
        this._cleanup(); // Child containers rely on context.relay being mutated (for gDSFP).


        this._resolver = createFragmentSpecResolver$2(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer, this._handleFragmentDataUpdate);
        this.setState({
          prevContext: relayContext,
          contextForChildren: relayContext,
          relayProp: this._buildRelayProp(relayContext)
        });
      } else if (!this._hasFetched) {
        this._resolver.setProps(nextProps);
      }

      var data = this._resolver.resolve();

      if (data !== this.state.data) {
        this.setState({
          data: data
        });
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this._isUnmounted = true;

      this._cleanup();
    };

    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
      // Short-circuit if any Relay-related data has changed
      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {
        return true;
      } // Otherwise, for convenience short-circuit if all non-Relay props
      // are scalar and equal


      var keys = Object.keys(nextProps);

      for (var ii = 0; ii < keys.length; ii++) {
        var _key = keys[ii];

        if (_key === '__relayContext') {
          if (nextState.prevContext.environment !== this.state.prevContext.environment) {
            return true;
          }
        } else {
          if (!fragments.hasOwnProperty(_key) && !isScalarAndEqual$2(nextProps[_key], this.props[_key])) {
            return true;
          }
        }
      }

      return false;
    };

    _proto._buildRelayProp = function _buildRelayProp(relayContext) {
      return {
        hasMore: this._hasMore,
        isLoading: this._isLoading,
        loadMore: this._loadMore,
        refetchConnection: this._refetchConnection,
        environment: relayContext.environment
      };
    }
    /**
     * Render new data for the existing props/context.
     */
    ;

    _proto._getConnectionData = function _getConnectionData() {
      // Extract connection data and verify there are more edges to fetch
      var _this$props = this.props,
          _ = _this$props.componentRef,
          restProps = (0, _objectWithoutPropertiesLoose2$1["default"])(_this$props, ["componentRef"]);
      var props = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, restProps), this.state.data);
      var connectionData = getConnectionFromProps(props);

      if (connectionData == null) {
        return null;
      }

      var _ConnectionInterface$2 = ConnectionInterface$1.get(),
          EDGES = _ConnectionInterface$2.EDGES,
          PAGE_INFO = _ConnectionInterface$2.PAGE_INFO,
          HAS_NEXT_PAGE = _ConnectionInterface$2.HAS_NEXT_PAGE,
          HAS_PREV_PAGE = _ConnectionInterface$2.HAS_PREV_PAGE,
          END_CURSOR = _ConnectionInterface$2.END_CURSOR,
          START_CURSOR = _ConnectionInterface$2.START_CURSOR;

      !(typeof connectionData === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return `null` or a plain object with %s and %s properties, got `%s`.', componentName, EDGES, PAGE_INFO, connectionData) : browser$1(false) : void 0;
      var edges = connectionData[EDGES];
      var pageInfo = connectionData[PAGE_INFO];

      if (edges == null || pageInfo == null) {
        return null;
      }

      !Array.isArray(edges) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Array, got `%s`.', componentName, EDGES, edges) : browser$1(false) : void 0;
      !(typeof pageInfo === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Object, got `%s`.', componentName, PAGE_INFO, pageInfo) : browser$1(false) : void 0;
      var hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];
      var cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];

      if (typeof hasMore !== 'boolean' || edges.length !== 0 && typeof cursor === 'undefined') {
        process$1.env.NODE_ENV !== "production" ? warning_1(false, 'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' + 'Be sure to fetch %s (got `%s`) and %s (got `%s`).', PAGE_INFO, componentName, direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE, hasMore, direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;
        return null;
      }

      return {
        cursor: cursor,
        edgeCount: edges.length,
        hasMore: hasMore
      };
    };

    _proto._getQueryFetcher = function _getQueryFetcher() {
      if (!this._queryFetcher) {
        this._queryFetcher = new ReactRelayQueryFetcher_1();
      }

      return this._queryFetcher;
    };

    _proto._canFetchPage = function _canFetchPage(method) {
      if (this._isUnmounted) {
        process$1.env.NODE_ENV !== "production" ? warning_1(false, 'ReactRelayPaginationContainer: Unexpected call of `%s` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to fetch data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `%s` call.', method, containerName, method) : void 0;
        return false;
      }

      return true;
    };

    _proto._fetchPage = function _fetchPage(paginatingVariables, observer, options) {
      var _this2 = this;

      var _assertRelayContext = assertRelayContext$2(this.props.__relayContext),
          environment = _assertRelayContext.environment;

      var _this$props2 = this.props,
          _ = _this$props2.componentRef,
          __relayContext = _this$props2.__relayContext,
          __rootIsQueryRenderer = _this$props2.__rootIsQueryRenderer,
          restProps = (0, _objectWithoutPropertiesLoose2$1["default"])(_this$props2, ["componentRef", "__relayContext", "__rootIsQueryRenderer"]);
      var props = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, restProps), this.state.data);
      var fragmentVariables;
      var rootVariables = getRootVariablesForFragments_1(fragments, restProps); // $FlowFixMe[cannot-spread-interface]

      fragmentVariables = getVariablesFromObject$1(fragments, restProps); // $FlowFixMe[cannot-spread-interface]

      fragmentVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, rootVariables), fragmentVariables), this._refetchVariables);
      var fetchVariables = connectionConfig.getVariables(props, {
        count: paginatingVariables.count,
        cursor: paginatingVariables.cursor
      }, fragmentVariables);
      !(typeof fetchVariables === 'object' && fetchVariables !== null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'ReactRelayPaginationContainer: Expected `getVariables()` to ' + 'return an object, got `%s` in `%s`.', fetchVariables, componentName) : browser$1(false) : void 0; // $FlowFixMe[cannot-spread-interface]

      fetchVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, fetchVariables), this._refetchVariables);
      fragmentVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, fetchVariables), fragmentVariables);
      var cacheConfig = options ? {
        force: !!options.force
      } : undefined;

      if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {
        cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;
      }

      var request = getRequest$7(connectionConfig.query);
      var operation = createOperationDescriptor$8(request, fetchVariables, cacheConfig);
      var refetchSubscription = null;

      if (this._refetchSubscription) {
        this._refetchSubscription.unsubscribe();
      }

      this._hasFetched = true;

      var onNext = function onNext(payload, complete) {
        var prevData = _this2._resolver.resolve();

        _this2._resolver.setVariables(getFragmentVariables(fragmentVariables, paginatingVariables.totalCount), operation.request.node);

        var nextData = _this2._resolver.resolve(); // Workaround slightly different handling for connection in different
        // core implementations:
        // - Classic core requires the count to be explicitly incremented
        // - Modern core automatically appends new items, updating the count
        //   isn't required to see new data.
        //
        // `setState` is only required if changing the variables would change the
        // resolved data.
        // TODO #14894725: remove PaginationContainer equal check


        if (!areEqual_1(prevData, nextData)) {
          _this2.setState({
            data: nextData,
            contextForChildren: {
              environment: _this2.props.__relayContext.environment
            }
          }, complete);
        } else {
          complete();
        }
      };

      var cleanup = function cleanup() {
        if (_this2._refetchSubscription === refetchSubscription) {
          _this2._refetchSubscription = null;
          _this2._isARequestInFlight = false;
        }
      };

      this._isARequestInFlight = true;
      refetchSubscription = this._getQueryFetcher().execute({
        environment: environment,
        operation: operation,
        preservePreviousReferences: true
      }).mergeMap(function (payload) {
        return Observable.create(function (sink) {
          onNext(payload, function () {
            sink.next(); // pass void to public observer's `next`

            sink.complete();
          });
        });
      }) // use do instead of finally so that observer's `complete` fires after cleanup
      ["do"]({
        error: cleanup,
        complete: cleanup,
        unsubscribe: cleanup
      }).subscribe(observer || {});
      this._refetchSubscription = this._isARequestInFlight ? refetchSubscription : null;
      return refetchSubscription;
    };

    _proto._cleanup = function _cleanup() {
      this._resolver.dispose();

      this._refetchVariables = null;
      this._hasFetched = false;

      if (this._refetchSubscription) {
        this._refetchSubscription.unsubscribe();

        this._refetchSubscription = null;
        this._isARequestInFlight = false;
      }

      if (this._queryFetcher) {
        this._queryFetcher.dispose();
      }
    };

    _proto.render = function render() {
      var _this$props3 = this.props,
          componentRef = _this$props3.componentRef,
          __relayContext = _this$props3.__relayContext,
          __rootIsQueryRenderer = _this$props3.__rootIsQueryRenderer,
          props = (0, _objectWithoutPropertiesLoose2$1["default"])(_this$props3, ["componentRef", "__relayContext", "__rootIsQueryRenderer"]);
      return /*#__PURE__*/React__default['default'].createElement(ReactRelayContext.Provider, {
        value: this.state.contextForChildren
      }, /*#__PURE__*/React__default['default'].createElement(Component, (0, _extends2$1["default"])({}, props, this.state.data, {
        ref: componentRef,
        relay: this.state.relayProp
      })));
    };

    return _class;
  }(React__default['default'].Component), (0, _defineProperty2$6["default"])(_class, "displayName", containerName), _temp;
}
/**
 * Wrap the basic `createContainer()` function with logic to adapt to the
 * `context.relay.environment` in which it is rendered. Specifically, the
 * extraction of the environment-specific version of fragments in the
 * `fragmentSpec` is memoized once per environment, rather than once per
 * instance of the container constructed/rendered.
 */


function createContainer$1(Component, fragmentSpec, connectionConfig) {
  // $FlowFixMe[incompatible-return]
  return buildReactRelayContainer_1(Component, fragmentSpec, function (ComponentClass, fragments) {
    return createContainerWithFragments$1(ComponentClass, fragments, connectionConfig);
  });
}

var ReactRelayPaginationContainer = {
  createContainer: createContainer$1
};

var _objectSpread2$e = interopRequireDefault(objectSpread2);

var _inheritsLoose2$2 = interopRequireDefault(inheritsLoose);











var createOperationDescriptor$9 = relayRuntime.createOperationDescriptor,
    deepFreeze$2 = relayRuntime.deepFreeze,
    getRequest$8 = relayRuntime.getRequest;

/**
 * React may double-fire the constructor, and we call 'fetch' in the
 * constructor. If a request is already in flight from a previous call to the
 * constructor, just reuse the query fetcher and wait for the response.
 */
var requestCache = {};
var queryRendererContext$1 = {
  rootIsQueryRenderer: true
};

/**
 * @public
 *
 * Orchestrates fetching and rendering data for a single view or view hierarchy:
 * - Fetches the query/variables using the given network implementation.
 * - Normalizes the response(s) to that query, publishing them to the given
 *   store.
 * - Renders the pending/fail/success states with the provided render function.
 * - Subscribes for updates to the root data and re-renders with any changes.
 */
var ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {
  (0, _inheritsLoose2$2["default"])(ReactRelayQueryRenderer, _React$Component);

  function ReactRelayQueryRenderer(props) {
    var _this;

    _this = _React$Component.call(this, props) || this; // Callbacks are attached to the current instance and shared with static
    // lifecyles by bundling with state. This is okay to do because the
    // callbacks don't change in reaction to props. However we should not
    // "leak" them before mounting (since we would be unable to clean up). For
    // that reason, we define them as null initially and fill them in after
    // mounting to avoid leaking memory.

    var retryCallbacks = {
      handleDataChange: null,
      handleRetryAfterError: null
    };
    var queryFetcher;
    var requestCacheKey;

    if (props.query) {
      var query = props.query;
      var request = getRequest$8(query);
      requestCacheKey = getRequestCacheKey(request.params, props.variables);
      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher_1();
    } else {
      queryFetcher = new ReactRelayQueryFetcher_1();
    }

    _this.state = (0, _objectSpread2$e["default"])({
      prevPropsEnvironment: props.environment,
      prevPropsVariables: props.variables,
      prevQuery: props.query,
      queryFetcher: queryFetcher,
      retryCallbacks: retryCallbacks
    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));
    return _this;
  }

  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual_1(prevState.prevPropsVariables, nextProps.variables)) {
      var query = nextProps.query;
      var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();
      prevState.queryFetcher.disposeRequest();
      var queryFetcher;

      if (query) {
        var request = getRequest$8(query);
        var requestCacheKey = getRequestCacheKey(request.params, nextProps.variables);
        queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher_1(prevSelectionReferences);
      } else {
        queryFetcher = new ReactRelayQueryFetcher_1(prevSelectionReferences);
      }

      return (0, _objectSpread2$e["default"])({
        prevQuery: nextProps.query,
        prevPropsEnvironment: nextProps.environment,
        prevPropsVariables: nextProps.variables,
        queryFetcher: queryFetcher
      }, fetchQueryAndComputeStateFromProps(nextProps, queryFetcher, prevState.retryCallbacks // passing no requestCacheKey will cause it to be recalculated internally
      // and we want the updated requestCacheKey, since variables may have changed
      ));
    }

    return null;
  };

  var _proto = ReactRelayQueryRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var _this$state = this.state,
        retryCallbacks = _this$state.retryCallbacks,
        queryFetcher = _this$state.queryFetcher,
        requestCacheKey = _this$state.requestCacheKey;

    if (requestCacheKey) {
      delete requestCache[requestCacheKey];
    }

    retryCallbacks.handleDataChange = function (params) {
      var error = params.error == null ? null : params.error;
      var snapshot = params.snapshot == null ? null : params.snapshot;

      _this2.setState(function (prevState) {
        var prevRequestCacheKey = prevState.requestCacheKey;

        if (prevRequestCacheKey) {
          delete requestCache[prevRequestCacheKey];
        } // Don't update state if nothing has changed.


        if (snapshot === prevState.snapshot && error === prevState.error) {
          return null;
        }

        return {
          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),
          snapshot: snapshot,
          requestCacheKey: null
        };
      });
    };

    retryCallbacks.handleRetryAfterError = function (error) {
      return _this2.setState(function (prevState) {
        var prevRequestCacheKey = prevState.requestCacheKey;

        if (prevRequestCacheKey) {
          delete requestCache[prevRequestCacheKey];
        }

        return {
          renderProps: getLoadingRenderProps(),
          requestCacheKey: null
        };
      });
    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.
    // If data has changed since constructions, this will re-render.


    if (this.props.query) {
      queryFetcher.setOnDataChange(retryCallbacks.handleDataChange);
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    // We don't need to cache the request after the component commits
    var requestCacheKey = this.state.requestCacheKey;

    if (requestCacheKey) {
      delete requestCache[requestCacheKey]; // HACK

      delete this.state.requestCacheKey;
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.state.queryFetcher.dispose();
  };

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;
  };

  _proto.render = function render() {
    var _this$state2 = this.state,
        renderProps = _this$state2.renderProps,
        relayContext = _this$state2.relayContext; // Note that the root fragment results in `renderProps.props` is already
    // frozen by the store; this call is to freeze the renderProps object and
    // error property if set.

    if (process$1.env.NODE_ENV !== "production") {
      deepFreeze$2(renderProps);
    }

    return /*#__PURE__*/React__default['default'].createElement(ReactRelayContext.Provider, {
      value: relayContext
    }, /*#__PURE__*/React__default['default'].createElement(ReactRelayQueryRendererContext.Provider, {
      value: queryRendererContext$1
    }, this.props.render(renderProps)));
  };

  return ReactRelayQueryRenderer;
}(React__default['default'].Component);

function getLoadingRenderProps() {
  return {
    error: null,
    props: null,
    // `props: null` indicates that the data is being fetched (i.e. loading)
    retry: null
  };
}

function getEmptyRenderProps() {
  return {
    error: null,
    props: {},
    // `props: {}` indicates no data available
    retry: null
  };
}

function getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {
  return {
    error: error ? error : null,
    props: snapshot ? snapshot.data : null,
    retry: function retry(cacheConfigOverride) {
      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);

      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {
        retryCallbacks.handleDataChange({
          snapshot: syncSnapshot
        });
      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {
        // If retrying after an error and no synchronous result available,
        // reset the render props
        retryCallbacks.handleRetryAfterError(error);
      }
    }
  };
}

function getRequestCacheKey(request, variables) {
  return JSON.stringify({
    id: request.cacheID ? request.cacheID : request.id,
    variables: variables
  });
}

function fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {
  var environment = props.environment,
      query = props.query,
      variables = props.variables,
      cacheConfig = props.cacheConfig;
  var genericEnvironment = environment;

  if (query) {
    var request = getRequest$8(query);
    var operation = createOperationDescriptor$9(request, variables, cacheConfig);
    var relayContext = {
      environment: genericEnvironment
    };

    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {
      // This same request is already in flight.
      var snapshot = requestCache[requestCacheKey].snapshot;

      if (snapshot) {
        // Use the cached response
        return {
          error: null,
          relayContext: relayContext,
          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),
          snapshot: snapshot,
          requestCacheKey: requestCacheKey
        };
      } else {
        // Render loading state
        return {
          error: null,
          relayContext: relayContext,
          renderProps: getLoadingRenderProps(),
          snapshot: null,
          requestCacheKey: requestCacheKey
        };
      }
    }

    try {
      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);
      var querySnapshot = queryFetcher.fetch({
        environment: genericEnvironment,
        onDataChange: retryCallbacks.handleDataChange,
        operation: operation
      }); // Use network data first, since it may be fresher

      var _snapshot = querySnapshot || storeSnapshot; // cache the request to avoid duplicate requests


      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);
      requestCache[requestCacheKey] = {
        queryFetcher: queryFetcher,
        snapshot: _snapshot
      };

      if (!_snapshot) {
        return {
          error: null,
          relayContext: relayContext,
          renderProps: getLoadingRenderProps(),
          snapshot: null,
          requestCacheKey: requestCacheKey
        };
      }

      return {
        error: null,
        relayContext: relayContext,
        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),
        snapshot: _snapshot,
        requestCacheKey: requestCacheKey
      };
    } catch (error) {
      return {
        error: error,
        relayContext: relayContext,
        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),
        snapshot: null,
        requestCacheKey: requestCacheKey
      };
    }
  } else {
    queryFetcher.dispose();
    var _relayContext = {
      environment: genericEnvironment
    };
    return {
      error: null,
      relayContext: _relayContext,
      renderProps: getEmptyRenderProps(),
      requestCacheKey: null // if there is an error, don't cache request

    };
  }
}

var ReactRelayQueryRenderer_1 = ReactRelayQueryRenderer;

var _extends2$2 = interopRequireDefault(_extends_1);

var _objectWithoutPropertiesLoose2$2 = interopRequireDefault(objectWithoutPropertiesLoose);

var _objectSpread2$f = interopRequireDefault(objectSpread2);

var _assertThisInitialized2$2 = interopRequireDefault(assertThisInitialized);

var _inheritsLoose2$3 = interopRequireDefault(inheritsLoose);

var _defineProperty2$7 = interopRequireDefault(defineProperty);















var getContainerName$4 = ReactRelayContainerUtils.getContainerName;

var assertRelayContext$3 = RelayContext.assertRelayContext;

var Observable$1 = relayRuntime.Observable,
    createFragmentSpecResolver$3 = relayRuntime.createFragmentSpecResolver,
    createOperationDescriptor$a = relayRuntime.createOperationDescriptor,
    getDataIDsFromObject$3 = relayRuntime.getDataIDsFromObject,
    getRequest$9 = relayRuntime.getRequest,
    getVariablesFromObject$2 = relayRuntime.getVariablesFromObject,
    isScalarAndEqual$3 = relayRuntime.isScalarAndEqual;

/**
 * Composes a React component class, returning a new class that intercepts
 * props, resolving them with the provided fragments and subscribing for
 * updates.
 */
function createContainerWithFragments$2(Component, fragments, taggedNode) {
  var _class, _temp;

  var containerName = getContainerName$4(Component);
  return _temp = _class = /*#__PURE__*/function (_React$Component) {
    (0, _inheritsLoose2$3["default"])(_class, _React$Component);

    function _class(props) {
      var _props$__rootIsQueryR, _this;

      _this = _React$Component.call(this, props) || this;
      (0, _defineProperty2$7["default"])((0, _assertThisInitialized2$2["default"])(_this), "_handleFragmentDataUpdate", function () {
        var resolverFromThisUpdate = _this.state.resolver;

        _this.setState(function (updatedState) {
          return (// If this event belongs to the current data source, update.
            // Otherwise we should ignore it.
            resolverFromThisUpdate === updatedState.resolver ? {
              data: updatedState.resolver.resolve()
            } : null
          );
        });
      });
      (0, _defineProperty2$7["default"])((0, _assertThisInitialized2$2["default"])(_this), "_refetch", function (refetchVariables, renderVariables, observerOrCallback, options) {
        if (_this._isUnmounted) {
          process$1.env.NODE_ENV !== "production" ? warning_1(false, 'ReactRelayRefetchContainer: Unexpected call of `refetch` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to refetch the data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `refetch`.', containerName) : void 0;
          return {
            dispose: function dispose() {}
          };
        }

        var _assertRelayContext = assertRelayContext$3(_this.props.__relayContext),
            environment = _assertRelayContext.environment;

        var rootVariables = getRootVariablesForFragments_1(fragments, _this.props);
        var fetchVariables = typeof refetchVariables === 'function' ? refetchVariables(_this._getFragmentVariables()) : refetchVariables; // $FlowFixMe[cannot-spread-interface]

        fetchVariables = (0, _objectSpread2$f["default"])((0, _objectSpread2$f["default"])({}, rootVariables), fetchVariables);
        var fragmentVariables = renderVariables ? // $FlowFixMe[cannot-spread-interface]
        (0, _objectSpread2$f["default"])((0, _objectSpread2$f["default"])({}, fetchVariables), renderVariables) : fetchVariables;
        var cacheConfig = options ? {
          force: !!options.force
        } : undefined;

        if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {
          cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;
        }

        var observer = typeof observerOrCallback === 'function' ? {
          // callback is not exectued on complete or unsubscribe
          // for backward compatibility
          next: observerOrCallback,
          error: observerOrCallback
        } : observerOrCallback || {};
        var query = getRequest$9(taggedNode);
        var operation = createOperationDescriptor$a(query, fetchVariables, cacheConfig); // TODO: T26288752 find a better way

        /* eslint-disable lint/react-state-props-mutation */

        _this.state.localVariables = fetchVariables;
        /* eslint-enable lint/react-state-props-mutation */
        // Cancel any previously running refetch.

        _this._refetchSubscription && _this._refetchSubscription.unsubscribe(); // Declare refetchSubscription before assigning it in .start(), since
        // synchronous completion may call callbacks .subscribe() returns.

        var refetchSubscription;

        var storeSnapshot = _this._getQueryFetcher().lookupInStore(environment, operation, options === null || options === void 0 ? void 0 : options.fetchPolicy);

        if (storeSnapshot != null) {
          _this.state.resolver.setVariables(fragmentVariables, operation.request.node);

          _this.setState(function (latestState) {
            return {
              data: latestState.resolver.resolve(),
              contextForChildren: {
                environment: _this.props.__relayContext.environment
              }
            };
          }, function () {
            observer.next && observer.next();
            observer.complete && observer.complete();
          });

          return {
            dispose: function dispose() {}
          };
        }

        _this._getQueryFetcher().execute({
          environment: environment,
          operation: operation,
          // TODO (T26430099): Cleanup old references
          preservePreviousReferences: true
        }).mergeMap(function (response) {
          _this.state.resolver.setVariables(fragmentVariables, operation.request.node);

          return Observable$1.create(function (sink) {
            return _this.setState(function (latestState) {
              return {
                data: latestState.resolver.resolve(),
                contextForChildren: {
                  environment: _this.props.__relayContext.environment
                }
              };
            }, function () {
              sink.next();
              sink.complete();
            });
          });
        })["finally"](function () {
          // Finalizing a refetch should only clear this._refetchSubscription
          // if the finizing subscription is the most recent call.
          if (_this._refetchSubscription === refetchSubscription) {
            _this._refetchSubscription = null;
          }
        }).subscribe((0, _objectSpread2$f["default"])((0, _objectSpread2$f["default"])({}, observer), {}, {
          start: function start(subscription) {
            _this._refetchSubscription = refetchSubscription = subscription;
            observer.start && observer.start(subscription);
          }
        }));

        return {
          dispose: function dispose() {
            refetchSubscription && refetchSubscription.unsubscribe();
          }
        };
      });
      var relayContext = assertRelayContext$3(props.__relayContext);
      var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;
      _this._refetchSubscription = null; // Do not provide a subscription/callback here.
      // It is possible for this render to be interrupted or aborted,
      // In which case the subscription would cause a leak.
      // We will add the subscription in componentDidMount().

      var resolver = createFragmentSpecResolver$3(relayContext, containerName, fragments, props, rootIsQueryRenderer);
      _this.state = {
        data: resolver.resolve(),
        localVariables: null,
        prevProps: props,
        prevPropsContext: relayContext,
        contextForChildren: relayContext,
        relayProp: getRelayProp$1(relayContext.environment, _this._refetch),
        resolver: resolver
      };
      _this._isUnmounted = false;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this._isUnmounted = false;

      this._subscribeToNewResolver();
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      // If the environment has changed or props point to new records then
      // previously fetched data and any pending fetches no longer apply:
      // - Existing references are on the old environment.
      // - Existing references are based on old variables.
      // - Pending fetches are for the previous records.
      if (this.state.resolver !== prevState.resolver) {
        prevState.resolver.dispose();
        this._queryFetcher && this._queryFetcher.dispose();
        this._refetchSubscription && this._refetchSubscription.unsubscribe();

        this._subscribeToNewResolver();
      }
    }
    /**
     * When new props are received, read data for the new props and add it to
     * state. Props may be the same in which case previous data can be reused.
     */
    ;

    _class.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$__rootIsQu;

      // Any props change could impact the query, so we mirror props in state.
      // This is an unusual pattern, but necessary for this container usecase.
      var prevProps = prevState.prevProps;
      var relayContext = assertRelayContext$3(nextProps.__relayContext);
      var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;
      var prevIDs = getDataIDsFromObject$3(fragments, prevProps);
      var nextIDs = getDataIDsFromObject$3(fragments, nextProps);
      var prevRootVariables = getRootVariablesForFragments_1(fragments, prevProps);
      var nextRootVariables = getRootVariablesForFragments_1(fragments, nextProps);
      var resolver = prevState.resolver; // If the environment has changed or props point to new records then
      // previously fetched data and any pending fetches no longer apply:
      // - Existing references are on the old environment.
      // - Existing references are based on old variables.
      // - Pending fetches are for the previous records.

      if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual_1(prevRootVariables, nextRootVariables) || !areEqual_1(prevIDs, nextIDs)) {
        // Do not provide a subscription/callback here.
        // It is possible for this render to be interrupted or aborted,
        // In which case the subscription would cause a leak.
        // We will add the subscription in componentDidUpdate().
        resolver = createFragmentSpecResolver$3(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);
        return {
          data: resolver.resolve(),
          localVariables: null,
          prevProps: nextProps,
          prevPropsContext: relayContext,
          contextForChildren: relayContext,
          relayProp: getRelayProp$1(relayContext.environment, prevState.relayProp.refetch),
          resolver: resolver
        };
      } else if (!prevState.localVariables) {
        resolver.setProps(nextProps);
      }

      var data = resolver.resolve();

      if (data !== prevState.data) {
        return {
          data: data,
          prevProps: nextProps
        };
      }

      return null;
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this._isUnmounted = true;
      this.state.resolver.dispose();
      this._queryFetcher && this._queryFetcher.dispose();
      this._refetchSubscription && this._refetchSubscription.unsubscribe();
    };

    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
      // Short-circuit if any Relay-related data has changed
      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {
        return true;
      } // Otherwise, for convenience short-circuit if all non-Relay props
      // are scalar and equal


      var keys = Object.keys(nextProps);

      for (var ii = 0; ii < keys.length; ii++) {
        var _key = keys[ii];

        if (_key === '__relayContext') {
          if (this.state.prevPropsContext.environment !== nextState.prevPropsContext.environment) {
            return true;
          }
        } else {
          if (!fragments.hasOwnProperty(_key) && !isScalarAndEqual$3(nextProps[_key], this.props[_key])) {
            return true;
          }
        }
      }

      return false;
    };

    _proto._subscribeToNewResolver = function _subscribeToNewResolver() {
      var _this$state = this.state,
          data = _this$state.data,
          resolver = _this$state.resolver; // Event listeners are only safe to add during the commit phase,
      // So they won't leak if render is interrupted or errors.

      resolver.setCallback(this._handleFragmentDataUpdate); // External values could change between render and commit.
      // Check for this case, even though it requires an extra store read.

      var maybeNewData = resolver.resolve();

      if (data !== maybeNewData) {
        this.setState({
          data: maybeNewData
        });
      }
    }
    /**
     * Render new data for the existing props/context.
     */
    ;

    _proto._getFragmentVariables = function _getFragmentVariables() {
      return getVariablesFromObject$2(fragments, this.props);
    };

    _proto._getQueryFetcher = function _getQueryFetcher() {
      if (!this._queryFetcher) {
        this._queryFetcher = new ReactRelayQueryFetcher_1();
      }

      return this._queryFetcher;
    };

    _proto.render = function render() {
      var _this$props = this.props,
          componentRef = _this$props.componentRef,
          __relayContext = _this$props.__relayContext,
          __rootIsQueryRenderer = _this$props.__rootIsQueryRenderer,
          props = (0, _objectWithoutPropertiesLoose2$2["default"])(_this$props, ["componentRef", "__relayContext", "__rootIsQueryRenderer"]);
      var _this$state2 = this.state,
          relayProp = _this$state2.relayProp,
          contextForChildren = _this$state2.contextForChildren;
      return /*#__PURE__*/React__default['default'].createElement(ReactRelayContext.Provider, {
        value: contextForChildren
      }, /*#__PURE__*/React__default['default'].createElement(Component, (0, _extends2$2["default"])({}, props, this.state.data, {
        ref: componentRef,
        relay: relayProp
      })));
    };

    return _class;
  }(React__default['default'].Component), (0, _defineProperty2$7["default"])(_class, "displayName", containerName), _temp;
}

function getRelayProp$1(environment, refetch) {
  return {
    environment: environment,
    refetch: refetch
  };
}
/**
 * Wrap the basic `createContainer()` function with logic to adapt to the
 * `context.relay.environment` in which it is rendered. Specifically, the
 * extraction of the environment-specific version of fragments in the
 * `fragmentSpec` is memoized once per environment, rather than once per
 * instance of the container constructed/rendered.
 */


function createContainer$2(Component, fragmentSpec, taggedNode) {
  // $FlowFixMe[incompatible-return]
  return buildReactRelayContainer_1(Component, fragmentSpec, function (ComponentClass, fragments) {
    return createContainerWithFragments$2(ComponentClass, fragments, taggedNode);
  });
}

var ReactRelayRefetchContainer = {
  createContainer: createContainer$2
};

var useMemo$1 = React__default['default'].useMemo;

function RelayEnvironmentProvider(props) {
  var children = props.children,
      environment = props.environment;
  var context = useMemo$1(function () {
    return {
      environment: environment
    };
  }, [environment]);
  return /*#__PURE__*/React__default['default'].createElement(ReactRelayContext$1.Provider, {
    value: context
  }, children);
}

var RelayEnvironmentProvider_1 = RelayEnvironmentProvider;

var _objectSpread2$g = interopRequireDefault(objectSpread2);







var PreloadableQueryRegistry$1 = relayRuntime.PreloadableQueryRegistry,
    ReplaySubject = relayRuntime.ReplaySubject,
    createOperationDescriptor$b = relayRuntime.createOperationDescriptor,
    getRequest$a = relayRuntime.getRequest,
    getRequestIdentifier$1 = relayRuntime.getRequestIdentifier,
    Observable$2 = relayRuntime.Observable,
    fetchQueryDeduped$1 = relayRuntime.__internal.fetchQueryDeduped;

var RenderDispatcher = null;
var fetchKey = 100001;

function useTrackLoadQueryInRender() {
  if (RenderDispatcher === null) {
    var _React$__SECRET_INTER, _React$__SECRET_INTER2;

    // Flow does not know of React internals (rightly so), but we need to
    // ensure here that this function isn't called inside render.
    RenderDispatcher = // $FlowFixMe[prop-missing]
    (_React$__SECRET_INTER = React__default['default'].__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER === void 0 ? void 0 : (_React$__SECRET_INTER2 = _React$__SECRET_INTER.ReactCurrentDispatcher) === null || _React$__SECRET_INTER2 === void 0 ? void 0 : _React$__SECRET_INTER2.current;
  }
}

function loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {
  var _React$__SECRET_INTER3, _React$__SECRET_INTER4, _options$__nameForWar, _options$fetchPolicy;

  // This code ensures that we don't call loadQuery during render.
  var CurrentDispatcher = // $FlowFixMe[prop-missing]
  (_React$__SECRET_INTER3 = React__default['default'].__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER3 === void 0 ? void 0 : (_React$__SECRET_INTER4 = _React$__SECRET_INTER3.ReactCurrentDispatcher) === null || _React$__SECRET_INTER4 === void 0 ? void 0 : _React$__SECRET_INTER4.current;
  process$1.env.NODE_ENV !== "production" ? warning_1(RenderDispatcher == null || CurrentDispatcher !== RenderDispatcher, 'Relay: `%s` should not be called inside a React render function.', (_options$__nameForWar = options === null || options === void 0 ? void 0 : options.__nameForWarning) !== null && _options$__nameForWar !== void 0 ? _options$__nameForWar : 'loadQuery') : void 0; // Every time you call loadQuery, we will generate a new fetchKey.
  // This will ensure that every query reference that is created and
  // passed to usePreloadedQuery is independently evaluated,
  // even if they are for the same query/variables.
  // Specifically, we want to avoid a case where we try to refetch a
  // query by calling loadQuery a second time, and have the Suspense
  // cache in usePreloadedQuery reuse the cached result instead of
  // re-evaluating the new query ref and triggering a refetch if
  // necessary.

  fetchKey++;
  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';
  var networkCacheConfig = (0, _objectSpread2$g["default"])((0, _objectSpread2$g["default"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {
    force: true
  }); // executeWithNetworkSource will retain and execute an operation
  // against the Relay store, given an Observable that would provide
  // the network events for the operation.

  var retainReference;
  var didExecuteNetworkSource = false;

  var executeWithNetworkSource = function executeWithNetworkSource(operation, networkObservable) {
    didExecuteNetworkSource = true;
    return environment.executeWithSource({
      operation: operation,
      source: networkObservable
    });
  }; // N.B. For loadQuery, we unconventionally want to return an Observable
  // that isn't lazily executed, meaning that we don't want to wait
  // until the returned Observable is subscribed to to actually start
  // fetching and executing an operation; i.e. we want to execute the
  // operation eagerly, when loadQuery is called.
  // For this reason, we use an intermediate executionSubject which
  // allows us to capture the events that occur during the eager execution
  // of the operation, and then replay them to the Observable we
  // ultimately return.


  var executionSubject = new ReplaySubject();
  var returnedObservable = Observable$2.create(function (sink) {
    return executionSubject.subscribe(sink);
  });
  var unsubscribeFromNetworkRequest;
  var networkError = null; // makeNetworkRequest will immediately start a raw network request if
  // one isn't already in flight and return an Observable that when
  // subscribed to will replay the network events that have occured so far,
  // as well as subsequent events.

  var didMakeNetworkRequest = false;

  var makeNetworkRequest = function makeNetworkRequest(params) {
    // N.B. this function is called synchronously or not at all
    // didMakeNetworkRequest is safe to rely on in the returned value
    // Even if the request gets deduped below, we still wan't to return an
    // observable that provides the replayed network events for the query,
    // so we set this to true before deduping, to guarantee that the
    // `source` observable is returned.
    didMakeNetworkRequest = true;
    var observable;
    var subject = new ReplaySubject();

    {
      // Here, we are calling fetchQueryDeduped at the network layer level,
      // which ensures that only a single network request is active for a given
      // (environment, identifier) pair.
      // Since network requests can be started /before/ we have the query ast
      // necessary to process the results, we need to dedupe the raw requests
      // separately from deduping the operation execution; specifically,
      // if `loadQuery` is called multiple times before the query ast is available,
      // we still want the network request to be deduped.
      // - If a duplicate active network request is found, it will return an
      // Observable that replays the events of the already active request.
      // - If no duplicate active network request is found, it will call the fetchFn
      // to start the request, and return an Observable that will replay
      // the events from the network request.
      // We provide an extra key to the identifier to distinguish deduping
      // of raw network requests vs deduping of operation executions.
      var identifier = 'raw-network-request-' + getRequestIdentifier$1(params, variables);
      observable = fetchQueryDeduped$1(environment, identifier, function () {
        var network = environment.getNetwork();
        return network.execute(params, variables, networkCacheConfig);
      });
    }

    var _observable$subscribe = observable.subscribe({
      error: function error(err) {
        networkError = err;
        subject.error(err);
      },
      next: function next(data) {
        subject.next(data);
      },
      complete: function complete() {
        subject.complete();
      }
    }),
        unsubscribe = _observable$subscribe.unsubscribe;

    unsubscribeFromNetworkRequest = unsubscribe;
    return Observable$2.create(function (sink) {
      var subjectSubscription = subject.subscribe(sink);
      return function () {
        subjectSubscription.unsubscribe();
        unsubscribeFromNetworkRequest();
      };
    });
  };

  var unsubscribeFromExecution;

  var executeDeduped = function executeDeduped(operation, fetchFn) {
    {
      // N.B. at this point, if we're calling execute with a query ast (OperationDescriptor),
      // we are guaranteed to have started a network request. We set this to
      // true here as well since `makeNetworkRequest` might get skipped in the case
      // where the query ast is already available and the query executions get deduped.
      // Even if the execution gets deduped below, we still wan't to return
      // an observable that provides the replayed network events for the query,
      // so we set this to true before deduping, to guarantee that the `source`
      // observable is returned.
      didMakeNetworkRequest = true;
    } // Here, we are calling fetchQueryDeduped, which ensures that only
    // a single operation is active for a given (environment, identifier) pair,
    // and also tracks the active state of the operation, which is necessary
    // for our Suspense infra to later be able to suspend (or not) on
    // active operations. Even though we already dedupe raw network requests,
    // we also need to dedupe and keep track operation execution for our Suspense
    // infra, and we also want to avoid processing responses more than once, for
    // the cases where `loadQuery` might be called multiple times after the query ast
    // is available.
    // - If a duplicate active operation is found, it will return an
    // Observable that replays the events of the already active operation.
    // - If no duplicate active operation is found, it will call the fetchFn
    // to execute the operation, and return an Observable that will provide
    // the events for executing the operation.


    var _fetchQueryDeduped$su = fetchQueryDeduped$1(environment, operation.request.identifier, fetchFn).subscribe({
      error: function error(err) {
        executionSubject.error(err);
      },
      next: function next(data) {
        executionSubject.next(data);
      },
      complete: function complete() {
        executionSubject.complete();
      }
    });

    unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;
  };

  var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {
    var operation = createOperationDescriptor$b(concreteRequest, variables, networkCacheConfig);
    retainReference = environment.retain(operation);

    if (fetchPolicy === 'store-only') {
      return;
    } // N.B. If the fetch policy allows fulfillment from the store but the
    // environment already has the data for that operation cached in the store,
    // then we do nothing.


    var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';

    if (shouldFetch) {
      executeDeduped(operation, function () {
        // N.B. Since we have the operation synchronously available here,
        // we can immediately fetch and execute the operation.
        var networkObservable = makeNetworkRequest(concreteRequest.params);
        var executeObservable = executeWithNetworkSource(operation, networkObservable);
        return executeObservable;
      });
    }
  };

  var params;
  var cancelOnLoadCallback;
  var queryId;

  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {
    var preloadableConcreteRequest = preloadableRequest;
    params = preloadableConcreteRequest.params;
    var _params = params;
    queryId = _params.id;
    !(queryId !== null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : browser$1(false) : void 0;

    var _module = PreloadableQueryRegistry$1.get(queryId);

    if (_module != null) {
      checkAvailabilityAndExecute(_module);
    } else {
      // If the module isn't synchronously available, we launch the
      // network request immediately if the fetchPolicy might produce
      // a network fetch, regardless of the state of the store cache. We
      // do this because we can't check if a query is cached without the
      // ast, and we know that if we don't have the query ast
      // available, then this query could've never been written to the
      // store in the first place, so it couldn't have been cached.
      var networkObservable = fetchPolicy === 'store-only' ? null : makeNetworkRequest(params);

      var _PreloadableQueryRegi = PreloadableQueryRegistry$1.onLoad( // $FlowFixMe[incompatible-call]
      queryId, function (preloadedModule) {
        cancelOnLoadCallback();
        var operation = createOperationDescriptor$b(preloadedModule, variables, networkCacheConfig);
        retainReference = environment.retain(operation);

        if (networkObservable != null) {
          executeDeduped(operation, function () {
            return executeWithNetworkSource(operation, networkObservable);
          });
        }
      });

      cancelOnLoadCallback = _PreloadableQueryRegi.dispose;
    }
  } else {
    var graphQlTaggedNode = preloadableRequest;
    var request = getRequest$a(graphQlTaggedNode);
    params = request.params;
    queryId = params.cacheID != null ? params.cacheID : params.id;
    checkAvailabilityAndExecute(request);
  }

  var isDisposed = false;
  return {
    kind: 'PreloadedQuery',
    environment: environment,
    environmentProviderOptions: environmentProviderOptions,
    dispose: function dispose() {
      if (isDisposed) {
        return;
      }

      if (didExecuteNetworkSource) {
        unsubscribeFromExecution && unsubscribeFromExecution();
      } else {
        unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();
      }

      retainReference && retainReference.dispose();
      cancelOnLoadCallback && cancelOnLoadCallback();
      isDisposed = true;
    },
    fetchKey: fetchKey,
    id: queryId,

    // $FlowFixMe[unsafe-getters-setters] - this has no side effects
    get isDisposed() {
      return isDisposed;
    },

    // $FlowFixMe[unsafe-getters-setters] - this has no side effects
    get networkError() {
      return networkError;
    },

    name: params.name,
    networkCacheConfig: networkCacheConfig,
    fetchPolicy: fetchPolicy,
    source: didMakeNetworkRequest ? returnedObservable : undefined,
    variables: variables
  };
}

var loadQuery_1 = {
  loadQuery: loadQuery,
  useTrackLoadQueryInRender: useTrackLoadQueryInRender
};

var loadQuery$1 = loadQuery_1.loadQuery;

function loadEntryPoint(environmentProvider, entryPoint, entryPointParams) {
  // Start loading the code for the entrypoint
  var loadingPromise = null;

  if (entryPoint.root.getModuleIfRequired() == null) {
    loadingPromise = entryPoint.root.load();
  }

  var preloadProps = entryPoint.getPreloadProps(entryPointParams);
  var queries = preloadProps.queries,
      entryPoints = preloadProps.entryPoints,
      extraProps = preloadProps.extraProps;
  var preloadedQueries = {};
  var preloadedEntryPoints = {};

  if (queries != null) {
    var queriesPropNames = Object.keys(queries);
    queriesPropNames.forEach(function (queryPropName) {
      var _queries$queryPropNam = queries[queryPropName],
          environmentProviderOptions = _queries$queryPropNam.environmentProviderOptions,
          options = _queries$queryPropNam.options,
          parameters = _queries$queryPropNam.parameters,
          variables = _queries$queryPropNam.variables;
      var environment = environmentProvider.getEnvironment(environmentProviderOptions);
      preloadedQueries[queryPropName] = loadQuery$1(environment, parameters, variables, {
        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
        networkCacheConfig: options === null || options === void 0 ? void 0 : options.networkCacheConfig,
        __nameForWarning: 'loadEntryPoint'
      }, environmentProviderOptions);
    });
  }

  if (entryPoints != null) {
    var entryPointPropNames = Object.keys(entryPoints);
    entryPointPropNames.forEach(function (entryPointPropName) {
      var entryPointDescription = entryPoints[entryPointPropName];

      if (entryPointDescription == null) {
        return;
      }

      var nestedEntryPoint = entryPointDescription.entryPoint,
          nestedParams = entryPointDescription.entryPointParams;
      preloadedEntryPoints[entryPointPropName] = loadEntryPoint(environmentProvider, nestedEntryPoint, nestedParams);
    });
  }

  var isDisposed = false;
  return {
    dispose: function dispose() {
      if (isDisposed) {
        return;
      }

      if (preloadedQueries != null) {
        Object.values(preloadedQueries).forEach(function (_ref) {
          var innerDispose = _ref.dispose;
          innerDispose();
        });
      }

      if (preloadedEntryPoints != null) {
        Object.values(preloadedEntryPoints).forEach(function (_ref2) {
          var innerDispose = _ref2.dispose;
          innerDispose();
        });
      }

      isDisposed = true;
    },
    entryPoints: preloadedEntryPoints,
    extraProps: extraProps !== null && extraProps !== void 0 ? extraProps : null,
    getComponent: function getComponent() {
      var component = entryPoint.root.getModuleIfRequired();

      if (component == null) {
        var _loadingPromise;

        loadingPromise = (_loadingPromise = loadingPromise) !== null && _loadingPromise !== void 0 ? _loadingPromise : entryPoint.root.load();
        throw loadingPromise;
      } // $FlowFixMe[incompatible-cast] - trust me Flow, its entryPoint component


      return component;
    },

    // $FlowFixMe[unsafe-getters-setters] - this has no side effects
    get isDisposed() {
      return isDisposed;
    },

    queries: preloadedQueries,
    rootModuleID: entryPoint.root.getModuleId()
  };
}

var loadEntryPoint_1 = loadEntryPoint;

var useEffect$1 = React__default['default'].useEffect,
    useRef$1 = React__default['default'].useRef;

function useIsMountedRef() {
  var isMountedRef = useRef$1(true);
  useEffect$1(function () {
    isMountedRef.current = true;
    return function () {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef;
}

var useIsMountedRef_1 = useIsMountedRef;

var _createForOfIteratorHelper2$a = interopRequireDefault(createForOfIteratorHelper);





var useTrackLoadQueryInRender$1 = loadQuery_1.useTrackLoadQueryInRender;

var useCallback = React__default['default'].useCallback,
    useEffect$2 = React__default['default'].useEffect,
    useRef$2 = React__default['default'].useRef,
    useState$1 = React__default['default'].useState;

var initialNullEntryPointReferenceState = {
  kind: 'NullEntryPointReference'
};

function useLoadEntryPoint(environmentProvider, entryPoint, options) {
  var _options$TEST_ONLY__i, _options$TEST_ONLY__i2, _options$TEST_ONLY__i3, _options$TEST_ONLY__i4;

  /**
   * We want to always call `entryPointReference.dispose()` for every call to
   * `setEntryPointReference(loadEntryPoint(...))` so that no leaks of data in Relay
   * stores will occur.
   *
   * However, a call to `setState(newState)` is not always followed by a commit where
   * this value is reflected in the state. Thus, we cannot reliably clean up each ref
   * with `useEffect(() => () => entryPointReference.dispose(), [entryPointReference])`.
   *
   * Instead, we keep track of each call to `loadEntryPoint` in a ref.
   * Relying on the fact that if a state change commits, no state changes that were
   * initiated prior to the currently committing state change will ever subsequently
   * commit, we can safely dispose of all preloaded entry point references
   * associated with state changes initiated prior to the currently committing state
   * change.
   *
   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted
   * entry point references.
   */
  useTrackLoadQueryInRender$1();
  var initialEntryPointReferenceInternal = (_options$TEST_ONLY__i = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i2 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i2 === void 0 ? void 0 : _options$TEST_ONLY__i2.entryPointReference) !== null && _options$TEST_ONLY__i !== void 0 ? _options$TEST_ONLY__i : initialNullEntryPointReferenceState;
  var initialEntryPointParamsInternal = (_options$TEST_ONLY__i3 = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i4 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i4 === void 0 ? void 0 : _options$TEST_ONLY__i4.entryPointParams) !== null && _options$TEST_ONLY__i3 !== void 0 ? _options$TEST_ONLY__i3 : null;
  var isMountedRef = useIsMountedRef_1();
  var undisposedEntryPointReferencesRef = useRef$2(new Set([initialEntryPointReferenceInternal]));

  var _useState = useState$1(initialEntryPointReferenceInternal),
      entryPointReference = _useState[0],
      setEntryPointReference = _useState[1];

  var _useState2 = useState$1(initialEntryPointParamsInternal),
      entryPointParams = _useState2[0],
      setEntryPointParams = _useState2[1];

  var disposeEntryPoint = useCallback(function () {
    if (isMountedRef.current) {
      var nullEntryPointReference = {
        kind: 'NullEntryPointReference'
      };
      undisposedEntryPointReferencesRef.current.add(nullEntryPointReference);
      setEntryPointReference(nullEntryPointReference);
    }
  }, [setEntryPointReference, isMountedRef]);
  var entryPointLoaderCallback = useCallback(function (params) {
    if (isMountedRef.current) {
      var updatedEntryPointReference = loadEntryPoint_1(environmentProvider, entryPoint, params);
      undisposedEntryPointReferencesRef.current.add(updatedEntryPointReference);
      setEntryPointReference(updatedEntryPointReference);
      setEntryPointParams(params);
    }
  }, [environmentProvider, entryPoint, setEntryPointReference, isMountedRef]);
  var maybeHiddenOrFastRefresh = useRef$2(false);
  useEffect$2(function () {
    return function () {
      // Attempt to detect if the component was
      // hidden (by Offscreen API), or fast refresh occured;
      // Only in these situations would the effect cleanup
      // for "unmounting" run multiple times, so if
      // we are ever able to read this ref with a value
      // of true, it means that one of these cases
      // has happened.
      maybeHiddenOrFastRefresh.current = true;
    };
  }, []);
  useEffect$2(function () {
    if (maybeHiddenOrFastRefresh.current === true) {
      // This block only runs if the component has previously "unmounted"
      // due to it being hidden by the Offscreen API, or during fast refresh.
      // At this point, the current entryPointReference will have been disposed
      // by the previous cleanup, so instead of attempting to
      // do our regular commit setup, which would incorrectly leave our
      // current entryPointReference disposed, we need to load the entryPoint again
      // and force a re-render by calling entryPointLoaderCallback again,
      // so that the entryPointReference's queries are correctly re-retained, and
      // potentially refetched if necessary.
      maybeHiddenOrFastRefresh.current = false;

      if (entryPointReference.kind !== 'NullEntryPointReference' && entryPointParams != null) {
        entryPointLoaderCallback(entryPointParams);
      }

      return;
    } // When a new entryPointReference is committed, we iterate over all
    // entrypoint refs in undisposedEntryPointReferences and dispose all of
    // the refs that aren't the currently committed one. This ensures
    // that we don't leave any dangling entrypoint references for the
    // case that loadEntryPoint is called multiple times before commit; when
    // this happens, multiple state updates will be scheduled, but only one
    // will commit, meaning that we need to keep track of and dispose any
    // query references that don't end up committing.
    // - We are relying on the fact that sets iterate in insertion order, and we
    // can remove items from a set as we iterate over it (i.e. no iterator
    // invalidation issues.) Thus, it is safe to loop through
    // undisposedEntryPointReferences until we find entryPointReference, and
    // remove and dispose all previous references.
    // - We are guaranteed to find entryPointReference in the set, because if a
    // state change results in a commit, no state changes initiated prior to that
    // one will be committed, and we are disposing and removing references
    // associated with commits that were initiated prior to the currently
    // committing state change. (A useEffect callback is called during the commit
    // phase.)


    var undisposedEntryPointReferences = undisposedEntryPointReferencesRef.current;

    if (isMountedRef.current) {
      var _iterator = (0, _createForOfIteratorHelper2$a["default"])(undisposedEntryPointReferences),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var undisposedEntryPointReference = _step.value;

          if (undisposedEntryPointReference === entryPointReference) {
            break;
          }

          undisposedEntryPointReferences["delete"](undisposedEntryPointReference);

          if (undisposedEntryPointReference.kind !== 'NullEntryPointReference') {
            undisposedEntryPointReference.dispose();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, [entryPointReference, entryPointParams, entryPointLoaderCallback, isMountedRef]);
  useEffect$2(function () {
    return function disposeAllRemainingEntryPointReferences() {
      // undisposedEntryPointReferences.current is never reassigned
      // eslint-disable-next-line react-hooks/exhaustive-deps
      var _iterator2 = (0, _createForOfIteratorHelper2$a["default"])(undisposedEntryPointReferencesRef.current),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var unhandledStateChange = _step2.value;

          if (unhandledStateChange.kind !== 'NullEntryPointReference') {
            unhandledStateChange.dispose();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    };
  }, []);
  return [entryPointReference.kind === 'NullEntryPointReference' ? null : entryPointReference, entryPointLoaderCallback, disposeEntryPoint];
}

var useEntryPointLoader = useLoadEntryPoint;

/**
 * JS maps (both plain objects and Map) maintain key insertion
 * order, which means there is an easy way to simulate LRU behavior
 * that should also perform quite well:
 *
 * To insert a new value, first delete the key from the inner _map,
 * then _map.set(k, v). By deleting and reinserting, you ensure that the
 * map sees the key as the last inserted key.
 *
 * Get does the same: if the key is present, delete and reinsert it.
 */
var LRUCache = /*#__PURE__*/function () {
  function LRUCache(capacity) {
    this._capacity = capacity;
    !(this._capacity > 0) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'LRUCache: Unable to create instance of cache with zero or negative capacity.') : browser$1(false) : void 0;
    this._map = new Map();
  }

  var _proto = LRUCache.prototype;

  _proto.set = function set(key, value) {
    this._map["delete"](key);

    this._map.set(key, value);

    if (this._map.size > this._capacity) {
      var firstKey = this._map.keys().next();

      if (!firstKey.done) {
        this._map["delete"](firstKey.value);
      }
    }
  };

  _proto.get = function get(key) {
    var value = this._map.get(key);

    if (value != null) {
      this._map["delete"](key);

      this._map.set(key, value);
    }

    return value;
  };

  _proto.has = function has(key) {
    return this._map.has(key);
  };

  _proto["delete"] = function _delete(key) {
    this._map["delete"](key);
  };

  _proto.size = function size() {
    return this._map.size;
  };

  _proto.capacity = function capacity() {
    return this._capacity - this._map.size;
  };

  _proto.clear = function clear() {
    this._map.clear();
  };

  return LRUCache;
}();

function create$3(capacity) {
  return new LRUCache(capacity);
}

var LRUCache_1 = {
  create: create$3
};

var _objectSpread2$h = interopRequireDefault(objectSpread2);

var _toConsumableArray2$5 = interopRequireDefault(toConsumableArray);





var getPromiseForActiveRequest$2 = relayRuntime.__internal.getPromiseForActiveRequest,
    getFragmentIdentifier$1 = relayRuntime.getFragmentIdentifier,
    getSelector$4 = relayRuntime.getSelector,
    isPromise$1 = relayRuntime.isPromise,
    recycleNodesInto$1 = relayRuntime.recycleNodesInto,
    reportMissingRequiredFields$1 = relayRuntime.reportMissingRequiredFields;

var WEAKMAP_SUPPORTED$1 = typeof WeakMap === 'function';
// TODO: Fix to not rely on LRU. If the number of active fragments exceeds this
// capacity, readSpec() will fail to find cached entries and break object
// identity even if data hasn't changed.
var CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array

var CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);

function isMissingData(snapshot) {
  if (Array.isArray(snapshot)) {
    return snapshot.some(function (s) {
      return s.isMissingData;
    });
  }

  return snapshot.isMissingData;
}

function getFragmentResult(cacheKey, snapshot) {
  if (Array.isArray(snapshot)) {
    return {
      cacheKey: cacheKey,
      snapshot: snapshot,
      data: snapshot.map(function (s) {
        return s.data;
      })
    };
  }

  return {
    cacheKey: cacheKey,
    snapshot: snapshot,
    data: snapshot.data
  };
}

function getPromiseForPendingOperationAffectingOwner(environment, request) {
  return environment.getOperationTracker().getPromiseForPendingOperationsAffectingOwner(request);
}

var FragmentResourceImpl = /*#__PURE__*/function () {
  function FragmentResourceImpl(environment) {
    this._environment = environment;
    this._cache = LRUCache_1.create(CACHE_CAPACITY);
  }
  /**
   * This function should be called during a Component's render function,
   * to read the data for a fragment, or suspend if the fragment is being
   * fetched.
   */


  var _proto = FragmentResourceImpl.prototype;

  _proto.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {
    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier$1(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);
  }
  /**
   * Like `read`, but with a pre-computed fragmentIdentifier that should be
   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the
   * arguments.
   */
  ;

  _proto.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {
    var _fragmentNode$metadat;

    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.
    // This is a convenience when consuming fragments via a HOC API, when the
    // prop corresponding to the fragment ref might be passed as null.

    if (fragmentRef == null) {
      return {
        cacheKey: fragmentIdentifier,
        data: null,
        snapshot: null
      };
    } // If fragmentRef is plural, ensure that it is an array.
    // If it's empty, return the empty array directly before doing any more work.


    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {
      !Array.isArray(fragmentRef) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : browser$1(false) : void 0;

      if (fragmentRef.length === 0) {
        return {
          cacheKey: fragmentIdentifier,
          data: CONSTANT_READONLY_EMPTY_ARRAY,
          snapshot: CONSTANT_READONLY_EMPTY_ARRAY
        };
      }
    } // Now we actually attempt to read the fragment:
    // 1. Check if there's a cached value for this fragment


    var cachedValue = this._cache.get(fragmentIdentifier);

    if (cachedValue != null) {
      if (isPromise$1(cachedValue)) {
        throw cachedValue;
      }

      if (cachedValue.snapshot) {
        this._reportMissingRequiredFieldsInSnapshot(cachedValue.snapshot);

        return cachedValue;
      }
    } // 2. If not, try reading the fragment from the Relay store.
    // If the snapshot has data, return it and save it in cache


    var fragmentSelector = getSelector$4(fragmentNode, fragmentRef);
    !(fragmentSelector != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : "the `".concat(fragmentKey, "`"), componentDisplayName) : browser$1(false) : void 0;
    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {
      return environment.lookup(s);
    }) : environment.lookup(fragmentSelector);
    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;

    if (!isMissingData(snapshot)) {
      this._reportMissingRequiredFieldsInSnapshot(snapshot);

      var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot);

      this._cache.set(fragmentIdentifier, fragmentResult);

      return fragmentResult;
    } // 3. If we don't have data in the store, check if a request is in
    // flight for the fragment's parent query, or for another operation
    // that may affect the parent's query data, such as a mutation
    // or subscription. If a promise exists, cache the promise and use it
    // to suspend.


    var networkPromise = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner);

    if (networkPromise != null) {
      throw networkPromise;
    }

    this._reportMissingRequiredFieldsInSnapshot(snapshot);

    return getFragmentResult(fragmentIdentifier, snapshot);
  };

  _proto._reportMissingRequiredFieldsInSnapshot = function _reportMissingRequiredFieldsInSnapshot(snapshot) {
    var _this = this;

    if (Array.isArray(snapshot)) {
      snapshot.forEach(function (s) {
        if (s.missingRequiredFields != null) {
          reportMissingRequiredFields$1(_this._environment, s.missingRequiredFields);
        }
      });
    } else {
      if (snapshot.missingRequiredFields != null) {
        reportMissingRequiredFields$1(this._environment, snapshot.missingRequiredFields);
      }
    }
  };

  _proto.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {
    var result = {};

    for (var _key in fragmentNodes) {
      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);
    }

    return result;
  };

  _proto.subscribe = function subscribe(fragmentResult, callback) {
    var _this2 = this;

    var environment = this._environment;
    var cacheKey = fragmentResult.cacheKey;
    var renderedSnapshot = fragmentResult.snapshot;

    if (!renderedSnapshot) {
      return {
        dispose: function dispose() {}
      };
    } // 1. Check for any updates missed during render phase
    // TODO(T44066760): More efficiently detect if we missed an update


    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),
        didMissUpdates = _this$checkMissedUpda[0],
        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with
    // the latest data.


    if (didMissUpdates) {
      callback();
    } // 3. Establish subscriptions on the snapshot(s)


    var dataSubscriptions = [];

    if (Array.isArray(renderedSnapshot)) {
      !Array.isArray(currentSnapshot) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected snapshots to be plural. ' + "If you're seeing this, this is likely a bug in Relay.") : browser$1(false) : void 0;
      currentSnapshot.forEach(function (snapshot, idx) {
        dataSubscriptions.push(environment.subscribe(snapshot, function (latestSnapshot) {
          _this2._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx);

          callback();
        }));
      });
    } else {
      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected snapshot to be singular. ' + "If you're seeing this, this is likely a bug in Relay.") : browser$1(false) : void 0;
      dataSubscriptions.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {
        _this2._cache.set(cacheKey, getFragmentResult(cacheKey, latestSnapshot));

        callback();
      }));
    }

    return {
      dispose: function dispose() {
        dataSubscriptions.map(function (s) {
          return s.dispose();
        });

        _this2._cache["delete"](cacheKey);
      }
    };
  };

  _proto.subscribeSpec = function subscribeSpec(fragmentResults, callback) {
    var _this3 = this;

    var disposables = Object.keys(fragmentResults).map(function (key) {
      return _this3.subscribe(fragmentResults[key], callback);
    });
    return {
      dispose: function dispose() {
        disposables.forEach(function (disposable) {
          disposable.dispose();
        });
      }
    };
  };

  _proto.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {
    var environment = this._environment;
    var cacheKey = fragmentResult.cacheKey;
    var renderedSnapshot = fragmentResult.snapshot;

    if (!renderedSnapshot) {
      return [false, null];
    }

    var didMissUpdates = false;

    if (Array.isArray(renderedSnapshot)) {
      var currentSnapshots = [];
      renderedSnapshot.forEach(function (snapshot, idx) {
        var currentSnapshot = environment.lookup(snapshot.selector);
        var renderData = snapshot.data;
        var currentData = currentSnapshot.data;
        var updatedData = recycleNodesInto$1(renderData, currentData);

        if (updatedData !== renderData) {
          currentSnapshot = (0, _objectSpread2$h["default"])((0, _objectSpread2$h["default"])({}, currentSnapshot), {}, {
            data: updatedData
          });
          didMissUpdates = true;
        }

        currentSnapshots[idx] = currentSnapshot;
      });

      if (didMissUpdates) {
        this._cache.set(cacheKey, getFragmentResult(cacheKey, currentSnapshots));
      }

      return [didMissUpdates, currentSnapshots];
    }

    var currentSnapshot = environment.lookup(renderedSnapshot.selector);
    var renderData = renderedSnapshot.data;
    var currentData = currentSnapshot.data;
    var updatedData = recycleNodesInto$1(renderData, currentData);
    currentSnapshot = {
      data: updatedData,
      isMissingData: currentSnapshot.isMissingData,
      seenRecords: currentSnapshot.seenRecords,
      selector: currentSnapshot.selector,
      missingRequiredFields: currentSnapshot.missingRequiredFields
    };

    if (updatedData !== renderData) {
      this._cache.set(cacheKey, getFragmentResult(cacheKey, currentSnapshot));

      didMissUpdates = true;
    }

    return [didMissUpdates, currentSnapshot];
  };

  _proto.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {
    var _this4 = this;

    return Object.keys(fragmentResults).some(function (key) {
      return _this4.checkMissedUpdates(fragmentResults[key])[0];
    });
  };

  _proto._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner) {
    var _this5 = this;

    var _getPromiseForActiveR;

    var environment = this._environment;
    var networkPromise = (_getPromiseForActiveR = getPromiseForActiveRequest$2(environment, fragmentOwner)) !== null && _getPromiseForActiveR !== void 0 ? _getPromiseForActiveR : getPromiseForPendingOperationAffectingOwner(environment, fragmentOwner);

    if (!networkPromise) {
      return null;
    } // When the Promise for the request resolves, we need to make sure to
    // update the cache with the latest data available in the store before
    // resolving the Promise


    var promise = networkPromise.then(function () {
      _this5._cache["delete"](cacheKey);
    })["catch"](function (error) {
      _this5._cache["delete"](cacheKey);
    });

    this._cache.set(cacheKey, promise);

    var queryName = fragmentOwner.node.params.name;
    var fragmentName = fragmentNode.name;
    var promiseDisplayName = queryName === fragmentName ? "Relay(".concat(queryName, ")") : "Relay(".concat(queryName, ":").concat(fragmentName, ")"); // $FlowExpectedError[prop-missing] Expando to annotate Promises.

    promise.displayName = promiseDisplayName;
    return promise;
  };

  _proto._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx) {
    var currentFragmentResult = this._cache.get(cacheKey);

    if (isPromise$1(currentFragmentResult)) {
      reportInvalidCachedData(latestSnapshot.selector.node.name);
      return;
    }

    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : currentFragmentResult.snapshot;

    if (currentSnapshot && !Array.isArray(currentSnapshot)) {
      reportInvalidCachedData(latestSnapshot.selector.node.name);
      return;
    }

    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2$5["default"])(currentSnapshot) : (0, _toConsumableArray2$5["default"])(baseSnapshots);
    nextSnapshots[idx] = latestSnapshot;

    this._cache.set(cacheKey, getFragmentResult(cacheKey, nextSnapshots));
  };

  return FragmentResourceImpl;
}();

function reportInvalidCachedData(nodeName) {
   process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + "If you're seeing this, this is likely a bug in Relay.", nodeName) : browser$1(false) ;
}

function createFragmentResource(environment) {
  return new FragmentResourceImpl(environment);
}

var dataResources = WEAKMAP_SUPPORTED$1 ? new WeakMap() : new Map();

function getFragmentResourceForEnvironment(environment) {
  var cached = dataResources.get(environment);

  if (cached) {
    return cached;
  }

  var newDataResource = createFragmentResource(environment);
  dataResources.set(environment, newDataResource);
  return newDataResource;
}

var FragmentResource = {
  createFragmentResource: createFragmentResource,
  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment
};

var getFragmentResourceForEnvironment$1 = FragmentResource.getFragmentResourceForEnvironment;

var useEffect$3 = React__default['default'].useEffect,
    useRef$3 = React__default['default'].useRef,
    useState$2 = React__default['default'].useState;

var getFragmentIdentifier$2 = relayRuntime.getFragmentIdentifier;

function useFragmentNode(fragmentNode, fragmentRef, componentDisplayName) {
  var environment = useRelayEnvironment_1();
  var FragmentResource = getFragmentResourceForEnvironment$1(environment);
  var isMountedRef = useRef$3(false);

  var _useState = useState$2(0),
      forceUpdate = _useState[1];

  var fragmentIdentifier = getFragmentIdentifier$2(fragmentNode, fragmentRef); // Read fragment data; this might suspend.

  var fragmentResult = FragmentResource.readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName);
  var isListeningForUpdatesRef = useRef$3(true);

  function enableStoreUpdates() {
    isListeningForUpdatesRef.current = true;
    var didMissUpdates = FragmentResource.checkMissedUpdates(fragmentResult)[0];

    if (didMissUpdates) {
      handleDataUpdate();
    }
  }

  function disableStoreUpdates() {
    isListeningForUpdatesRef.current = false;
  }

  function handleDataUpdate() {
    if (isMountedRef.current === false || isListeningForUpdatesRef.current === false) {
      return;
    } // React bails out on noop state updates as an optimization.
    // If we want to force an update via setState, we need to pass an value.
    // The actual value can be arbitrary though, e.g. an incremented number.


    forceUpdate(function (count) {
      return count + 1;
    });
  } // Establish Relay store subscriptions in the commit phase, only if
  // rendering for the first time, or if we need to subscribe to new data
  // If the fragment identifier changes, it means that the variables on the
  // fragment owner changed, or the fragment ref points to different records.
  // In this case, we need to resubscribe to the Relay store.


  useEffect$3(function () {
    isMountedRef.current = true;
    var disposable = FragmentResource.subscribe(fragmentResult, handleDataUpdate);
    return function () {
      // When unmounting or resubscribing to new data, clean up current
      // subscription. This will also make sure fragment data is no longer
      // cached so that next time it its read, it will be freshly read from
      // the Relay store
      isMountedRef.current = false;
      disposable.dispose();
    }; // NOTE: We disable react-hooks-deps warning because environment and fragmentIdentifier
    // is capturing all information about whether the effect should be re-ran.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [environment, fragmentIdentifier]);

  if (process$1.env.NODE_ENV !== "production") {
    if (fragmentRef != null && (fragmentResult.data === undefined || Array.isArray(fragmentResult.data) && fragmentResult.data.length > 0 && fragmentResult.data.every(function (data) {
      return data === undefined;
    }))) {
      process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Expected to have been able to read non-null data for ' + 'fragment `%s` declared in ' + '`%s`, since fragment reference was non-null. ' + "Make sure that that `%s`'s parent isn't " + 'holding on to and/or passing a fragment reference for data that ' + 'has been deleted.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;
    }
  }

  return {
    // $FlowFixMe[incompatible-return]
    data: fragmentResult.data,
    disableStoreUpdates: disableStoreUpdates,
    enableStoreUpdates: enableStoreUpdates
  };
}

var useFragmentNode_1 = useFragmentNode;

var useRef$4 = React__default['default'].useRef;

function useStaticFragmentNodeWarning(fragmentNode, warningContext) {
  if (process$1.env.NODE_ENV !== "production") {
    // This is calling `useRef` conditionally, but based on the environment
    // __DEV__ setting which shouldn't change. This allows us to only pay the
    // cost of `useRef` in development mode to produce the warning.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    var initialPropRef = useRef$4(fragmentNode.name);
    process$1.env.NODE_ENV !== "production" ? warning_1(initialPropRef.current === fragmentNode.name, 'Relay: The %s has to remain the same over the lifetime of a component. ' + 'Changing it is not supported and will result in unexpected behavior.', warningContext) : void 0;
  }
}

var useStaticFragmentNodeWarning_1 = useStaticFragmentNodeWarning;

var useTrackLoadQueryInRender$2 = loadQuery_1.useTrackLoadQueryInRender;

var useDebugValue = React__default['default'].useDebugValue;

var getFragment$3 = relayRuntime.getFragment;

function useFragment(fragmentInput, fragmentRef) {
  // We need to use this hook in order to be able to track if
  // loadQuery was called during render
  useTrackLoadQueryInRender$2();
  var fragmentNode = getFragment$3(fragmentInput);
  useStaticFragmentNodeWarning_1(fragmentNode, 'first argument of useFragment()');

  var _useFragmentNode = useFragmentNode_1(fragmentNode, fragmentRef, 'useFragment()'),
      data = _useFragmentNode.data;

  if (process$1.env.NODE_ENV !== "production") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useDebugValue({
      fragment: fragmentNode.name,
      data: data
    });
  }

  return data;
}

var useFragment_1 = useFragment;

var useCallback$1 = React__default['default'].useCallback,
    useEffect$4 = React__default['default'].useEffect,
    useRef$5 = React__default['default'].useRef;

/**
 * This hook returns a mutable React ref that holds the value of whether a
 * fetch request is in flight. The reason this is a mutable ref instead of
 * state is because we don't actually want to trigger an update when this
 * changes, but instead synchronously keep track of whether the network request
 * is in flight, for example in order to bail out of a request if one is
 * already in flight. If this was state, due to the nature of concurrent
 * updates, this value wouldn't be in sync with when the request is actually
 * in flight.
 * The additional functions returned by this Hook can be used to mutate
 * the ref.
 */
function useFetchTrackingRef() {
  var subscriptionRef = useRef$5(null);
  var isFetchingRef = useRef$5(false);
  var disposeFetch = useCallback$1(function () {
    if (subscriptionRef.current != null) {
      subscriptionRef.current.unsubscribe();
      subscriptionRef.current = null;
    }

    isFetchingRef.current = false;
  }, []);
  var startFetch = useCallback$1(function (subscription) {
    subscriptionRef.current = subscription;
    isFetchingRef.current = true;
  }, []);
  var completeFetch = useCallback$1(function () {
    subscriptionRef.current = null;
    isFetchingRef.current = false;
  }, []); // Dipose of ongoing fetch on unmount

  useEffect$4(function () {
    return disposeFetch;
  }, [disposeFetch]);
  return {
    isFetchingRef: isFetchingRef,
    startFetch: startFetch,
    disposeFetch: disposeFetch,
    completeFetch: completeFetch
  };
}

var useFetchTrackingRef_1 = useFetchTrackingRef;

var _objectSpread2$i = interopRequireDefault(objectSpread2);

var _defineProperty2$8 = interopRequireDefault(defineProperty);





var isPromise$2 = relayRuntime.isPromise;

var CACHE_CAPACITY$1 = 1000;
var DEFAULT_FETCH_POLICY = 'store-or-network';
var DATA_RETENTION_TIMEOUT = 5 * 60 * 1000;
var WEAKMAP_SUPPORTED$2 = typeof WeakMap === 'function';

function getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {
  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;
  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();
  var cacheIdentifier = "".concat(fetchPolicy, "-").concat(renderPolicy, "-").concat(operation.request.identifier);

  if (cacheBreaker != null) {
    return "".concat(cacheIdentifier, "-").concat(cacheBreaker);
  }

  return cacheIdentifier;
}

function getQueryResult(operation, cacheIdentifier) {
  var rootFragmentRef = {
    __id: operation.fragment.dataID,
    __fragments: (0, _defineProperty2$8["default"])({}, operation.fragment.node.name, operation.request.variables),
    __fragmentOwner: operation.request
  };
  return {
    cacheIdentifier: cacheIdentifier,
    fragmentNode: operation.request.node.fragment,
    fragmentRef: rootFragmentRef,
    operation: operation
  };
}

var nextID = 200000;

function createCacheEntry(cacheIdentifier, operation, value, networkSubscription, onDispose) {
  var currentValue = value;
  var retainCount = 0;
  var retainDisposable = null;
  var releaseTemporaryRetain = null;
  var currentNetworkSubscription = networkSubscription;

  var retain = function retain(environment) {
    retainCount++;

    if (retainCount === 1) {
      retainDisposable = environment.retain(operation);
    }

    return {
      dispose: function dispose() {
        retainCount = Math.max(0, retainCount - 1);

        if (retainCount === 0) {
          !(retainDisposable != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected disposable to release query to be defined.' + "If you're seeing this, this is likely a bug in Relay.") : browser$1(false) : void 0;
          retainDisposable.dispose();
          retainDisposable = null;
        }

        onDispose(cacheEntry);
      }
    };
  };

  var cacheEntry = {
    cacheIdentifier: cacheIdentifier,
    id: nextID++,
    getValue: function getValue() {
      return currentValue;
    },
    setValue: function setValue(val) {
      currentValue = val;
    },
    getRetainCount: function getRetainCount() {
      return retainCount;
    },
    getNetworkSubscription: function getNetworkSubscription() {
      return currentNetworkSubscription;
    },
    setNetworkSubscription: function setNetworkSubscription(subscription) {
      if (currentNetworkSubscription != null) {
        currentNetworkSubscription.unsubscribe();
      }

      currentNetworkSubscription = subscription;
    },
    temporaryRetain: function temporaryRetain(environment) {
      // NOTE: If we're executing in a server environment, there's no need
      // to create temporary retains, since the component will never commit.
      if (environment.isServer()) {
        return {
          dispose: function dispose() {}
        };
      } // NOTE: temporaryRetain is called during the render phase. However,
      // given that we can't tell if this render will eventually commit or not,
      // we create a timer to autodispose of this retain in case the associated
      // component never commits.
      // If the component /does/ commit, permanentRetain will clear this timeout
      // and permanently retain the data.


      var disposable = retain(environment);
      var releaseQueryTimeout = null;

      var localReleaseTemporaryRetain = function localReleaseTemporaryRetain() {
        clearTimeout(releaseQueryTimeout);
        releaseQueryTimeout = null;
        releaseTemporaryRetain = null;
        disposable.dispose(); // Normally if this entry never commits, the request would've ended by the
        // time this timeout expires and the temporary retain is released. However,
        // we need to do this for live queries which remain open indefinitely.

        if (retainCount <= 0 && currentNetworkSubscription != null) {
          currentNetworkSubscription.unsubscribe();
        }
      };

      releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT); // NOTE: Since temporaryRetain can be called multiple times, we release
      // the previous temporary retain after we re-establish a new one, since
      // we only ever need a single temporary retain until the permanent retain is
      // established.
      // temporaryRetain may be called multiple times by React during the render
      // phase, as well as multiple times by other query components that are
      // rendering the same query/variables.

      if (releaseTemporaryRetain != null) {
        releaseTemporaryRetain();
      }

      releaseTemporaryRetain = localReleaseTemporaryRetain;
      return {
        dispose: function dispose() {
          releaseTemporaryRetain && releaseTemporaryRetain();
        }
      };
    },
    permanentRetain: function permanentRetain(environment) {
      var disposable = retain(environment);

      if (releaseTemporaryRetain != null) {
        releaseTemporaryRetain();
        releaseTemporaryRetain = null;
      }

      return {
        dispose: function dispose() {
          disposable.dispose();

          if (retainCount <= 0 && currentNetworkSubscription != null) {
            currentNetworkSubscription.unsubscribe();
          }
        }
      };
    }
  };
  return cacheEntry;
}

var QueryResourceImpl = /*#__PURE__*/function () {
  function QueryResourceImpl(environment) {
    var _this = this;

    (0, _defineProperty2$8["default"])(this, "_clearCacheEntry", function (cacheEntry) {
      if (cacheEntry.getRetainCount() <= 0) {
        _this._cache["delete"](cacheEntry.cacheIdentifier);
      }
    });
    this._environment = environment;
    this._cache = LRUCache_1.create(CACHE_CAPACITY$1);
  }

  var _proto = QueryResourceImpl.prototype;

  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {
    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);
    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);
  }
  /**
   * This function should be called during a Component's render function,
   * to either read an existing cached value for the query, or fetch the query
   * and suspend.
   */
  ;

  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {
    var environment = this._environment;
    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;
    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy(); // 1. Check if there's a cached value for this operation, and reuse it if
    // it's available

    var cacheEntry = this._cache.get(cacheIdentifier);

    var temporaryRetainDisposable = null;

    if (cacheEntry == null) {
      // 2. If a cached value isn't available, try fetching the operation.
      // _fetchAndSaveQuery will update the cache with either a Promise or
      // an Error to throw, or a QueryResult to return.
      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2$i["default"])((0, _objectSpread2$i["default"])({}, observer), {}, {
        unsubscribe: function unsubscribe(subscription) {
          // 4. If the request is cancelled, make sure to dispose
          // of the temporary retain; this will ensure that a promise
          // doesn't remain unnecessarily cached until the temporary retain
          // expires. Not clearing the temporary retain might cause the
          // query to incorrectly re-suspend.
          if (temporaryRetainDisposable != null) {
            temporaryRetainDisposable.dispose();
          }

          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;
          observerUnsubscribe && observerUnsubscribe(subscription);
        }
      }));
    } // 3. Temporarily retain here in render phase. When the component reading
    // the operation is committed, we will transfer ownership of data retention
    // to the component.
    // In case the component never commits (mounts or updates) from this render,
    // this data retention hold will auto-release itself after a timeout.


    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);
    var cachedValue = cacheEntry.getValue();

    if (isPromise$2(cachedValue) || cachedValue instanceof Error) {
      throw cachedValue;
    }

    return cachedValue;
  }
  /**
   * This function should be called during a component's commit phase
   * (e.g. inside useEffect), in order to retain the operation in the Relay store
   * and transfer ownership of the operation to the component lifecycle.
   */
  ;

  _proto.retain = function retain(queryResult, profilerContext) {
    var environment = this._environment;
    var cacheIdentifier = queryResult.cacheIdentifier,
        operation = queryResult.operation;

    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, queryResult, null);

    var disposable = cacheEntry.permanentRetain(environment);

    environment.__log({
      name: 'queryresource.retain',
      profilerContext: profilerContext,
      resourceID: cacheEntry.id
    });

    return {
      dispose: function dispose() {
        disposable.dispose();
      }
    };
  };

  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {
    var environment = this._environment;
    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);
    return this._cache.get(cacheIdentifier);
  };

  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, value, networkSubscription) {
    var cacheEntry = this._cache.get(cacheIdentifier);

    if (cacheEntry == null) {
      cacheEntry = createCacheEntry(cacheIdentifier, operation, value, networkSubscription, this._clearCacheEntry);

      this._cache.set(cacheIdentifier, cacheEntry);
    }

    return cacheEntry;
  };

  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {
    var _this2 = this;

    var environment = this._environment; // NOTE: Running `check` will write missing data to the store using any
    // missing data handlers specified on the environment;
    // We run it here first to make the handlers get a chance to populate
    // missing data.

    var queryAvailability = environment.check(operation);
    var queryStatus = queryAvailability.status;
    var hasFullQuery = queryStatus === 'available';
    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';
    var shouldFetch;
    var shouldAllowRender;

    var resolveNetworkPromise = function resolveNetworkPromise() {};

    switch (fetchPolicy) {
      case 'store-only':
        {
          shouldFetch = false;
          shouldAllowRender = true;
          break;
        }

      case 'store-or-network':
        {
          shouldFetch = !hasFullQuery;
          shouldAllowRender = canPartialRender;
          break;
        }

      case 'store-and-network':
        {
          shouldFetch = true;
          shouldAllowRender = canPartialRender;
          break;
        }

      case 'network-only':
      default:
        {
          shouldFetch = true;
          shouldAllowRender = false;
          break;
        }
    } // NOTE: If this value is false, we will cache a promise for this
    // query, which means we will suspend here at this query root.
    // If it's true, we will cache the query resource and allow rendering to
    // continue.


    if (shouldAllowRender) {
      var queryResult = getQueryResult(operation, cacheIdentifier);

      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryResult, null, this._clearCacheEntry);

      this._cache.set(cacheIdentifier, _cacheEntry);
    }

    if (shouldFetch) {
      var _queryResult = getQueryResult(operation, cacheIdentifier);

      var networkSubscription;
      fetchObservable.subscribe({
        start: function start(subscription) {
          networkSubscription = subscription;

          var cacheEntry = _this2._cache.get(cacheIdentifier);

          if (cacheEntry) {
            cacheEntry.setNetworkSubscription(networkSubscription);
          }

          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;
          observerStart && observerStart(subscription);
        },
        next: function next() {
          var snapshot = environment.lookup(operation.fragment);

          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, _queryResult, networkSubscription);

          cacheEntry.setValue(_queryResult);
          resolveNetworkPromise();
          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;
          observerNext && observerNext(snapshot);
        },
        error: function error(_error) {
          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, _error, networkSubscription);

          cacheEntry.setValue(_error);
          resolveNetworkPromise();
          networkSubscription = null;
          cacheEntry.setNetworkSubscription(null);
          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;
          observerError && observerError(_error);
        },
        complete: function complete() {
          resolveNetworkPromise();
          networkSubscription = null;

          var cacheEntry = _this2._cache.get(cacheIdentifier);

          if (cacheEntry) {
            cacheEntry.setNetworkSubscription(null);
          }

          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;
          observerComplete && observerComplete();
        },
        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe
      });

      var _cacheEntry2 = this._cache.get(cacheIdentifier);

      if (!_cacheEntry2) {
        var networkPromise = new Promise(function (resolve) {
          resolveNetworkPromise = resolve;
        }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.

        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';
        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, networkPromise, networkSubscription, this._clearCacheEntry);

        this._cache.set(cacheIdentifier, _cacheEntry2);
      }
    } else {
      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;
      observerComplete && observerComplete();
    }

    var cacheEntry = this._cache.get(cacheIdentifier);

    !(cacheEntry != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + "If you're seeing this, this is likely a bug in Relay.") : browser$1(false) : void 0;

    environment.__log({
      name: 'queryresource.fetch',
      resourceID: cacheEntry.id,
      operation: operation,
      profilerContext: profilerContext,
      fetchPolicy: fetchPolicy,
      renderPolicy: renderPolicy,
      queryAvailability: queryAvailability,
      shouldFetch: shouldFetch
    });

    return cacheEntry;
  };

  return QueryResourceImpl;
}();

function createQueryResource(environment) {
  return new QueryResourceImpl(environment);
}

var dataResources$1 = WEAKMAP_SUPPORTED$2 ? new WeakMap() : new Map();

function getQueryResourceForEnvironment(environment) {
  var cached = dataResources$1.get(environment);

  if (cached) {
    return cached;
  }

  var newDataResource = createQueryResource(environment);
  dataResources$1.set(environment, newDataResource);
  return newDataResource;
}

var QueryResource = {
  createQueryResource: createQueryResource,
  getQueryResourceForEnvironment: getQueryResourceForEnvironment,
  getQueryCacheIdentifier: getQueryCacheIdentifier
};

var getQueryResourceForEnvironment$1 = QueryResource.getQueryResourceForEnvironment,
    getQueryCacheIdentifier$1 = QueryResource.getQueryCacheIdentifier;

var useContext$2 = React__default['default'].useContext,
    useEffect$5 = React__default['default'].useEffect,
    useState$3 = React__default['default'].useState,
    useRef$6 = React__default['default'].useRef;

function useLazyLoadQueryNode(_ref) {
  var query = _ref.query,
      componentDisplayName = _ref.componentDisplayName,
      fetchObservable = _ref.fetchObservable,
      fetchPolicy = _ref.fetchPolicy,
      fetchKey = _ref.fetchKey,
      renderPolicy = _ref.renderPolicy;
  var environment = useRelayEnvironment_1();
  var profilerContext = useContext$2(ProfilerContext_1);
  var QueryResource = getQueryResourceForEnvironment$1(environment);

  var _useState = useState$3(0),
      forceUpdateKey = _useState[0],
      forceUpdate = _useState[1];

  var _useFetchTrackingRef = useFetchTrackingRef_1(),
      startFetch = _useFetchTrackingRef.startFetch,
      completeFetch = _useFetchTrackingRef.completeFetch;

  var cacheBreaker = "".concat(forceUpdateKey, "-").concat(fetchKey !== null && fetchKey !== void 0 ? fetchKey : '');
  var cacheIdentifier = getQueryCacheIdentifier$1(environment, query, fetchPolicy, renderPolicy, cacheBreaker);
  var preparedQueryResult = profilerContext.wrapPrepareQueryResource(function () {
    return QueryResource.prepareWithIdentifier(cacheIdentifier, query, fetchObservable, fetchPolicy, renderPolicy, {
      start: startFetch,
      complete: completeFetch,
      error: completeFetch
    }, profilerContext);
  });
  var maybeHiddenOrFastRefresh = useRef$6(false);
  useEffect$5(function () {
    return function () {
      // Attempt to detect if the component was
      // hidden (by Offscreen API), or fast refresh occured;
      // Only in these situations would the effect cleanup
      // for "unmounting" run multiple times, so if
      // we are ever able to read this ref with a value
      // of true, it means that one of these cases
      // has happened.
      maybeHiddenOrFastRefresh.current = true;
    };
  }, []);
  useEffect$5(function () {
    if (maybeHiddenOrFastRefresh.current === true) {
      // This block only runs if the component has previously "unmounted"
      // due to it being hidden by the Offscreen API, or during fast refresh.
      // At this point, the current cached resource will have been disposed
      // by the previous cleanup, so instead of attempting to
      // do our regular commit setup, which would incorrectly attempt to
      // retain a cached query resource that was disposed, we need to force
      // a re-render so that the cache entry for this query is re-intiliazed and
      // and re-evaluated (and potentially cause a refetch).
      maybeHiddenOrFastRefresh.current = false;
      forceUpdate(function (n) {
        return n + 1;
      });
      return;
    }

    var disposable = QueryResource.retain(preparedQueryResult, profilerContext);
    return function () {
      disposable.dispose();
    }; // NOTE: We disable react-hooks-deps warning because the `environment`
    // and `cacheIdentifier` identities are capturing all information about whether
    // the effect should be re-executed and the query re-retained.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [environment, cacheIdentifier]);
  var fragmentNode = preparedQueryResult.fragmentNode,
      fragmentRef = preparedQueryResult.fragmentRef;

  var _useFragmentNode = useFragmentNode_1(fragmentNode, fragmentRef, componentDisplayName),
      data = _useFragmentNode.data;

  return data;
}

var useLazyLoadQueryNode_1 = useLazyLoadQueryNode;

var useMemo$2 = React__default['default'].useMemo,
    useRef$7 = React__default['default'].useRef,
    useState$4 = React__default['default'].useState;

function useMemoVariables(variables) {
  var _variablesChangedGene2;

  // The value of this ref is a counter that should be incremented when
  // variables change. This allows us to use the counter as a
  // memoization value to indicate if the computation for useMemo
  // should be re-executed.
  var variablesChangedGenerationRef = useRef$7(0); // We mirror the variables to check if they have changed between renders

  var _useState = useState$4(variables),
      mirroredVariables = _useState[0],
      setMirroredVariables = _useState[1];

  var variablesChanged = !areEqual_1(variables, mirroredVariables);

  if (variablesChanged) {
    var _variablesChangedGene;

    variablesChangedGenerationRef.current = ((_variablesChangedGene = variablesChangedGenerationRef.current) !== null && _variablesChangedGene !== void 0 ? _variablesChangedGene : 0) + 1;
    setMirroredVariables(variables);
  } // NOTE: We disable react-hooks-deps warning because we explicitly
  // don't want to memoize on object identity
  // eslint-disable-next-line react-hooks/exhaustive-deps


  var memoVariables = useMemo$2(function () {
    return variables;
  }, [variablesChangedGenerationRef.current]);
  return [memoVariables, (_variablesChangedGene2 = variablesChangedGenerationRef.current) !== null && _variablesChangedGene2 !== void 0 ? _variablesChangedGene2 : 0];
}

var useMemoVariables_1 = useMemoVariables;

var createOperationDescriptor$c = relayRuntime.createOperationDescriptor,
    getRequest$b = relayRuntime.getRequest;

var useMemo$3 = React__default['default'].useMemo;

function useMemoOperationDescriptor(gqlQuery, variables, cacheConfig) {
  var _useMemoVariables = useMemoVariables_1(variables),
      memoVariables = _useMemoVariables[0];

  var _useMemoVariables2 = useMemoVariables_1(cacheConfig || {}),
      memoCacheConfig = _useMemoVariables2[0];

  return useMemo$3(function () {
    return createOperationDescriptor$c(getRequest$b(gqlQuery), memoVariables, memoCacheConfig);
  }, [gqlQuery, memoVariables, memoCacheConfig]);
}

var useMemoOperationDescriptor_1 = useMemoOperationDescriptor;

var useTrackLoadQueryInRender$3 = loadQuery_1.useTrackLoadQueryInRender;

var fetchQuery$3 = relayRuntime.__internal.fetchQuery;

function useLazyLoadQuery(gqlQuery, variables, options) {
  // We need to use this hook in order to be able to track if
  // loadQuery was called during render
  useTrackLoadQueryInRender$3();
  var environment = useRelayEnvironment_1();
  var query = useMemoOperationDescriptor_1(gqlQuery, variables, options && options.networkCacheConfig ? options.networkCacheConfig : {
    force: true
  });
  var data = useLazyLoadQueryNode_1({
    componentDisplayName: 'useLazyLoadQuery()',
    fetchKey: options === null || options === void 0 ? void 0 : options.fetchKey,
    fetchObservable: fetchQuery$3(environment, query),
    fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
    query: query,
    renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
  });
  return data;
}

var useLazyLoadQuery_1 = useLazyLoadQuery;

var _objectSpread2$j = interopRequireDefault(objectSpread2);





var defaultCommitMutation = relayRuntime.commitMutation;

var useState$5 = React__default['default'].useState,
    useEffect$6 = React__default['default'].useEffect,
    useRef$8 = React__default['default'].useRef,
    useCallback$2 = React__default['default'].useCallback;



function useMutation(mutation) {
  var commitMutationFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCommitMutation;
  var environment = useRelayEnvironment_1();
  var isMountedRef = useIsMountedRef_1();
  var environmentRef = useRef$8(environment);
  var mutationRef = useRef$8(mutation);
  var inFlightMutationsRef = useRef$8(new Set());

  var _useState = useState$5(false),
      isMutationInFlight = _useState[0],
      setMutationInFlight = _useState[1];

  var cleanup = useCallback$2(function (disposable) {
    if (environmentRef.current === environment && mutationRef.current === mutation) {
      inFlightMutationsRef.current["delete"](disposable);

      if (isMountedRef.current) {
        setMutationInFlight(inFlightMutationsRef.current.size > 0);
      }
    }
  }, [environment, isMountedRef, mutation]);
  useEffect$6(function () {
    if (environmentRef.current !== environment || mutationRef.current !== mutation) {
      inFlightMutationsRef.current = new Set();

      if (isMountedRef.current) {
        setMutationInFlight(false);
      }

      environmentRef.current = environment;
      mutationRef.current = mutation;
    }
  }, [environment, isMountedRef, mutation]);
  var commit = useCallback$2(function (config) {
    var disposable = commitMutationFn(environment, (0, _objectSpread2$j["default"])((0, _objectSpread2$j["default"])({}, config), {}, {
      mutation: mutation,
      onCompleted: function onCompleted(response, errors) {
        cleanup(disposable);
        config.onCompleted && config.onCompleted(response, errors);
      },
      onError: function onError(error) {
        cleanup(disposable);
        config.onError && config.onError(error);
      },
      onUnsubscribe: function onUnsubscribe() {
        cleanup(disposable);
        config.onUnsubscribe && config.onUnsubscribe();
      }
    }));
    inFlightMutationsRef.current.add(disposable);

    if (isMountedRef.current) {
      setMutationInFlight(true);
    }

    return disposable;
  }, [cleanup, commitMutationFn, environment, isMountedRef, mutation]);
  return [commit, isMutationInFlight];
}

var useMutation_1 = useMutation;

function getRefetchMetadata(fragmentNode, componentDisplayName) {
  var _fragmentNode$metadat, _fragmentNode$metadat2;

  !(((_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) !== true) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: getRefetchMetadata(): Expected fragment `%s` not to be plural when using ' + '`%s`. Remove `@relay(plural: true)` from fragment `%s` ' + 'in order to use it with `%s`.', fragmentNode.name, componentDisplayName, fragmentNode.name, componentDisplayName) : browser$1(false) : void 0;
  var refetchMetadata = (_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.refetch;
  !(refetchMetadata != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: getRefetchMetadata(): Expected fragment `%s` to be refetchable when using `%s`. ' + 'Did you forget to add a @refetchable directive to the fragment?', componentDisplayName, fragmentNode.name) : browser$1(false) : void 0; // handle both commonjs and es modules

  var refetchableRequest = refetchMetadata.operation["default"] ? refetchMetadata.operation["default"] : refetchMetadata.operation;
  var fragmentRefPathInResponse = refetchMetadata.fragmentPathInResult;
  !(typeof refetchableRequest !== 'string') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: getRefetchMetadata(): Expected refetch query to be an ' + "operation and not a string when using `%s`. If you're seeing this, " + 'this is likely a bug in Relay.', componentDisplayName) : browser$1(false) : void 0;
  var identifierField = refetchMetadata.identifierField;
  !(identifierField == null || typeof identifierField === 'string') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.') : browser$1(false) : void 0;
  return {
    fragmentRefPathInResponse: fragmentRefPathInResponse,
    identifierField: identifierField,
    refetchableRequest: refetchableRequest,
    refetchMetadata: refetchMetadata
  };
}

var getRefetchMetadata_1 = getRefetchMetadata;

function getPaginationMetadata(fragmentNode, componentDisplayName) {
  var _fragmentNode$metadat, _fragmentNode$metadat2;

  var _getRefetchMetadata = getRefetchMetadata_1(fragmentNode, componentDisplayName),
      paginationRequest = _getRefetchMetadata.refetchableRequest,
      refetchMetadata = _getRefetchMetadata.refetchMetadata;

  var paginationMetadata = refetchMetadata.connection;
  !(paginationMetadata != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' + 'connection when using `%s`. Did you forget to add a @connection ' + 'directive to the connection field in the fragment?', componentDisplayName, fragmentNode.name) : browser$1(false) : void 0;
  var connectionPathInFragmentData = paginationMetadata.path;
  var connectionMetadata = ((_fragmentNode$metadat = (_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.connection) !== null && _fragmentNode$metadat !== void 0 ? _fragmentNode$metadat : [])[0];
  !(connectionMetadata != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' + 'connection when using `%s`. Did you forget to add a @connection ' + 'directive to the connection field in the fragment?', componentDisplayName, fragmentNode.name) : browser$1(false) : void 0;
  var identifierField = refetchMetadata.identifierField;
  !(identifierField == null || typeof identifierField === 'string') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.') : browser$1(false) : void 0;
  return {
    connectionPathInFragmentData: connectionPathInFragmentData,
    identifierField: identifierField,
    paginationRequest: paginationRequest,
    paginationMetadata: paginationMetadata,
    stream: connectionMetadata.stream === true
  };
}

var getPaginationMetadata_1 = getPaginationMetadata;

var _defineProperty2$9 = interopRequireDefault(defineProperty);

var _objectSpread4 = interopRequireDefault(objectSpread2);





function getPaginationVariables(direction, count, cursor, baseVariables, extraVariables, paginationMetadata) {
  var _objectSpread3;

  var backwardMetadata = paginationMetadata.backward,
      forwardMetadata = paginationMetadata.forward;

  if (direction === 'backward') {
    var _objectSpread2;

    !(backwardMetadata != null && backwardMetadata.count != null && backwardMetadata.cursor != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected backward pagination metadata to be available. ' + "If you're seeing this, this is likely a bug in Relay.") : browser$1(false) : void 0;
    process$1.env.NODE_ENV !== "production" ? warning_1(!extraVariables.hasOwnProperty(backwardMetadata.cursor), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain cursor variable `%s`. This variable is automatically ' + 'determined by Relay.', backwardMetadata.cursor) : void 0;
    process$1.env.NODE_ENV !== "production" ? warning_1(!extraVariables.hasOwnProperty(backwardMetadata.count), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain count variable `%s`. This variable is automatically ' + 'determined by Relay.', backwardMetadata.count) : void 0; // $FlowFixMe[cannot-spread-interface]

    var _paginationVariables = (0, _objectSpread4["default"])((0, _objectSpread4["default"])((0, _objectSpread4["default"])({}, baseVariables), extraVariables), {}, (_objectSpread2 = {}, (0, _defineProperty2$9["default"])(_objectSpread2, backwardMetadata.cursor, cursor), (0, _defineProperty2$9["default"])(_objectSpread2, backwardMetadata.count, count), _objectSpread2));

    if (forwardMetadata && forwardMetadata.cursor) {
      _paginationVariables[forwardMetadata.cursor] = null;
    }

    if (forwardMetadata && forwardMetadata.count) {
      _paginationVariables[forwardMetadata.count] = null;
    }

    return _paginationVariables;
  }

  !(forwardMetadata != null && forwardMetadata.count != null && forwardMetadata.cursor != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected forward pagination metadata to be available. ' + "If you're seeing this, this is likely a bug in Relay.") : browser$1(false) : void 0;
  process$1.env.NODE_ENV !== "production" ? warning_1(!extraVariables.hasOwnProperty(forwardMetadata.cursor), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain cursor variable `%s`. This variable is automatically ' + 'determined by Relay.', forwardMetadata.cursor) : void 0;
  process$1.env.NODE_ENV !== "production" ? warning_1(!extraVariables.hasOwnProperty(forwardMetadata.count), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain count variable `%s`. This variable is automatically ' + 'determined by Relay.', forwardMetadata.count) : void 0; // $FlowFixMe[cannot-spread-interface]

  var paginationVariables = (0, _objectSpread4["default"])((0, _objectSpread4["default"])((0, _objectSpread4["default"])({}, baseVariables), extraVariables), {}, (_objectSpread3 = {}, (0, _defineProperty2$9["default"])(_objectSpread3, forwardMetadata.cursor, cursor), (0, _defineProperty2$9["default"])(_objectSpread3, forwardMetadata.count, count), _objectSpread3));

  if (backwardMetadata && backwardMetadata.cursor) {
    paginationVariables[backwardMetadata.cursor] = null;
  }

  if (backwardMetadata && backwardMetadata.count) {
    paginationVariables[backwardMetadata.count] = null;
  }

  return paginationVariables;
}

var getPaginationVariables_1 = getPaginationVariables;

var _createForOfIteratorHelper2$b = interopRequireDefault(createForOfIteratorHelper);



function getValueAtPath(data, path) {
  var result = data;

  var _iterator = (0, _createForOfIteratorHelper2$b["default"])(path),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;

      if (result == null) {
        return null;
      }

      if (typeof key === 'number') {
        !Array.isArray(result) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected an array when extracting value at path. ' + "If you're seeing this, this is likely a bug in Relay.") : browser$1(false) : void 0;
        result = result[key];
      } else {
        !(typeof result === 'object' && !Array.isArray(result)) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected an object when extracting value at path. ' + "If you're seeing this, this is likely a bug in Relay.") : browser$1(false) : void 0;
        result = result[key];
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return result;
}

var getValueAtPath_1 = getValueAtPath;

var getObservableForActiveRequest$1 = relayRuntime.__internal.getObservableForActiveRequest,
    getSelector$5 = relayRuntime.getSelector;

var useEffect$7 = React__default['default'].useEffect,
    useState$6 = React__default['default'].useState,
    useMemo$4 = React__default['default'].useMemo;

function useIsOperationNodeActive(fragmentNode, fragmentRef) {
  var environment = useRelayEnvironment_1();
  var observable = useMemo$4(function () {
    var selector = getSelector$5(fragmentNode, fragmentRef);

    if (selector == null) {
      return null;
    }

    !(selector.kind === 'SingularReaderSelector') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'useIsOperationNodeActive: Plural fragments are not supported.') : browser$1(false) : void 0;
    return getObservableForActiveRequest$1(environment, selector.owner);
  }, [environment, fragmentNode, fragmentRef]);

  var _useState = useState$6(observable != null),
      isActive = _useState[0],
      setIsActive = _useState[1];

  useEffect$7(function () {
    var subscription;
    setIsActive(observable != null);

    if (observable != null) {
      var onCompleteOrError = function onCompleteOrError() {
        setIsActive(false);
      };

      subscription = observable.subscribe({
        complete: onCompleteOrError,
        error: onCompleteOrError
      });
    }

    return function () {
      if (subscription) {
        subscription.unsubscribe();
      }
    };
  }, [observable]);
  return isActive;
}

var useIsOperationNodeActive_1 = useIsOperationNodeActive;

var _objectSpread2$k = interopRequireDefault(objectSpread2);

















var useCallback$3 = React__default['default'].useCallback,
    useEffect$8 = React__default['default'].useEffect,
    useState$7 = React__default['default'].useState;

var ConnectionInterface$2 = relayRuntime.ConnectionInterface,
    fetchQuery$4 = relayRuntime.__internal.fetchQuery,
    createOperationDescriptor$d = relayRuntime.createOperationDescriptor,
    getSelector$6 = relayRuntime.getSelector;

function useLoadMoreFunction(args) {
  var direction = args.direction,
      fragmentNode = args.fragmentNode,
      fragmentRef = args.fragmentRef,
      fragmentIdentifier = args.fragmentIdentifier,
      fragmentData = args.fragmentData,
      connectionPathInFragmentData = args.connectionPathInFragmentData,
      paginationRequest = args.paginationRequest,
      paginationMetadata = args.paginationMetadata,
      componentDisplayName = args.componentDisplayName,
      observer = args.observer,
      onReset = args.onReset,
      identifierField = args.identifierField;
  var environment = useRelayEnvironment_1();

  var _useFetchTrackingRef = useFetchTrackingRef_1(),
      isFetchingRef = _useFetchTrackingRef.isFetchingRef,
      startFetch = _useFetchTrackingRef.startFetch,
      disposeFetch = _useFetchTrackingRef.disposeFetch,
      completeFetch = _useFetchTrackingRef.completeFetch;

  var identifierValue = identifierField != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierField] : null;
  var isMountedRef = useIsMountedRef_1();

  var _useState = useState$7(environment),
      mirroredEnvironment = _useState[0],
      setMirroredEnvironment = _useState[1];

  var _useState2 = useState$7(fragmentIdentifier),
      mirroredFragmentIdentifier = _useState2[0],
      setMirroredFragmentIdentifier = _useState2[1];

  var isParentQueryActive = useIsOperationNodeActive_1(fragmentNode, fragmentRef);
  var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;

  if (shouldReset) {
    disposeFetch();
    onReset();
    setMirroredEnvironment(environment);
    setMirroredFragmentIdentifier(fragmentIdentifier);
  }

  var _getConnectionState = getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData),
      cursor = _getConnectionState.cursor,
      hasMore = _getConnectionState.hasMore; // Dispose of pagination requests in flight when unmounting


  useEffect$8(function () {
    return function () {
      disposeFetch();
    };
  }, [disposeFetch]);
  var loadMore = useCallback$3(function (count, options) {
    // TODO(T41131846): Fetch/Caching policies for loadMore
    var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;

    if (isMountedRef.current !== true) {
      // Bail out and warn if we're trying to paginate after the component
      // has unmounted
      process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Unexpected fetch on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : void 0;
      return {
        dispose: function dispose() {}
      };
    }

    var fragmentSelector = getSelector$6(fragmentNode, fragmentRef);

    if (isFetchingRef.current === true || fragmentData == null || isParentQueryActive) {
      if (fragmentSelector == null) {
        process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Unexpected fetch while using a null fragment ref ' + 'for fragment `%s` in `%s`. When fetching more items, we expect ' + "initial fragment data to be non-null. Please make sure you're " + 'passing a valid fragment ref to `%s` before paginating.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;
      }

      if (onComplete) {
        onComplete(null);
      }

      return {
        dispose: function dispose() {}
      };
    }

    !(fragmentSelector != null && fragmentSelector.kind !== 'PluralReaderSelector') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected to be able to find a non-plural fragment owner for ' + "fragment `%s` when using `%s`. If you're seeing this, " + 'this is likely a bug in Relay.', fragmentNode.name, componentDisplayName) : browser$1(false) : void 0;
    var parentVariables = fragmentSelector.owner.variables;
    var fragmentVariables = fragmentSelector.variables;
    var extraVariables = options === null || options === void 0 ? void 0 : options.UNSTABLE_extraVariables; // $FlowFixMe[cannot-spread-interface]

    var baseVariables = (0, _objectSpread2$k["default"])((0, _objectSpread2$k["default"])({}, parentVariables), fragmentVariables);
    var paginationVariables = getPaginationVariables_1(direction, count, cursor, baseVariables, // $FlowFixMe[cannot-spread-interface]
    (0, _objectSpread2$k["default"])({}, extraVariables), paginationMetadata); // If the query needs an identifier value ('id' or similar) and one
    // was not explicitly provided, read it from the fragment data.

    if (identifierField != null) {
      // @refetchable fragments are guaranteed to have an `id` selection
      // if the type is Node, implements Node, or is @fetchable. Double-check
      // that there actually is a value at runtime.
      if (typeof identifierValue !== 'string') {
        process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierField, identifierValue) : void 0;
      }

      paginationVariables.id = identifierValue;
    }

    var paginationQuery = createOperationDescriptor$d(paginationRequest, paginationVariables, {
      force: true
    });
    fetchQuery$4(environment, paginationQuery).subscribe((0, _objectSpread2$k["default"])((0, _objectSpread2$k["default"])({}, observer), {}, {
      start: function start(subscription) {
        startFetch(subscription);
        observer.start && observer.start(subscription);
      },
      complete: function complete() {
        completeFetch();
        observer.complete && observer.complete();
        onComplete && onComplete(null);
      },
      error: function error(_error) {
        completeFetch();
        observer.error && observer.error(_error);
        onComplete && onComplete(_error);
      }
    }));
    return {
      dispose: disposeFetch
    };
  }, // NOTE: We disable react-hooks-deps warning because all values
  // inside paginationMetadata are static
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [environment, identifierValue, direction, cursor, startFetch, disposeFetch, completeFetch, isFetchingRef, isParentQueryActive, fragmentData, fragmentNode.name, fragmentRef, componentDisplayName]);
  return [loadMore, hasMore, disposeFetch];
}

function getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData) {
  var _pageInfo$END_CURSOR, _pageInfo$START_CURSO;

  var _ConnectionInterface$ = ConnectionInterface$2.get(),
      EDGES = _ConnectionInterface$.EDGES,
      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,
      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,
      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,
      END_CURSOR = _ConnectionInterface$.END_CURSOR,
      START_CURSOR = _ConnectionInterface$.START_CURSOR;

  var connection = getValueAtPath_1(fragmentData, connectionPathInFragmentData);

  if (connection == null) {
    return {
      cursor: null,
      hasMore: false
    };
  }

  !(typeof connection === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected connection in fragment `%s` to have been `null`, or ' + 'a plain object with %s and %s properties. Instead got `%s`.', fragmentNode.name, EDGES, PAGE_INFO, connection) : browser$1(false) : void 0;
  var edges = connection[EDGES];
  var pageInfo = connection[PAGE_INFO];

  if (edges == null || pageInfo == null) {
    return {
      cursor: null,
      hasMore: false
    };
  }

  !Array.isArray(edges) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected connection in fragment `%s` to have a plural `%s` field. ' + 'Instead got `%s`.', fragmentNode.name, EDGES, edges) : browser$1(false) : void 0;
  !(typeof pageInfo === 'object') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected connection in fragment `%s` to have a `%s` field. ' + 'Instead got `%s`.', fragmentNode.name, PAGE_INFO, pageInfo) : browser$1(false) : void 0;
  var cursor = direction === 'forward' ? (_pageInfo$END_CURSOR = pageInfo[END_CURSOR]) !== null && _pageInfo$END_CURSOR !== void 0 ? _pageInfo$END_CURSOR : null : (_pageInfo$START_CURSO = pageInfo[START_CURSOR]) !== null && _pageInfo$START_CURSO !== void 0 ? _pageInfo$START_CURSO : null;
  !(cursor === null || typeof cursor === 'string') ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected page info for connection in fragment `%s` to have a ' + 'valid `%s`. Instead got `%s`.', fragmentNode.name, START_CURSOR, cursor) : browser$1(false) : void 0;
  var hasMore;

  if (direction === 'forward') {
    hasMore = cursor != null && pageInfo[HAS_NEXT_PAGE] === true;
  } else {
    hasMore = cursor != null && pageInfo[HAS_PREV_PAGE] === true;
  }

  return {
    cursor: cursor,
    hasMore: hasMore
  };
}

var useLoadMoreFunction_1 = useLoadMoreFunction;

var _createForOfIteratorHelper2$c = interopRequireDefault(createForOfIteratorHelper);





var loadQuery$2 = loadQuery_1.loadQuery,
    useTrackLoadQueryInRender$4 = loadQuery_1.useTrackLoadQueryInRender;

var useCallback$4 = React__default['default'].useCallback,
    useEffect$9 = React__default['default'].useEffect,
    useRef$9 = React__default['default'].useRef,
    useState$8 = React__default['default'].useState;

var initialNullQueryReferenceState = {
  kind: 'NullQueryReference'
};

function useQueryLoader(preloadableRequest, initialQueryReference) {
  /**
   * We want to always call `queryReference.dispose()` for every call to
   * `setQueryReference(loadQuery(...))` so that no leaks of data in Relay stores
   * will occur.
   *
   * However, a call to `setState(newState)` is not always followed by a commit where
   * this value is reflected in the state. Thus, we cannot reliably clean up each
   * ref with `useEffect(() => () => queryReference.dispose(), [queryReference])`.
   *
   * Instead, we keep track of each call to `loadQuery` in a ref.
   * Relying on the fact that if a state change commits, no state changes that were
   * initiated prior to the currently committing state change will ever subsequently
   * commit, we can safely dispose of all preloaded query references
   * associated with state changes initiated prior to the currently committing state
   * change.
   *
   * Finally, when the hook unmounts, we also dispose of all remaining uncommitted
   * query references.
   */
  var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;
  var environment = useRelayEnvironment_1();
  useTrackLoadQueryInRender$4();
  var isMountedRef = useIsMountedRef_1();
  var undisposedQueryReferencesRef = useRef$9(new Set([initialQueryReferenceInternal]));

  var _useState = useState$8(function () {
    return initialQueryReferenceInternal;
  }),
      queryReference = _useState[0],
      setQueryReference = _useState[1];

  var _useState2 = useState$8(function () {
    return initialQueryReferenceInternal;
  }),
      previousInitialQueryReference = _useState2[0],
      setPreviousInitialQueryReference = _useState2[1];

  if (initialQueryReferenceInternal !== previousInitialQueryReference) {
    // Rendering the query reference makes it "managed" by this hook, so
    // we start keeping track of it so we can dispose it when it is no longer
    // necessary here
    // TODO(T78446637): Handle disposal of managed query references in
    // components that were never mounted after rendering
    undisposedQueryReferencesRef.current.add(initialQueryReferenceInternal);
    setPreviousInitialQueryReference(initialQueryReferenceInternal);
    setQueryReference(initialQueryReferenceInternal);
  }

  var disposeQuery = useCallback$4(function () {
    if (isMountedRef.current) {
      undisposedQueryReferencesRef.current.add(initialNullQueryReferenceState);
      setQueryReference(initialNullQueryReferenceState);
    }
  }, [isMountedRef]);
  var queryLoaderCallback = useCallback$4(function (variables, options) {
    var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {
      fetchPolicy: options.fetchPolicy,
      networkCacheConfig: options.networkCacheConfig,
      __nameForWarning: options.__nameForWarning
    } : options;

    if (isMountedRef.current) {
      var _options$__environmen;

      var updatedQueryReference = loadQuery$2((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);
      undisposedQueryReferencesRef.current.add(updatedQueryReference);
      setQueryReference(updatedQueryReference);
    }
  }, [environment, preloadableRequest, setQueryReference, isMountedRef]);
  var maybeHiddenOrFastRefresh = useRef$9(false);
  useEffect$9(function () {
    return function () {
      // Attempt to detect if the component was
      // hidden (by Offscreen API), or fast refresh occured;
      // Only in these situations would the effect cleanup
      // for "unmounting" run multiple times, so if
      // we are ever able to read this ref with a value
      // of true, it means that one of these cases
      // has happened.
      maybeHiddenOrFastRefresh.current = true;
    };
  }, []);
  useEffect$9(function () {
    if (maybeHiddenOrFastRefresh.current === true) {
      // This block only runs if the component has previously "unmounted"
      // due to it being hidden by the Offscreen API, or during fast refresh.
      // At this point, the current queryReference will have been disposed
      // by the previous cleanup, so instead of attempting to
      // do our regular commit setup, which would incorrectly leave our
      // current queryReference disposed, we need to load the query again
      // and force a re-render by calling queryLoaderCallback again,
      // so that the queryReference is correctly re-retained, and
      // potentially refetched if necessary.
      maybeHiddenOrFastRefresh.current = false;

      if (queryReference.kind !== 'NullQueryReference') {
        queryLoaderCallback(queryReference.variables, {
          fetchPolicy: queryReference.fetchPolicy,
          networkCacheConfig: queryReference.networkCacheConfig
        });
      }

      return;
    } // When a new queryReference is committed, we iterate over all
    // query references in undisposedQueryReferences and dispose all of
    // the refs that aren't the currently committed one. This ensures
    // that we don't leave any dangling query references for the
    // case that loadQuery is called multiple times before commit; when
    // this happens, multiple state updates will be scheduled, but only one
    // will commit, meaning that we need to keep track of and dispose any
    // query references that don't end up committing.
    // - We are relying on the fact that sets iterate in insertion order, and we
    // can remove items from a set as we iterate over it (i.e. no iterator
    // invalidation issues.) Thus, it is safe to loop through
    // undisposedQueryReferences until we find queryReference, and
    // remove and dispose all previous references.
    // - We are guaranteed to find queryReference in the set, because if a
    // state update results in a commit, no state updates initiated prior to that
    // one will be committed, and we are disposing and removing references
    // associated with updates that were scheduled prior to the currently
    // committing state change. (A useEffect callback is called during the commit
    // phase.)


    var undisposedQueryReferences = undisposedQueryReferencesRef.current;

    if (isMountedRef.current) {
      var _iterator = (0, _createForOfIteratorHelper2$c["default"])(undisposedQueryReferences),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var undisposedQueryReference = _step.value;

          if (undisposedQueryReference === queryReference) {
            break;
          }

          undisposedQueryReferences["delete"](undisposedQueryReference);

          if (undisposedQueryReference.kind !== 'NullQueryReference') {
            undisposedQueryReference.dispose && undisposedQueryReference.dispose();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, [queryReference, isMountedRef, queryLoaderCallback]);
  useEffect$9(function () {
    return function disposeAllRemainingQueryReferences() {
      // undisposedQueryReferences.current is never reassigned
      // eslint-disable-next-line react-hooks/exhaustive-deps
      var _iterator2 = (0, _createForOfIteratorHelper2$c["default"])(undisposedQueryReferencesRef.current),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var unhandledStateChange = _step2.value;

          if (unhandledStateChange.kind !== 'NullQueryReference') {
            unhandledStateChange.dispose && unhandledStateChange.dispose();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    };
  }, []);
  return [queryReference.kind === 'NullQueryReference' ? null : queryReference, queryLoaderCallback, disposeQuery];
}

var useQueryLoader_1 = useQueryLoader;

var _objectSpread2$l = interopRequireDefault(objectSpread2);



















var getFragmentResourceForEnvironment$2 = FragmentResource.getFragmentResourceForEnvironment;

var getQueryResourceForEnvironment$2 = QueryResource.getQueryResourceForEnvironment;

var useCallback$5 = React__default['default'].useCallback,
    useContext$3 = React__default['default'].useContext,
    useReducer = React__default['default'].useReducer;

var fetchQuery$5 = relayRuntime.__internal.fetchQuery,
    createOperationDescriptor$e = relayRuntime.createOperationDescriptor,
    getFragmentIdentifier$3 = relayRuntime.getFragmentIdentifier,
    getSelector$7 = relayRuntime.getSelector;

function reducer(state, action) {
  switch (action.type) {
    case 'refetch':
      {
        var _action$refetchEnviro;

        return (0, _objectSpread2$l["default"])((0, _objectSpread2$l["default"])({}, state), {}, {
          fetchPolicy: action.fetchPolicy,
          mirroredEnvironment: (_action$refetchEnviro = action.refetchEnvironment) !== null && _action$refetchEnviro !== void 0 ? _action$refetchEnviro : state.mirroredEnvironment,
          onComplete: action.onComplete,
          refetchEnvironment: action.refetchEnvironment,
          refetchQuery: action.refetchQuery,
          renderPolicy: action.renderPolicy
        });
      }

    case 'reset':
      {
        return {
          fetchPolicy: undefined,
          mirroredEnvironment: action.environment,
          mirroredFragmentIdentifier: action.fragmentIdentifier,
          onComplete: undefined,
          refetchQuery: null,
          renderPolicy: undefined
        };
      }

    default:
      {
        action.type;
        throw new Error('useRefetchableFragmentNode: Unexpected action type');
      }
  }
}

function useRefetchableFragmentNode(fragmentNode, parentFragmentRef, componentDisplayName) {
  var parentEnvironment = useRelayEnvironment_1();

  var _getRefetchMetadata = getRefetchMetadata_1(fragmentNode, componentDisplayName),
      refetchableRequest = _getRefetchMetadata.refetchableRequest,
      fragmentRefPathInResponse = _getRefetchMetadata.fragmentRefPathInResponse,
      identifierField = _getRefetchMetadata.identifierField;

  var fragmentIdentifier = getFragmentIdentifier$3(fragmentNode, parentFragmentRef);

  var _useReducer = useReducer(reducer, {
    fetchPolicy: undefined,
    mirroredEnvironment: parentEnvironment,
    mirroredFragmentIdentifier: fragmentIdentifier,
    onComplete: undefined,
    refetchEnvironment: null,
    refetchQuery: null,
    renderPolicy: undefined
  }),
      refetchState = _useReducer[0],
      dispatch = _useReducer[1];

  var fetchPolicy = refetchState.fetchPolicy,
      mirroredEnvironment = refetchState.mirroredEnvironment,
      mirroredFragmentIdentifier = refetchState.mirroredFragmentIdentifier,
      onComplete = refetchState.onComplete,
      refetchEnvironment = refetchState.refetchEnvironment,
      refetchQuery = refetchState.refetchQuery,
      renderPolicy = refetchState.renderPolicy;
  var environment = refetchEnvironment !== null && refetchEnvironment !== void 0 ? refetchEnvironment : parentEnvironment;
  var QueryResource = getQueryResourceForEnvironment$2(environment);
  var FragmentResource = getFragmentResourceForEnvironment$2(environment);
  var profilerContext = useContext$3(ProfilerContext_1);
  var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;

  var _useQueryLoader = useQueryLoader_1(refetchableRequest),
      queryRef = _useQueryLoader[0],
      loadQuery = _useQueryLoader[1],
      disposeQuery = _useQueryLoader[2];

  var fragmentRef = parentFragmentRef;

  if (shouldReset) {
    dispatch({
      type: 'reset',
      environment: environment,
      fragmentIdentifier: fragmentIdentifier
    });
    disposeQuery();
  } else if (refetchQuery != null && queryRef != null) {
    // If refetch was called, we expect to have a refetchQuery and queryRef
    // in state, since both state updates to set the refetchQuery and the
    // queryRef occur simultaneously.
    // In this case, we need to read the refetched query data (potentially
    // suspending if it's in flight), and extract the new fragment ref
    // from the query in order read the current @refetchable fragment
    // with the updated fragment owner as the new refetchQuery.
    // Before observing the refetch, record the current ID and typename
    // so that, if we are refetching existing data on
    // a field that implements Node, after refetching we
    // can validate that the received data is consistent
    var debugPreviousIDAndTypename;

    if (process$1.env.NODE_ENV !== "production") {
      debugPreviousIDAndTypename = debugFunctions.getInitialIDAndType(refetchQuery.request.variables, fragmentRefPathInResponse, environment);
    }

    var handleQueryCompleted = function handleQueryCompleted(maybeError) {
      onComplete && onComplete(maybeError !== null && maybeError !== void 0 ? maybeError : null);
    }; // The queryRef.source obtained from useQueryLoader will be
    // an observable we can consume /if/ a network request was
    // started. Otherwise, given that QueryResource.prepare
    // always expects an observable we fall back to a new network
    // observable. Note however that if loadQuery did not make a network
    // request, we don't expect to make one here, unless the state of
    // the cache has changed between the call to refetch and this
    // render.


    var fetchObservable = queryRef.source != null ? queryRef.source : fetchQuery$5(environment, refetchQuery); // Now wwe can we read the refetch query here using the
    // queryRef provided from useQueryLoader. Note that the
    // network request is started during the call to refetch,
    // but if the refetch query is still in flight, we will suspend
    // at this point:

    var queryResult = profilerContext.wrapPrepareQueryResource(function () {
      return QueryResource.prepare(refetchQuery, fetchObservable, fetchPolicy, renderPolicy, {
        error: handleQueryCompleted,
        complete: function complete() {
          // Validate that the type of the object we got back matches the type
          // of the object already in the store
          if (process$1.env.NODE_ENV !== "production") {
            debugFunctions.checkSameTypeAfterRefetch(debugPreviousIDAndTypename, environment, fragmentNode, componentDisplayName);
          }

          handleQueryCompleted();
        }
      }, queryRef.fetchKey, profilerContext);
    });
    var queryData = FragmentResource.read(queryResult.fragmentNode, queryResult.fragmentRef, componentDisplayName).data;
    !(queryData != null) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'Relay: Expected to be able to read refetch query response. ' + "If you're seeing this, this is likely a bug in Relay.") : browser$1(false) : void 0; // After reading/fetching the refetch query, we extract from the
    // refetch query response the new fragment ref we need to use to read
    // the fragment. The new fragment ref will point to the refetch query
    // as its fragment owner.

    var refetchedFragmentRef = getValueAtPath_1(queryData, fragmentRefPathInResponse);
    fragmentRef = refetchedFragmentRef;

    if (process$1.env.NODE_ENV !== "production") {
      // Validate that the id of the object we got back matches the id
      // we queried for in the variables.
      // We do this during render instead of onComplete to make sure we are
      // only validating the most recent refetch.
      debugFunctions.checkSameIDAfterRefetch(debugPreviousIDAndTypename, fragmentRef, fragmentNode, componentDisplayName);
    }
  } // We read and subscribe to the fragment using useFragmentNode.
  // If refetch was called, we read the fragment using the new computed
  // fragment ref from the refetch query response; otherwise, we use the
  // fragment ref passed by the caller as normal.


  var _useFragmentNode = useFragmentNode_1(fragmentNode, fragmentRef, componentDisplayName),
      fragmentData = _useFragmentNode.data,
      disableStoreUpdates = _useFragmentNode.disableStoreUpdates,
      enableStoreUpdates = _useFragmentNode.enableStoreUpdates;

  var refetch = useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest);
  return {
    fragmentData: fragmentData,
    fragmentRef: fragmentRef,
    refetch: refetch,
    disableStoreUpdates: disableStoreUpdates,
    enableStoreUpdates: enableStoreUpdates
  };
}

function useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierField, loadQuery, parentFragmentRef, refetchableRequest) {
  var isMountedRef = useIsMountedRef_1();
  var identifierValue = identifierField != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierField] : null;
  return useCallback$5(function (providedRefetchVariables, options) {
    // Bail out and warn if we're trying to refetch after the component
    // has unmounted
    if (isMountedRef.current !== true) {
      process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Unexpected call to `refetch` on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : void 0;
      return {
        dispose: function dispose() {}
      };
    }

    if (parentFragmentRef == null) {
      process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Unexpected call to `refetch` while using a null fragment ref ' + 'for fragment `%s` in `%s`. When calling `refetch`, we expect ' + "initial fragment data to be non-null. Please make sure you're " + 'passing a valid fragment ref to `%s` before calling ' + '`refetch`, or make sure you pass all required variables to `refetch`.', fragmentNode.name, componentDisplayName, componentDisplayName) : void 0;
    }

    var refetchEnvironment = options === null || options === void 0 ? void 0 : options.__environment;
    var fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy;
    var renderPolicy = options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy;
    var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;
    var fragmentSelector = getSelector$7(fragmentNode, parentFragmentRef);
    var parentVariables;
    var fragmentVariables;

    if (fragmentSelector == null) {
      parentVariables = {};
      fragmentVariables = {};
    } else if (fragmentSelector.kind === 'PluralReaderSelector') {
      var _fragmentSelector$sel, _fragmentSelector$sel2, _fragmentSelector$sel3, _fragmentSelector$sel4;

      parentVariables = (_fragmentSelector$sel = (_fragmentSelector$sel2 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel2 === void 0 ? void 0 : _fragmentSelector$sel2.owner.variables) !== null && _fragmentSelector$sel !== void 0 ? _fragmentSelector$sel : {};
      fragmentVariables = (_fragmentSelector$sel3 = (_fragmentSelector$sel4 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel4 === void 0 ? void 0 : _fragmentSelector$sel4.variables) !== null && _fragmentSelector$sel3 !== void 0 ? _fragmentSelector$sel3 : {};
    } else {
      parentVariables = fragmentSelector.owner.variables;
      fragmentVariables = fragmentSelector.variables;
    } // A user of `useRefetchableFragment()` may pass a subset of
    // all variables required by the fragment when calling `refetch()`.
    // We fill in any variables not passed by the call to `refetch()` with the
    // variables from the original parent fragment owner.
    // $FlowFixMe[cannot-spread-interface]


    var refetchVariables = (0, _objectSpread2$l["default"])((0, _objectSpread2$l["default"])((0, _objectSpread2$l["default"])({}, parentVariables), fragmentVariables), providedRefetchVariables); // If the query needs an identifier value ('id' or similar) and one
    // was not explicitly provided, read it from the fragment data.

    if (identifierField != null && !providedRefetchVariables.hasOwnProperty('id')) {
      // @refetchable fragments are guaranteed to have an `id` selection
      // if the type is Node, implements Node, or is @fetchable. Double-check
      // that there actually is a value at runtime.
      if (typeof identifierValue !== 'string') {
        process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierField, identifierValue) : void 0;
      }

      refetchVariables.id = identifierValue;
    }

    var refetchQuery = createOperationDescriptor$e(refetchableRequest, refetchVariables, {
      force: true
    }); // We call loadQuery which will start a network request if necessary
    // and update the querRef from useQueryLoader.
    // Note the following:
    // - loadQuery will dispose of any previously refetched queries.
    // - We use the variables extracted off the OperationDescriptor
    // so that they have been filtered out to include only the
    // variables actually declared in the query.

    loadQuery(refetchQuery.request.variables, {
      fetchPolicy: fetchPolicy,
      __environment: refetchEnvironment,
      __nameForWarning: 'refetch'
    });
    dispatch({
      type: 'refetch',
      fetchPolicy: fetchPolicy,
      onComplete: onComplete,
      refetchEnvironment: refetchEnvironment,
      refetchQuery: refetchQuery,
      renderPolicy: renderPolicy
    });
    return {
      dispose: disposeQuery
    };
  }, // NOTE: We disable react-hooks-deps warning because:
  //   - We know fragmentRefPathInResponse is static, so it can be omitted from
  //     deps
  //   - We know fragmentNode is static, so it can be omitted from deps.
  //   - fragmentNode and parentFragmentRef are also captured by including
  //     fragmentIdentifier
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [fragmentIdentifier, dispatch, disposeQuery, identifierValue]);
}

var debugFunctions;

if (process$1.env.NODE_ENV !== "production") {
  debugFunctions = {
    getInitialIDAndType: function getInitialIDAndType(memoRefetchVariables, fragmentRefPathInResponse, environment) {
      var _require5 = relayRuntime,
          Record = _require5.Record; // $FlowFixMe[prop-missing]


      var id = memoRefetchVariables === null || memoRefetchVariables === void 0 ? void 0 : memoRefetchVariables.id;

      if (fragmentRefPathInResponse.length !== 1 || fragmentRefPathInResponse[0] !== 'node' || id == null) {
        return null;
      }

      var recordSource = environment.getStore().getSource();
      var record = recordSource.get(id);
      var typename = record && Record.getType(record);

      if (typename == null) {
        return null;
      }

      return {
        id: id,
        typename: typename
      };
    },
    checkSameTypeAfterRefetch: function checkSameTypeAfterRefetch(previousIDAndType, environment, fragmentNode, componentDisplayName) {
      var _require6 = relayRuntime,
          Record = _require6.Record;

      if (!previousIDAndType) {
        return;
      }

      var recordSource = environment.getStore().getSource();
      var record = recordSource.get(previousIDAndType.id);
      var typename = record && Record.getType(record);

      if (typename !== previousIDAndType.typename) {
        process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Call to `refetch` returned data with a different ' + '__typename: was `%s`, now `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements' + 'unique id requirement.', previousIDAndType.typename, typename, fragmentNode.name, componentDisplayName) : void 0;
      }
    },
    checkSameIDAfterRefetch: function checkSameIDAfterRefetch(previousIDAndTypename, refetchedFragmentRef, fragmentNode, componentDisplayName) {
      if (previousIDAndTypename == null) {
        return;
      }

      var _require7 = relayRuntime,
          ID_KEY = _require7.ID_KEY; // $FlowExpectedError[incompatible-use]


      var resultID = refetchedFragmentRef[ID_KEY];

      if (resultID != null && resultID !== previousIDAndTypename.id) {
        process$1.env.NODE_ENV !== "production" ? warning_1(false, 'Relay: Call to `refetch` returned a different id, expected ' + '`%s`, got `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements ' + 'unique id requirement.', resultID, previousIDAndTypename.id, fragmentNode.name, componentDisplayName) : void 0;
      }
    }
  };
}

var useRefetchableFragmentNode_1 = useRefetchableFragmentNode;

var _objectSpread2$m = interopRequireDefault(objectSpread2);









var useCallback$6 = React__default['default'].useCallback,
    useDebugValue$1 = React__default['default'].useDebugValue,
    useState$9 = React__default['default'].useState;

var getFragment$4 = relayRuntime.getFragment,
    getFragmentIdentifier$4 = relayRuntime.getFragmentIdentifier;

function usePaginationFragment(fragmentInput, parentFragmentRef) {
  var fragmentNode = getFragment$4(fragmentInput);
  useStaticFragmentNodeWarning_1(fragmentNode, 'first argument of usePaginationFragment()');
  var componentDisplayName = 'usePaginationFragment()';

  var _getPaginationMetadat = getPaginationMetadata_1(fragmentNode, componentDisplayName),
      connectionPathInFragmentData = _getPaginationMetadat.connectionPathInFragmentData,
      paginationRequest = _getPaginationMetadat.paginationRequest,
      paginationMetadata = _getPaginationMetadat.paginationMetadata,
      identifierField = _getPaginationMetadat.identifierField;

  var _useRefetchableFragme = useRefetchableFragmentNode_1(fragmentNode, parentFragmentRef, componentDisplayName),
      fragmentData = _useRefetchableFragme.fragmentData,
      fragmentRef = _useRefetchableFragme.fragmentRef,
      refetch = _useRefetchableFragme.refetch;

  var fragmentIdentifier = getFragmentIdentifier$4(fragmentNode, fragmentRef); // Backward pagination

  var _useLoadMore = useLoadMore({
    componentDisplayName: componentDisplayName,
    connectionPathInFragmentData: connectionPathInFragmentData,
    direction: 'backward',
    fragmentData: fragmentData,
    fragmentIdentifier: fragmentIdentifier,
    fragmentNode: fragmentNode,
    fragmentRef: fragmentRef,
    identifierField: identifierField,
    paginationMetadata: paginationMetadata,
    paginationRequest: paginationRequest
  }),
      loadPrevious = _useLoadMore[0],
      hasPrevious = _useLoadMore[1],
      isLoadingPrevious = _useLoadMore[2],
      disposeFetchPrevious = _useLoadMore[3]; // Forward pagination


  var _useLoadMore2 = useLoadMore({
    componentDisplayName: componentDisplayName,
    connectionPathInFragmentData: connectionPathInFragmentData,
    direction: 'forward',
    fragmentData: fragmentData,
    fragmentIdentifier: fragmentIdentifier,
    fragmentNode: fragmentNode,
    fragmentRef: fragmentRef,
    identifierField: identifierField,
    paginationMetadata: paginationMetadata,
    paginationRequest: paginationRequest
  }),
      loadNext = _useLoadMore2[0],
      hasNext = _useLoadMore2[1],
      isLoadingNext = _useLoadMore2[2],
      disposeFetchNext = _useLoadMore2[3];

  var refetchPagination = useCallback$6(function (variables, options) {
    disposeFetchNext();
    disposeFetchPrevious();
    return refetch(variables, (0, _objectSpread2$m["default"])((0, _objectSpread2$m["default"])({}, options), {}, {
      __environment: undefined
    }));
  }, [disposeFetchNext, disposeFetchPrevious, refetch]);

  if (process$1.env.NODE_ENV !== "production") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useDebugValue$1({
      fragment: fragmentNode.name,
      data: fragmentData,
      hasNext: hasNext,
      isLoadingNext: isLoadingNext,
      hasPrevious: hasPrevious,
      isLoadingPrevious: isLoadingPrevious
    });
  }

  return {
    data: fragmentData,
    loadNext: loadNext,
    loadPrevious: loadPrevious,
    hasNext: hasNext,
    hasPrevious: hasPrevious,
    isLoadingNext: isLoadingNext,
    isLoadingPrevious: isLoadingPrevious,
    refetch: refetchPagination
  };
}

function useLoadMore(args) {
  var _useState = useState$9(false),
      isLoadingMore = _useState[0],
      setIsLoadingMore = _useState[1];

  var observer = {
    start: function start() {
      return setIsLoadingMore(true);
    },
    complete: function complete() {
      return setIsLoadingMore(false);
    },
    error: function error() {
      return setIsLoadingMore(false);
    }
  };

  var handleReset = function handleReset() {
    return setIsLoadingMore(false);
  };

  var _useLoadMoreFunction = useLoadMoreFunction_1((0, _objectSpread2$m["default"])((0, _objectSpread2$m["default"])({}, args), {}, {
    observer: observer,
    onReset: handleReset
  })),
      loadMore = _useLoadMoreFunction[0],
      hasMore = _useLoadMoreFunction[1],
      disposeFetch = _useLoadMoreFunction[2];

  return [loadMore, hasMore, isLoadingMore, disposeFetch];
}

var usePaginationFragment_1 = usePaginationFragment;

var useTrackLoadQueryInRender$5 = loadQuery_1.useTrackLoadQueryInRender;

var useDebugValue$2 = React__default['default'].useDebugValue;

var _require3$__internal = relayRuntime.__internal,
    fetchQueryDeduped$2 = _require3$__internal.fetchQueryDeduped,
    fetchQuery$6 = _require3$__internal.fetchQuery;

function usePreloadedQuery(gqlQuery, preloadedQuery, options) {
  // We need to use this hook in order to be able to track if
  // loadQuery was called during render
  useTrackLoadQueryInRender$5();
  var environment = useRelayEnvironment_1();
  var fetchKey = preloadedQuery.fetchKey,
      fetchPolicy = preloadedQuery.fetchPolicy,
      source = preloadedQuery.source,
      variables = preloadedQuery.variables,
      networkCacheConfig = preloadedQuery.networkCacheConfig;
  var operation = useMemoOperationDescriptor_1(gqlQuery, variables, networkCacheConfig);
  var useLazyLoadQueryNodeParams;

  if (preloadedQuery.kind === 'PreloadedQuery_DEPRECATED') {
    !(operation.request.node.params.name === preloadedQuery.name) ? process$1.env.NODE_ENV !== "production" ? browser$1(false, 'usePreloadedQuery(): Expected data to be prefetched for query `%s`, ' + 'got prefetch results for query `%s`.', operation.request.node.params.name, preloadedQuery.name) : browser$1(false) : void 0;
    useLazyLoadQueryNodeParams = {
      componentDisplayName: 'usePreloadedQuery()',
      fetchKey: fetchKey,
      fetchObservable: fetchQueryDeduped$2(environment, operation.request.identifier, function () {
        if (environment === preloadedQuery.environment && source != null) {
          return environment.executeWithSource({
            operation: operation,
            source: source
          });
        } else {
          return environment.execute({
            operation: operation
          });
        }
      }),
      fetchPolicy: fetchPolicy,
      query: operation,
      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
    };
  } else {
    process$1.env.NODE_ENV !== "production" ? warning_1(preloadedQuery.isDisposed === false, 'usePreloadedQuery(): Expected preloadedQuery to not be disposed yet. ' + 'This is because disposing the query marks it for future garbage ' + 'collection, and as such query results may no longer be present in the Relay ' + 'store. In the future, this will become a hard error.') : void 0;
    var fallbackFetchObservable = fetchQuery$6(environment, operation);
    var fetchObservable;

    if (source != null && environment === preloadedQuery.environment) {
      // If the source observable exists and the environments match, reuse
      // the source observable.
      // If the source observable happens to be empty, we need to fall back
      // and re-execute and de-dupe the query (at render time).
      fetchObservable = source.ifEmpty(fallbackFetchObservable);
    } else if (environment !== preloadedQuery.environment) {
      // If a call to loadQuery is made with a particular environment, and that
      // preloaded query is passed to usePreloadedQuery in a different environment
      // context, we cannot re-use the existing preloaded query.
      // Instead, we need to fall back and re-execute and de-dupe the query with
      // the new environment (at render time).
      // TODO T68036756 track occurences of this warning and turn it into a hard error
      process$1.env.NODE_ENV !== "production" ? warning_1(false, 'usePreloadedQuery(): usePreloadedQuery was passed a preloaded query ' + 'that was created with a different environment than the one that is currently ' + 'in context. In the future, this will become a hard error.') : void 0;
      fetchObservable = fallbackFetchObservable;
    } else {
      // if (source == null)
      // If the source observable does not exist, we need to
      // fall back and re-execute and de-dupe the query (at render time).
      fetchObservable = fallbackFetchObservable;
    }

    useLazyLoadQueryNodeParams = {
      componentDisplayName: 'usePreloadedQuery()',
      fetchObservable: fetchObservable,
      fetchKey: fetchKey,
      fetchPolicy: fetchPolicy,
      query: operation,
      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
    };
  }

  var data = useLazyLoadQueryNode_1(useLazyLoadQueryNodeParams);

  if (process$1.env.NODE_ENV !== "production") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useDebugValue$2({
      query: preloadedQuery.name,
      variables: preloadedQuery.variables,
      data: data,
      fetchKey: fetchKey,
      fetchPolicy: fetchPolicy,
      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
    });
  }

  return data;
}

var usePreloadedQuery_1 = usePreloadedQuery;

var useDebugValue$3 = React__default['default'].useDebugValue;

var getFragment$5 = relayRuntime.getFragment;

function useRefetchableFragment(fragmentInput, fragmentRef) {
  var fragmentNode = getFragment$5(fragmentInput);
  useStaticFragmentNodeWarning_1(fragmentNode, 'first argument of useRefetchableFragment()');

  var _useRefetchableFragme = useRefetchableFragmentNode_1(fragmentNode, fragmentRef, 'useRefetchableFragment()'),
      fragmentData = _useRefetchableFragme.fragmentData,
      refetch = _useRefetchableFragme.refetch;

  if (process$1.env.NODE_ENV !== "production") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useDebugValue$3({
      fragment: fragmentNode.name,
      data: fragmentData
    });
  }
  /* $FlowExpectedError[prop-missing] : Exposed options is a subset of internal
   * options */


  return [fragmentData, refetch];
}

var useRefetchableFragment_1 = useRefetchableFragment;

var useEffect$a = React__default['default'].useEffect,
    useRef$a = React__default['default'].useRef;

/**
 * This hook subscribes a callback to the invalidation state of the given data
 * ids.
 * Any time the invalidation state of the given data ids changes, the provided
 * callback will be called.
 * If new ids or a new callback are provided, the subscription will be
 * re-established and the previous one will be disposed.
 * The subscription will automatically be disposed on unmount
 */
function useSubscribeToInvalidationState(dataIDs, callback) {
  var environment = useRelayEnvironment_1();
  var disposableRef = useRef$a(null);
  var stableDataIDs = Array.from(dataIDs).sort().join('');
  useEffect$a(function () {
    var store = environment.getStore();
    var invalidationState = store.lookupInvalidationState(dataIDs);
    var disposable = store.subscribeToInvalidationState(invalidationState, callback);
    disposableRef.current = disposable;
    return function () {
      return disposable.dispose();
    }; // Intentionally excluding dataIDs, since we're using stableDataIDs
    // instead
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [stableDataIDs, callback, environment]);
  return {
    dispose: function dispose() {
      if (disposableRef.current != null) {
        disposableRef.current.dispose();
      }
    }
  };
}

var useSubscribeToInvalidationState_1 = useSubscribeToInvalidationState;

var requestSubscription$1 = relayRuntime.requestSubscription;

function useSubscription(config, requestSubscriptionFn) {
  // N.B. this will re-subscribe every render if config or requestSubscriptionFn
  // are not memoized.
  // Please do not pass an object defined in-line.
  var actualRequestSubscription = requestSubscriptionFn !== null && requestSubscriptionFn !== void 0 ? requestSubscriptionFn : requestSubscription$1;
  var environment = useRelayEnvironment_1();
  React__default['default'].useEffect(function () {
    var _requestSubscription = requestSubscription$1(environment, config),
        dispose = _requestSubscription.dispose;

    return dispose;
  }, [environment, config, actualRequestSubscription]);
}

var useSubscription_1 = useSubscription;

var loadQuery$3 = loadQuery_1.loadQuery;

/**
 * The public interface to react-relay.
 * Currently contains both Relay Hooks and legacy Container APIs.
 * Will eventually only export the interface from ./hooks.js.
 */
var lib$1 = {
  ConnectionHandler: relayRuntime.ConnectionHandler,
  QueryRenderer: ReactRelayQueryRenderer_1,
  LocalQueryRenderer: ReactRelayLocalQueryRenderer_1,
  MutationTypes: relayRuntime.MutationTypes,
  RangeOperations: relayRuntime.RangeOperations,
  ReactRelayContext: ReactRelayContext,
  applyOptimisticMutation: relayRuntime.applyOptimisticMutation,
  commitLocalUpdate: relayRuntime.commitLocalUpdate,
  commitMutation: relayRuntime.commitMutation,
  createFragmentContainer: ReactRelayFragmentContainer.createContainer,
  createPaginationContainer: ReactRelayPaginationContainer.createContainer,
  createRefetchContainer: ReactRelayRefetchContainer.createContainer,
  fetchQuery_DEPRECATED: relayRuntime.fetchQuery_DEPRECATED,
  graphql: relayRuntime.graphql,
  readInlineData: relayRuntime.readInlineData,
  requestSubscription: relayRuntime.requestSubscription,
  // Relay Hooks
  EntryPointContainer: EntryPointContainer_react,
  RelayEnvironmentProvider: RelayEnvironmentProvider_1,
  fetchQuery: relayRuntime.fetchQuery,
  loadQuery: loadQuery$3,
  loadEntryPoint: loadEntryPoint_1,
  useFragment: useFragment_1,
  useLazyLoadQuery: useLazyLoadQuery_1,
  useEntryPointLoader: useEntryPointLoader,
  useQueryLoader: useQueryLoader_1,
  useMutation: useMutation_1,
  usePaginationFragment: usePaginationFragment_1,
  usePreloadedQuery: usePreloadedQuery_1,
  useRefetchableFragment: useRefetchableFragment_1,
  useRelayEnvironment: useRelayEnvironment_1,
  useSubscribeToInvalidationState: useSubscribeToInvalidationState_1,
  useSubscription: useSubscription_1
};

/**
 * Relay v11.0.2
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var reactRelay = lib$1;

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

function useIsMountedRef$1() {
  var isMountedRef = React.useRef(true);
  React.useEffect(function () {
    isMountedRef.current = true;
    return function () {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef;
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Usage:
 *
 * ```ts
 * const AddCommentMutation = graphql`mutation { ... }`;
 * const [addComment, isCommentPending] = useMutation<MutationType>(AddCommentMutation);
 *
 * const disposable = addComment({ variables: { ... } });
 * ```
 *
 * @see https://github.com/facebook/relay/blob/master/packages/relay-experimental/useMutation.js
 */
function useMutation$1(mutation) {
  var environment = reactRelay.useRelayEnvironment();
  var isMountedRef = useIsMountedRef$1();
  var environmentRef = React.useRef(environment);
  var mutationRef = React.useRef(mutation);
  var inFlightMutationsRef = React.useRef(new Set());

  var _useState = React.useState(false),
      _useState2 = slicedToArray(_useState, 2),
      isMutationInFlight = _useState2[0],
      setMutationInFlight = _useState2[1];

  var cleanup = React.useCallback(function (disposable) {
    if (environmentRef.current === environment && mutationRef.current === mutation) {
      inFlightMutationsRef.current["delete"](disposable);

      if (isMountedRef.current) {
        setMutationInFlight(inFlightMutationsRef.current.size > 0);
      }
    }
  }, [environment, isMountedRef, mutation]);
  var commit = React.useCallback(function () {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      variables: {}
    };
    var disposable = relayRuntime.commitMutation(environment, _objectSpread(_objectSpread({}, config), {}, {
      mutation: mutation,
      onCompleted: function onCompleted(response, errors) {
        var _config$onCompleted;

        cleanup(disposable);
        (_config$onCompleted = config.onCompleted) === null || _config$onCompleted === void 0 ? void 0 : _config$onCompleted.call(config, response, errors);
      },
      onError: function onError(error) {
        var _config$onError;

        // We are usually not handling the `onError` state manually in the code.
        // Would it make sense to have something like generic `uiContext.errorMessage.show()`
        // here when `config.onError` is not defined?
        cleanup(disposable);
        (_config$onError = config.onError) === null || _config$onError === void 0 ? void 0 : _config$onError.call(config, error);
      },
      onUnsubscribe: function onUnsubscribe() {
        cleanup(disposable);
      }
    }));
    inFlightMutationsRef.current.add(disposable);

    if (isMountedRef.current) {
      setMutationInFlight(true);
    }

    return disposable;
  }, [cleanup, environment, isMountedRef, mutation]);
  React.useEffect(function () {
    if (environmentRef.current !== environment || mutationRef.current !== mutation) {
      inFlightMutationsRef.current = new Set();

      if (isMountedRef.current) {
        setMutationInFlight(false);
      }

      environmentRef.current = environment;
      mutationRef.current = mutation;
    }
  }, [environment, isMountedRef, mutation]);
  return [commit, isMutationInFlight];
}

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
var createRelayStore = function createRelayStore(storeProps) {
  return new relayRuntime.Store(new relayRuntime.RecordSource(), _objectSpread$1({
    // This property tells Relay to not immediately clear its cache when the user
    // navigates around the app. Relay will hold onto the specified number of
    // query results, allowing the user to return to recently visited pages
    // and reusing cached data if its available/fresh.
    gcReleaseBufferSize: 10
  }, storeProps));
};

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function requestSubscription$2(environment, config) {
  return relayRuntime.requestSubscription(environment, _objectSpread$2({
    variables: {}
  }, config));
}
/**
 * Please note: you have to memoize the subscription config otherwise the hook would re-subscribe
 * every render. Rather than passing the object defined in-line, do this:
 *
 * ```js
 * useSubscription<SubscriptionType>(
 *     useMemo(() => {
 *         return { ... }
 *     }, [ ... ]),
 * );
 * ```
 *
 * @see https://github.com/facebook/relay/blob/master/packages/relay-experimental/useSubscription.js
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function useSubscription$1(config) {
  // N.B. this will re-subscribe every render if config is not memoized. Please
  // do not pass an object defined in-line.
  var environment = reactRelay.useRelayEnvironment();
  React__default['default'].useEffect(function () {
    var _requestSubscription = requestSubscription$2(environment, config),
        dispose = _requestSubscription.dispose;

    return dispose;
  }, [environment, config]);
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties = _objectWithoutProperties;

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var taggedTemplateLiteral = _taggedTemplateLiteral;

function _templateObject() {
  var data = taggedTemplateLiteral(["\n\tposition: relative;\n\theight: 64px;\n\twidth: 64px;\n\ttop: calc(50% - 32px);\n\tleft: calc(50% - 32px);\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}
var CenteredWrapper = styled__default['default'].div(_templateObject());

(function (LoadingSpinnerSize) {
  LoadingSpinnerSize["LARGE"] = "l";
  LoadingSpinnerSize["EXTRA_LARGE"] = "xl";
})(exports.LoadingSpinnerSize || (exports.LoadingSpinnerSize = {}));

var CenteredLoader = function CenteredLoader(_ref) {
  var _ref$size = _ref.size,
      size = _ref$size === void 0 ? exports.LoadingSpinnerSize.LARGE : _ref$size;
  return /*#__PURE__*/React__default['default'].createElement(CenteredWrapper, null, /*#__PURE__*/React__default['default'].createElement(conventionUiReact.Spinner, {
    size: size
  }));
};

/**
 * This "silent" query renderer purposefully ignores GraphQL errors and loading state and therefore
 * effectively behaves silently (doesn't block UI, immediately calls render method and then again
 * with the fetched data). It's useful when you want to start a query but display something
 * additional only when it's ready or when you want to handle the loading state on your own.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
var QueryRendererSilent = function QueryRendererSilent(props) {
  var _props$variables;

  var RelayEnvironment = reactRelay.useRelayEnvironment();
  var render = React.useCallback(function (_ref) {
    var relayProps = _ref.props,
        relayError = _ref.error,
        relayRetry = _ref.retry;

    if (relayError !== null) {
      throw relayError; // propagate it to the ErrorBoundary
    }

    return props.render(relayProps, relayRetry);
  }, [props]);
  return /*#__PURE__*/React__default['default'].createElement(reactRelay.QueryRenderer, {
    environment: RelayEnvironment,
    fetchPolicy: "store-and-network",
    query: props.query,
    variables: (_props$variables = props.variables) !== null && _props$variables !== void 0 ? _props$variables : {},
    render: render
  });
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
var QueryRenderer = function QueryRenderer(_ref) {
  var _ref$loadingSpinnerSi = _ref.loadingSpinnerSize,
      loadingSpinnerSize = _ref$loadingSpinnerSi === void 0 ? exports.LoadingSpinnerSize.LARGE : _ref$loadingSpinnerSi,
      _ref$DEBUG_haltLoadin = _ref.DEBUG_haltLoading,
      DEBUG_haltLoading = _ref$DEBUG_haltLoadin === void 0 ? false : _ref$DEBUG_haltLoadin,
      render = _ref.render,
      props = objectWithoutProperties(_ref, ["loadingSpinnerSize", "DEBUG_haltLoading", "render"]);

  var renderCallback = React.useCallback(function (relayProps, relayRetry) {
    return relayProps === null ? /*#__PURE__*/React__default['default'].createElement(CenteredLoader, {
      size: loadingSpinnerSize
    }) : render(relayProps, relayRetry);
  }, [props]);

  if (DEBUG_haltLoading) {
    return /*#__PURE__*/React__default['default'].createElement(CenteredLoader, {
      size: loadingSpinnerSize
    });
  }

  return /*#__PURE__*/React__default['default'].createElement(QueryRendererSilent, _extends_1({}, props, {
    render: renderCallback
  }));
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
var TestQueryRenderer = function TestQueryRenderer(props) {
  var _props$variables;

  var render = React.useCallback(function (_ref) {
    var relayProps = _ref.props,
        relayError = _ref.error;

    if (relayProps) {
      return props.render(relayProps);
    } else if (relayError) {
      return /*#__PURE__*/React__default['default'].createElement("div", {
        "data-testid": "error"
      }, "TestQueryRenderer error: ", relayError.message);
    }

    return /*#__PURE__*/React__default['default'].createElement("div", {
      "data-testid": "loading"
    }, "TestQueryRenderer loading\u2026");
  }, [props]);
  return /*#__PURE__*/React__default['default'].createElement(reactRelay.QueryRenderer, {
    environment: props.environment,
    query: props.query,
    variables: (_props$variables = props.variables) !== null && _props$variables !== void 0 ? _props$variables : {},
    render: render
  });
};

var interopRequireDefault$1 = createCommonjsModule(function (module) {
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var interopRequireDefault$2 = createCommonjsModule(function (module) {
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var defineProperty$1 = createCommonjsModule(function (module) {
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var objectWithoutPropertiesLoose$1 = createCommonjsModule(function (module) {
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var objectWithoutProperties$1 = createCommonjsModule(function (module) {
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var setPrototypeOf = createCommonjsModule(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var inherits = createCommonjsModule(function (module) {
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var assertThisInitialized$1 = createCommonjsModule(function (module) {
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var possibleConstructorReturn = createCommonjsModule(function (module) {
var _typeof = _typeof_1["default"];



function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized$1(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var getPrototypeOf = createCommonjsModule(function (module) {
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var isNativeFunction = createCommonjsModule(function (module) {
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var isNativeReflectConstruct = createCommonjsModule(function (module) {
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var construct = createCommonjsModule(function (module) {
function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var wrapNativeSuper = createCommonjsModule(function (module) {
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var sprintf_1 = createCommonjsModule(function (module, exports) {





Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sprintf;

var _typeof2 = interopRequireDefault$2(_typeof_1);

var _inherits2 = interopRequireDefault$2(inherits);

var _possibleConstructorReturn2 = interopRequireDefault$2(possibleConstructorReturn);

var _getPrototypeOf2 = interopRequireDefault$2(getPrototypeOf);

var _wrapNativeSuper2 = interopRequireDefault$2(wrapNativeSuper);

function _wrapRegExp(re, groups) { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = (0, _wrapNativeSuper2.default)(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } (0, _inherits2.default)(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (_typeof_1(args[args.length - 1]) !== "object") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

function maybeReplace(format, pattern, replacementFn) {
  return format.replace(pattern, function (match, lookbehind) {
    // https://caniuse.com/#search=lookbehind
    if (lookbehind === '%') {
      return match;
    }

    var replacement = replacementFn();

    if (replacement === undefined) {
      return match;
    }

    return replacement;
  });
}
/**
 * Simple function for formatting strings. Replaces placeholders with values
 * passed as extra arguments.
 *
 * See: https://nodejs.org/api/util.html#util_util_format_format_args
 */


function sprintf(format) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var argsLength = args.length;

  if (argsLength === 0) {
    return format;
  }

  var index = 0;
  var withString = maybeReplace(format, /*#__PURE__*/_wrapRegExp(/(%)?%s/g, {
    lookbehind: 1
  }), function () {
    return index >= argsLength ? undefined : String(args[index++]);
  });
  var withJSON = maybeReplace(withString, /*#__PURE__*/_wrapRegExp(/(%)?%j/g, {
    lookbehind: 1
  }), function () {
    return index >= argsLength ? undefined : String(JSON.stringify(args[index++], getCircularReplacer()));
  });

  for (index; index < argsLength; index++) {
    withJSON += " ".concat(String(args[index]));
  }

  return withJSON.replace(/%%/g, '%');
}

function getCircularReplacer() {
  var seen = new WeakSet();
  return function (key, value) {
    if ((0, _typeof2.default)(value) === 'object' && value !== null) {
      if (seen.has(value)) {
        return '[Circular]';
      }

      seen.add(value);
    }

    return value;
  };
}
});

var sprintf = /*@__PURE__*/getDefaultExportFromCjs(sprintf_1);

var invariant_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = invariant;

var _sprintf = interopRequireDefault$2(sprintf_1);

/**
 * Use invariant() to assert state which your program assumes to be true.
 * It is intended to indicate a programmer error for a condition that should
 * never occur.
 *
 * Provide sprintf-style format (only %s is supported) and arguments to provide
 * information about what broke and what you were expecting.
 *
 * The invariant message will be stripped in production, but the invariant will
 * remain to ensure logic does not differ in production.
 *
 * TODO: add something like `invariant_violation` which is basically `invariant` but without condition (in cases where it's obvious violation)?
 */
function invariant(condition, format) {
  if (process$1.env.NODE_ENV !== "production") {
    if (format === undefined) {
      throw new Error('invariant(...): Second argument must be a string.');
    }
  }

  if (!condition) {
    var error;

    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      error = new Error(_sprintf.default.apply(void 0, [format].concat(args)));
      error.name = 'Invariant Violation';
    }

    throw error;
  }
}
});

var invariant$1 = /*@__PURE__*/getDefaultExportFromCjs(invariant_1);

var isBrowser_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
// https://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser/31090240#31090240
// eslint-disable-next-line no-new-func
var testIsBrowser = new Function('try {return this===window;}catch(e){ return false;}');

function isBrowser() {
  // We need to add !! to be able to type the return type as boolean
  return !!testIsBrowser();
}
});

var isBrowser = /*@__PURE__*/getDefaultExportFromCjs(isBrowser_1);

var isNumeric_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNumeric;

function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
}
});

var isNumeric = /*@__PURE__*/getDefaultExportFromCjs(isNumeric_1);

var isObject_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isObject;

var _typeof2 = interopRequireDefault$2(_typeof_1);

function isObject(value) {
  return (0, _typeof2.default)(value) === 'object' && value !== null && !Array.isArray(value);
}
});

var isObject = /*@__PURE__*/getDefaultExportFromCjs(isObject_1);

var isObjectEmpty_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isObjectEmpty;

var _isObject = interopRequireDefault$2(isObject_1);

function isObjectEmpty(obj) {
  // https://stackoverflow.com/a/32108184/3135248
  return (0, _isObject.default)(obj) && Object.entries(obj).length === 0 && Object.getOwnPropertyNames(obj).length === 0 && obj.constructor === Object;
}
});

var isObjectEmpty = /*@__PURE__*/getDefaultExportFromCjs(isObjectEmpty_1);

var nullthrows_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nullthrows;

// This is essentially a special case of `invariant` for null values.
function nullthrows(x) {
  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Got unexpected null or undefined.';

  if (x == null) {
    throw new Error(message);
  }

  return x;
}
});

var nullthrows = /*@__PURE__*/getDefaultExportFromCjs(nullthrows_1);

var rangeMap_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rangeMap;

function rangeMap(n, fn) {
  var arr = [];

  while (n > arr.length) {
    arr.push(fn(arr.length));
  }

  return arr;
}
});

var rangeMap = /*@__PURE__*/getDefaultExportFromCjs(rangeMap_1);

var warning_1$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = warning;

var _sprintf = interopRequireDefault$2(sprintf_1);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
function printWarning(format) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var message = _sprintf.default.apply(void 0, [format].concat(args));

  if (typeof console !== 'undefined') {
    console.warn(message); // eslint-disable-line no-console
  }
}

function warning(condition, format) {
  if (process$1.env.NODE_ENV !== "production") {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  }
}
});

var warning$1 = /*@__PURE__*/getDefaultExportFromCjs(warning_1$1);

var src = /*#__PURE__*/Object.freeze({
            __proto__: null,
            invariant: invariant$1,
            isBrowser: isBrowser,
            isNumeric: isNumeric,
            isObject: isObject,
            isObjectEmpty: isObjectEmpty,
            nullthrows: nullthrows,
            rangeMap: rangeMap,
            sprintf: sprintf,
            warning: warning$1
});

var browserPonyfill = createCommonjsModule(function (module, exports) {
var global = typeof self !== 'undefined' ? self : commonjsGlobal;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException;
}
F.prototype = global;
return new F();
})();
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}));
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers;
exports.Request = ctx.Request;
exports.Response = ctx.Response;
module.exports = exports;
});

var fetch = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _crossFetch = interopRequireDefault$2(browserPonyfill);

// Dependency `cross-fetch` takes care of providing correct ponyfill for browsers,
// React Native and Node.js. See: https://github.com/lquixada/cross-fetch/blob/0b198e8f3a8dc7ebad8f973d4a5bce6d00719b8e/package.json#L6-L8
var _default = _crossFetch.default;
exports.default = _default;
});

var setPrototypeOf_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setPrototypeOf;

/**
 * Necessary for Android version of React Native which doesn't support 'Object.setPrototypeOf'.
 *
 * @see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf#Polyfill
 */
function setPrototypeOf(obj, prototype) {
  if (Object.setPrototypeOf) {
    return Object.setPrototypeOf(obj, prototype);
  }

  obj.__proto__ = prototype; // eslint-disable-line no-proto

  return obj;
}
});

var TimeoutError_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _setPrototypeOf = interopRequireDefault$2(setPrototypeOf_1);

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
 */
function TimeoutError(message) {
  var instance = new Error(message);
  (0, _setPrototypeOf.default)(instance, Object.getPrototypeOf(this));

  if (Error.captureStackTrace) {
    Error.captureStackTrace(instance, TimeoutError);
  }

  return instance;
}

TimeoutError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: Error,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
/* $FlowFixMe[incompatible-function-indexer] This comment suppresses an error
 * when upgrading Flow. To see the error delete this comment and run Flow. */

(0, _setPrototypeOf.default)(TimeoutError, Error);
var _default = TimeoutError;
exports.default = _default;
});

var ResponseError_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _setPrototypeOf = interopRequireDefault$2(setPrototypeOf_1);

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
 */
function ResponseError(response, message) {
  var instance = new Error(message); // $FlowExpectedError[prop-missing]: property 'error.response' is unknown in Error (but that's fine, we are extending here)

  instance.response = response;
  (0, _setPrototypeOf.default)(instance, Object.getPrototypeOf(this));

  if (Error.captureStackTrace) {
    Error.captureStackTrace(instance, ResponseError);
  } // $FlowExpectedError[prop-missing]: property 'error.response' is unknown in Error (but that's fine, we are extending here)


  return instance;
}

ResponseError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: Error,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
/* $FlowFixMe[incompatible-function-indexer] This comment suppresses an error
 * when upgrading Flow. To see the error delete this comment and run Flow. */

(0, _setPrototypeOf.default)(ResponseError, Error);
var _default = ResponseError;
exports.default = _default;
});

var _js = /*@__PURE__*/getAugmentedNamespace(src);

var fetchWithRetries_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchWithRetries;
Object.defineProperty(exports, "TimeoutError", {
  enumerable: true,
  get: function get() {
    return _TimeoutError.default;
  }
});
Object.defineProperty(exports, "ResponseError", {
  enumerable: true,
  get: function get() {
    return _ResponseError.default;
  }
});

var _defineProperty2 = interopRequireDefault$2(defineProperty$1);

var _objectWithoutProperties2 = interopRequireDefault$2(objectWithoutProperties$1);



var _fetch = interopRequireDefault$2(fetch);

var _TimeoutError = interopRequireDefault$2(TimeoutError_1);

var _ResponseError = interopRequireDefault$2(ResponseError_1);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_TIMEOUT = 15000;
var DEFAULT_RETRIES = [1000, 3000];

function isNodejs() {
  var _process$versions;

  // Next.js has global `process` object even in Browser so we have to be more thorough here.
  // Please, leave it written exactly like this: we have to first check if `process` exists
  // manually (a?.b would fail otherwise). Then we cannot assume `versions` exist.
  // $FlowExpectedError[unnecessary-optional-chain]: field `versions` doesn't have to exist (see Browsers env)
  return typeof process$1 !== 'undefined' && ((_process$versions = process$1.versions) === null || _process$versions === void 0 ? void 0 : _process$versions.node) !== undefined;
}
/**
 * Makes a request to the server with the given data as the payload.
 * Automatic retries are done based on the values in `retryDelays`.
 */


function fetchWithRetries(resource, initWithRetries) {
  var _ref = initWithRetries !== null && initWithRetries !== void 0 ? initWithRetries : {},
      fetchTimeout = _ref.fetchTimeout,
      retryDelays = _ref.retryDelays,
      initHeaders = _ref.headers,
      init = (0, _objectWithoutProperties2.default)(_ref, ["fetchTimeout", "retryDelays", "headers"]);

  var _fetchTimeout = fetchTimeout != null ? fetchTimeout : DEFAULT_TIMEOUT;

  var _retryDelays = retryDelays != null ? retryDelays : DEFAULT_RETRIES;

  var requestsAttempted = 0;
  var requestStartTime = 0;
  return new Promise(function (resolve, reject) {
    /**
     * Sends a request to the server that will timeout after `fetchTimeout`.
     * If the request fails or times out a new request might be scheduled.
     */
    function sendTimedRequest() {
      requestsAttempted++;
      requestStartTime = Date.now();
      var isRequestAlive = true;
      var environmentHeaders = isNodejs() ? {
        // Cross-fetch uses node-fetch behind the scenes (in Node.js envs) which
        // sets default UA header (https://github.com/bitinn/node-fetch/blob/95286f52bb866283bc69521a04efe1de37b26a33/src/request.js#L225).
        // We overwrite it here to make clear where is this request actually
        // coming from. See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent
        'User-Agent': (0, _js.sprintf)('@adeira/fetch (+https://github.com/adeira/universe; %s)', requestsAttempted)
      } : {};
      var request = (0, _fetch.default)(resource, _objectSpread(_objectSpread({}, init), {}, {
        headers: _objectSpread(_objectSpread({}, environmentHeaders), initHeaders)
      }));
      var requestTimeout = setTimeout(function () {
        isRequestAlive = false;

        if (shouldRetry(requestsAttempted)) {
          retryRequest('HTTP timeout', resource);
        } else {
          reject(new _TimeoutError.default((0, _js.sprintf)("fetchWithRetries: Failed to get response from server (".concat(resource, "), tried %s times."), requestsAttempted)));
        }
      }, _fetchTimeout);
      request.then(function (response) {
        clearTimeout(requestTimeout);

        if (isRequestAlive) {
          // We got a response, we can clear the timeout.
          if (response.status >= 200 && response.status < 300) {
            // Got a response code that indicates success, resolve the promise.
            resolve(response);
          } else if (shouldRetry(requestsAttempted, response.status)) {
            // Fetch was not successful, retrying.
            retryRequest("HTTP error ".concat(response.status), resource);
          } else {
            // Request was not successful, giving up.
            reject(new _ResponseError.default(response, (0, _js.sprintf)('fetchWithRetries: Still no successful response after ' + '%s retries, giving up.', requestsAttempted)));
          }
        }
      }).catch(function (error) {
        clearTimeout(requestTimeout);

        if (shouldRetry(requestsAttempted)) {
          retryRequest(error.message, resource);
        } else {
          reject(error);
        }
      });
    }
    /**
     * Schedules another run of sendTimedRequest based on how much time has
     * passed between the time the last request was sent and now.
     */


    function retryRequest(reason, resource) {
      process$1.env.NODE_ENV !== "production" ? (0, _js.warning)(false, "fetchWithRetries: ".concat(reason, " (").concat(resource, "), retrying.")) : void 0;
      var retryDelay = _retryDelays[requestsAttempted - 1];
      var retryStartTime = requestStartTime + retryDelay; // Schedule retry for a configured duration after last request started.

      setTimeout(sendTimedRequest, retryStartTime - Date.now());
    }
    /**
     * Checks if another attempt should be done to send a request to the server.
     * It returns false for non-transient HTTP status codes like 401 or 403.
     */


    function shouldRetry(attempt, statusCode) {
      var nonTransientCodes = [400, // Bad Request (it's not gonna be better next time)
      401, // Unauthorized (request is not authorized - next time the same)
      403, // Forbidden (server understands but refuses to authorize)
      422, // Unprocessable entity (wrong form body, unlikely to change from retry)
      429 // Too Many Requests (stop DDoS-ing, rate limiting); TODO: take into account `Retry-After` header https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
      // TODO: consider every 4xx code?
      //  https://stackoverflow.com/q/47680711/3135248
      ];

      if (statusCode != null && nonTransientCodes.includes(statusCode)) {
        return false;
      }

      return attempt <= _retryDelays.length;
    }

    sendTimedRequest();
  });
}
});

var defineProperty$2 = createCommonjsModule(function (module) {
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var objectWithoutPropertiesLoose$2 = createCommonjsModule(function (module) {
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var objectWithoutProperties$2 = createCommonjsModule(function (module) {
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var createRelayStore_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRelayStore;



function createRelayStore(records, options) {
  var source = records == null ? new relayRuntime.RecordSource() : new relayRuntime.RecordSource(records);
  return new relayRuntime.Store(source, options);
}
});

var createRequestHandler_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRequestHandler;



function createRequestHandler(customFetcher) {
  return function handleRequest(requestNode, variables, cacheConfig, uploadables) {
    return relayRuntime.Observable.create(function (sink) {
      customFetcher(requestNode, variables, uploadables).then(function (response) {
        if (response.errors) {
          // Relay is currently quite opinionated and recommends to either try to render the data
          // or halt the application. It's a smart decisions since these errors are not for the
          // application users. We conveniently follow this recommendation and always try to
          // render the data. (TODO: allow to log these errors externally)
          //
          // eslint-disable-next-line no-console
          response.errors.map(function (error) {
            return console.warn(error.message, error);
          });
        }

        sink.next(response);
      }).catch(function (error) {
        sink.error(error);
      }).then(function () {
        sink.complete();
      });
      return function cleanup() {// noop, do anything here (called after sink.complete or when Relay unsubscribes)
      };
    });
  };
}
});

var _typeof_1$1 = createCommonjsModule(function (module) {
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var setPrototypeOf$1 = createCommonjsModule(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var inherits$1 = createCommonjsModule(function (module) {
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf$1(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var assertThisInitialized$2 = createCommonjsModule(function (module) {
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var possibleConstructorReturn$1 = createCommonjsModule(function (module) {
var _typeof = _typeof_1$1["default"];



function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized$2(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var getPrototypeOf$1 = createCommonjsModule(function (module) {
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var isNativeFunction$1 = createCommonjsModule(function (module) {
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var isNativeReflectConstruct$1 = createCommonjsModule(function (module) {
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var construct$1 = createCommonjsModule(function (module) {
function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct$1()) {
    module.exports = _construct = Reflect.construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf$1(instance, Class.prototype);
      return instance;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var wrapNativeSuper$1 = createCommonjsModule(function (module) {
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction$1(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct$1(Class, arguments, getPrototypeOf$1(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf$1(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var sprintf_1$1 = createCommonjsModule(function (module, exports) {





Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sprintf;

var _typeof2 = interopRequireDefault$1(_typeof_1$1);

var _inherits2 = interopRequireDefault$1(inherits$1);

var _possibleConstructorReturn2 = interopRequireDefault$1(possibleConstructorReturn$1);

var _getPrototypeOf2 = interopRequireDefault$1(getPrototypeOf$1);

var _wrapNativeSuper2 = interopRequireDefault$1(wrapNativeSuper$1);

function _wrapRegExp(re, groups) { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = (0, _wrapNativeSuper2.default)(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } (0, _inherits2.default)(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (_typeof_1$1(args[args.length - 1]) !== "object") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

function maybeReplace(format, pattern, replacementFn) {
  return format.replace(pattern, function (match, lookbehind) {
    // https://caniuse.com/#search=lookbehind
    if (lookbehind === '%') {
      return match;
    }

    var replacement = replacementFn();

    if (replacement === undefined) {
      return match;
    }

    return replacement;
  });
}
/**
 * Simple function for formatting strings. Replaces placeholders with values
 * passed as extra arguments.
 *
 * See: https://nodejs.org/api/util.html#util_util_format_format_args
 */


function sprintf(format) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var argsLength = args.length;

  if (argsLength === 0) {
    return format;
  }

  var index = 0;
  var withString = maybeReplace(format, /*#__PURE__*/_wrapRegExp(/(%)?%s/g, {
    lookbehind: 1
  }), function () {
    return index >= argsLength ? undefined : String(args[index++]);
  });
  var withJSON = maybeReplace(withString, /*#__PURE__*/_wrapRegExp(/(%)?%j/g, {
    lookbehind: 1
  }), function () {
    return index >= argsLength ? undefined : String(JSON.stringify(args[index++], getCircularReplacer()));
  });

  for (index; index < argsLength; index++) {
    withJSON += " ".concat(String(args[index]));
  }

  return withJSON.replace(/%%/g, '%');
}

function getCircularReplacer() {
  var seen = new WeakSet();
  return function (key, value) {
    if ((0, _typeof2.default)(value) === 'object' && value !== null) {
      if (seen.has(value)) {
        return '[Circular]';
      }

      seen.add(value);
    }

    return value;
  };
}
});

var sprintf$1 = /*@__PURE__*/getDefaultExportFromCjs(sprintf_1$1);

var invariant_1$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = invariant;

var _sprintf = interopRequireDefault$1(sprintf_1$1);

/**
 * Use invariant() to assert state which your program assumes to be true.
 * It is intended to indicate a programmer error for a condition that should
 * never occur.
 *
 * Provide sprintf-style format (only %s is supported) and arguments to provide
 * information about what broke and what you were expecting.
 *
 * The invariant message will be stripped in production, but the invariant will
 * remain to ensure logic does not differ in production.
 *
 * TODO: add something like `invariant_violation` which is basically `invariant` but without condition (in cases where it's obvious violation)?
 */
function invariant(condition, format) {
  if (process$1.env.NODE_ENV !== "production") {
    if (format === undefined) {
      throw new Error('invariant(...): Second argument must be a string.');
    }
  }

  if (!condition) {
    var error;

    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      error = new Error(_sprintf.default.apply(void 0, [format].concat(args)));
      error.name = 'Invariant Violation';
    }

    throw error;
  }
}
});

var invariant$2 = /*@__PURE__*/getDefaultExportFromCjs(invariant_1$1);

var isBrowser_1$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
// https://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser/31090240#31090240
// eslint-disable-next-line no-new-func
var testIsBrowser = new Function('try {return this===window;}catch(e){ return false;}');

function isBrowser() {
  // We need to add !! to be able to type the return type as boolean
  return !!testIsBrowser();
}
});

var isBrowser$1 = /*@__PURE__*/getDefaultExportFromCjs(isBrowser_1$1);

var isNumeric_1$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNumeric;

function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
}
});

var isNumeric$1 = /*@__PURE__*/getDefaultExportFromCjs(isNumeric_1$1);

var isObject_1$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isObject;

var _typeof2 = interopRequireDefault$1(_typeof_1$1);

function isObject(value) {
  return (0, _typeof2.default)(value) === 'object' && value !== null && !Array.isArray(value);
}
});

var isObject$1 = /*@__PURE__*/getDefaultExportFromCjs(isObject_1$1);

var isObjectEmpty_1$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isObjectEmpty;

var _isObject = interopRequireDefault$1(isObject_1$1);

function isObjectEmpty(obj) {
  // https://stackoverflow.com/a/32108184/3135248
  return (0, _isObject.default)(obj) && Object.entries(obj).length === 0 && Object.getOwnPropertyNames(obj).length === 0 && obj.constructor === Object;
}
});

var isObjectEmpty$1 = /*@__PURE__*/getDefaultExportFromCjs(isObjectEmpty_1$1);

var nullthrows_1$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nullthrows;

// This is essentially a special case of `invariant` for null values.
function nullthrows(x) {
  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Got unexpected null or undefined.';

  if (x == null) {
    throw new Error(message);
  }

  return x;
}
});

var nullthrows$1 = /*@__PURE__*/getDefaultExportFromCjs(nullthrows_1$1);

var rangeMap_1$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rangeMap;

function rangeMap(n, fn) {
  var arr = [];

  while (n > arr.length) {
    arr.push(fn(arr.length));
  }

  return arr;
}
});

var rangeMap$1 = /*@__PURE__*/getDefaultExportFromCjs(rangeMap_1$1);

var warning_1$2 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = warning;

var _sprintf = interopRequireDefault$1(sprintf_1$1);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
function printWarning(format) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var message = _sprintf.default.apply(void 0, [format].concat(args));

  if (typeof console !== 'undefined') {
    console.warn(message); // eslint-disable-line no-console
  }
}

function warning(condition, format) {
  if (process$1.env.NODE_ENV !== "production") {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  }
}
});

var warning$2 = /*@__PURE__*/getDefaultExportFromCjs(warning_1$2);

var src$1 = /*#__PURE__*/Object.freeze({
            __proto__: null,
            invariant: invariant$2,
            isBrowser: isBrowser$1,
            isNumeric: isNumeric$1,
            isObject: isObject$1,
            isObjectEmpty: isObjectEmpty$1,
            nullthrows: nullthrows$1,
            rangeMap: rangeMap$1,
            sprintf: sprintf$1,
            warning: warning$2
});

var logGroup_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = logGroup;

/* eslint-disable no-console */
function logGroup(groupMessage, groupBody, groupNote) {
  var groupMessageStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

  if (groupBody == null) {
    console.log('%c%s', 'font-weight:bold', groupMessage);
  } else {
    if (groupNote != null) {
      console.groupCollapsed("%c%s%c%s", "font-weight:bold;".concat(groupMessageStyle), groupMessage, 'font-weight:normal', " - ".concat(groupNote));
    } else {
      console.groupCollapsed("%c%s", "font-weight:bold;".concat(groupMessageStyle), groupMessage);
    }

    groupBody();
    console.groupEnd();
  }
}
});

var _js$1 = /*@__PURE__*/getAugmentedNamespace(src$1);

var RelayLazyLogger_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RelayLazyLogger;

var _defineProperty2 = interopRequireDefault$1(defineProperty$2);



var _logGroup = interopRequireDefault$1(logGroup_1);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var logEventsMap = new Map();

function createGroupMessage(operationName, operationKind) {
  return "[Relay".concat(operationKind != null ? " ".concat(operationKind) : '', "] ").concat(operationName !== null && operationName !== void 0 ? operationName : '');
} // Very similar to the eager one except it waits for the response and prints all the information at once.


function RelayLazyLogger(logEvent) {
  if (!(process$1.env.NODE_ENV !== "production") || !(0, _js$1.isBrowser)()) {
    return;
  }

  if (logEvent.name === 'network.start') {
    logEventsMap.set(logEvent.transactionID, {
      operationKind: logEvent.params.operationKind,
      operationName: logEvent.params.name,
      variables: logEvent.variables
    });
  } else if (logEvent.name === 'network.next') {
    // TODO: log subscriptions as they arrive
    var savedEvent = logEventsMap.get(logEvent.transactionID);

    if (savedEvent) {
      logEventsMap.set(logEvent.transactionID, _objectSpread(_objectSpread({}, savedEvent), {}, {
        response: logEvent.response
      }));
    }
  } else if (logEvent.name === 'network.complete' || logEvent.name === 'network.unsubscribe') {
    var _savedEvent = logEventsMap.get(logEvent.transactionID);

    (0, _logGroup.default)(createGroupMessage(_savedEvent === null || _savedEvent === void 0 ? void 0 : _savedEvent.operationName, _savedEvent === null || _savedEvent === void 0 ? void 0 : _savedEvent.operationKind), function () {
      console.log("Variables: %o", _savedEvent === null || _savedEvent === void 0 ? void 0 : _savedEvent.variables);
      console.log("Response: %o", _savedEvent === null || _savedEvent === void 0 ? void 0 : _savedEvent.response);
    });
  } else if (logEvent.name === 'network.error') {
    var _savedEvent2 = logEventsMap.get(logEvent.transactionID);

    (0, _logGroup.default)(createGroupMessage(_savedEvent2 === null || _savedEvent2 === void 0 ? void 0 : _savedEvent2.operationName, _savedEvent2 === null || _savedEvent2 === void 0 ? void 0 : _savedEvent2.operationKind), function () {
      console.error(logEvent.error);
    }, undefined, 'color:red');
  } else if (logEvent.name === 'entrypoint.root.consume' || logEvent.name === 'network.info' || logEvent.name === 'queryresource.fetch' || logEvent.name === 'queryresource.retain' || logEvent.name === 'store.gc' || logEvent.name === 'store.notify.complete' || logEvent.name === 'store.notify.start' || logEvent.name === 'store.notify.subscription' || logEvent.name === 'store.publish' || logEvent.name === 'store.restore' || logEvent.name === 'store.snapshot') ; else {
    checkEmpty(logEvent);
  }
}

function checkEmpty(logEvent) {
  console.error('Relay: cannot decide how to log event: %s', JSON.stringify(logEvent));
}
});

var createEnvironment_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createEnvironment;

var _defineProperty2 = interopRequireDefault$1(defineProperty$2);

var _objectWithoutProperties2 = interopRequireDefault$1(objectWithoutProperties$2);



var _createRelayStore = interopRequireDefault$1(createRelayStore_1);

var _createRequestHandler = interopRequireDefault$1(createRequestHandler_1);

var _RelayLazyLogger = interopRequireDefault$1(RelayLazyLogger_1);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function createNetwork(fetchFn, subscribeFn) {
  var fetch = (0, _createRequestHandler.default)(fetchFn);
  return relayRuntime.Network.create(fetch, subscribeFn);
}

function createEnvironment(options) {
  var fetchFn = options.fetchFn,
      subscribeFn = options.subscribeFn,
      records = options.records,
      gcReleaseBufferSize = options.gcReleaseBufferSize,
      rest = (0, _objectWithoutProperties2.default)(options, ["fetchFn", "subscribeFn", "records", "gcReleaseBufferSize"]);
  return new relayRuntime.Environment(_objectSpread({
    network: createNetwork(fetchFn, subscribeFn),
    log: _RelayLazyLogger.default,
    store: (0, _createRelayStore.default)(records, {
      gcReleaseBufferSize: gcReleaseBufferSize
    })
  }, rest));
}
});

var createLocalEnvironment_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createLocalEnvironment;



var _createRelayStore = interopRequireDefault$1(createRelayStore_1);

var _RelayLazyLogger = interopRequireDefault$1(RelayLazyLogger_1);

/**
 * This is just an alternative environment factory for LocalQueryRenderer. There is currently not
 * very much API around and should be extended as needed.
 */
function createLocalEnvironment() {
  // $FlowExpectedError[prop-missing]: Network is required in relay flow types
  return new relayRuntime.Environment({
    // notice this environment doesn't have network layer since it's not necessary
    log: _RelayLazyLogger.default,
    store: (0, _createRelayStore.default)()
  });
}
});

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var regenerator = runtime_1;

var asyncToGenerator = createCommonjsModule(function (module) {
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var helpers = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRequestBody = getRequestBody;
exports.getHeaders = exports.handleData = exports.forceFetch = exports.isQuery = exports.isMutation = void 0;

var isMutation = function isMutation(request) {
  return request.operationKind === 'mutation';
};

exports.isMutation = isMutation;

var isQuery = function isQuery(request) {
  return request.operationKind === 'query';
};

exports.isQuery = isQuery;

var forceFetch = function forceFetch(cacheConfig) {
  return !!(cacheConfig && cacheConfig.force);
};

exports.forceFetch = forceFetch;

var handleData = function handleData(response) {
  var contentType = response.headers.get('content-type');

  if (contentType != null && contentType.indexOf('application/json') !== -1) {
    return response.json();
  }

  return response.text();
};

exports.handleData = handleData;

function getRequestBodyWithUploadables(request, variables, uploadables) {
  var formData = new FormData();

  if (process$1.env.NODE_ENV !== "production" && request.text != null) {
    formData.append('query', request.text);
  } else if (request.id != null) {
    formData.append('documentId', request.id);
  } else {
    formData.append('query', request.text);
  }

  formData.append('variables', JSON.stringify(variables));
  Object.keys(uploadables).forEach(function (key) {
    if (Object.prototype.hasOwnProperty.call(uploadables, key)) {
      formData.append(key, uploadables[key]);
    }
  });
  return formData;
}

function getRequestBodyWithoutUplodables(request, variables) {
  var body = {};

  if (process$1.env.NODE_ENV !== "production" && request.text != null) {
    body = {
      query: request.text,
      variables: variables
    };
  } else if (request.id != null) {
    body = {
      documentId: request.id,
      variables: variables
    };
  } else {
    body = {
      query: request.text,
      variables: variables
    };
  }

  return JSON.stringify(body);
}

function getRequestBody(request, variables, uploadables) {
  if (uploadables) {
    return getRequestBodyWithUploadables(request, variables, uploadables);
  }

  return getRequestBodyWithoutUplodables(request, variables);
}

var getHeaders = function getHeaders(uploadables) {
  if (uploadables) {
    return {
      Accept: '*/*'
    };
  }

  return {
    'Accept': 'application/json',
    'Content-type': 'application/json'
  };
};

exports.getHeaders = getHeaders;
});

var createNetworkFetcher_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createNetworkFetcher;

var _regenerator = interopRequireDefault$1(regenerator);

var _defineProperty2 = interopRequireDefault$1(defineProperty$2);

var _asyncToGenerator2 = interopRequireDefault$1(asyncToGenerator);

var _fetch2 = interopRequireDefault$1(fetchWithRetries_1);



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function createNetworkFetcher(graphQLServerURL, additionalHeaders, refetchConfig) {
  return /*#__PURE__*/function () {
    var _fetch = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(request, variables, uploadables) {
      var _yield$additionalHead;

      var body, resolvedAdditionalHeaders, headers, response;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              body = (0, helpers.getRequestBody)(request, variables, uploadables); // sometimes it's necessary to get headers asynchronously (while refreshing authorization
              // token for example) - for this reason we accept object or promise here and we always
              // resolve it as a promise (see tests)

              _context.next = 3;
              return additionalHeaders;

            case 3:
              _context.t1 = _yield$additionalHead = _context.sent;
              _context.t0 = _context.t1 !== null;

              if (!_context.t0) {
                _context.next = 7;
                break;
              }

              _context.t0 = _yield$additionalHead !== void 0;

            case 7:
              if (!_context.t0) {
                _context.next = 11;
                break;
              }

              _context.t2 = _yield$additionalHead;
              _context.next = 12;
              break;

            case 11:
              _context.t2 = {};

            case 12:
              resolvedAdditionalHeaders = _context.t2;
              headers = _objectSpread(_objectSpread({}, (0, helpers.getHeaders)(uploadables)), resolvedAdditionalHeaders);
              _context.next = 16;
              return (0, _fetch2.default)(graphQLServerURL, _objectSpread({
                method: 'POST',
                headers: headers,
                body: body
              }, refetchConfig));

            case 16:
              response = _context.sent;
              return _context.abrupt("return", (0, helpers.handleData)(response));

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function fetch(_x, _x2, _x3) {
      return _fetch.apply(this, arguments);
    }

    return fetch;
  }();
}
});

var getDataFromRequest_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getDataFromRequest;



function getDataFromRequest(_ref, environment) {
  var query = _ref.query,
      variables = _ref.variables;
  var request = (0, relayRuntime.getRequest)(query);
  var operation = (0, relayRuntime.createOperationDescriptor)(request, variables);
  var res = environment.lookup(operation.fragment);
  return res.data;
}
});

var RelayDebugLogger_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RelayDebugLogger;

var _objectWithoutProperties2 = interopRequireDefault$1(objectWithoutProperties$2);



var _logGroup = interopRequireDefault$1(logGroup_1);

/* eslint-disable no-console */
function RelayDebugLogger(logEvent) {
  if (!(process$1.env.NODE_ENV !== "production") || !(0, _js$1.isBrowser)()) {
    return;
  }

  var name = logEvent.name,
      logEventParams = (0, _objectWithoutProperties2.default)(logEvent, ["name"]); // this logger simply logs everything

  (0, _logGroup.default)("[Relay] ".concat(logEvent.name), function () {
    console.log(logEventParams);
  });
}
});

var RelayEagerLogger_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RelayEagerLogger;



var _logGroup = interopRequireDefault$1(logGroup_1);

/* eslint-disable no-console */
// See: https://github.com/facebook/relay/commit/da9a57cb0b7ab9bedf82e3d1dddc17a0ad9e4d92
function RelayEagerLogger(logEvent) {
  if (!(process$1.env.NODE_ENV !== "production") || !(0, _js$1.isBrowser)()) {
    return;
  }

  var transactionID = logEvent.transactionID != null ? logEvent.transactionID : 99998; // so it clearly results in "-1"

  var groupMessage = "[Relay ".concat(transactionID - 99999, "] ").concat(logEvent.name);

  if (logEvent.name === 'network.start') {
    var _logEvent$params$text, _logEvent$params$text2, _logEvent$params$text3, _logEvent$params$text4;

    (0, _logGroup.default)(groupMessage, function () {
      console.log("Variables: %o", logEvent.variables);
      console.log(logEvent.params.text); // TODO: ID for persistent queries
    }, "".concat(logEvent.params.name, " ").concat(logEvent.params.operationKind === 'mutation' ? "\uD83D\uDCDD (".concat((_logEvent$params$text = (_logEvent$params$text2 = logEvent.params.text) === null || _logEvent$params$text2 === void 0 ? void 0 : _logEvent$params$text2.length) !== null && _logEvent$params$text !== void 0 ? _logEvent$params$text : 0, ")") : "\uD83D\uDD0D (".concat((_logEvent$params$text3 = (_logEvent$params$text4 = logEvent.params.text) === null || _logEvent$params$text4 === void 0 ? void 0 : _logEvent$params$text4.length) !== null && _logEvent$params$text3 !== void 0 ? _logEvent$params$text3 : 0, ")")));
  } else if (logEvent.name === 'network.next') {
    if (Array.isArray(logEvent.response)) {
      // we do not support batch response with @stream yet
      console.warn(logEvent.response);
    } else if (logEvent.response.errors !== undefined) {
      (0, _logGroup.default)(groupMessage, function () {
        console.log("Response: %o", logEvent.response);
      }, 'partial response with errors', 'color:orange');
    } else {
      (0, _logGroup.default)(groupMessage, function () {
        console.log("Response: %o", logEvent.response);
      });
    }
  } else if (logEvent.name === 'network.error') {
    (0, _logGroup.default)(groupMessage, function () {
      console.error(logEvent.error);
    }, undefined, 'color:red');
  } else if (logEvent.name === 'network.complete' || logEvent.name === 'network.unsubscribe') {
    (0, _logGroup.default)(groupMessage);
  } else if (logEvent.name === 'entrypoint.root.consume' || logEvent.name === 'network.info' || logEvent.name === 'queryresource.fetch' || logEvent.name === 'queryresource.retain' || logEvent.name === 'store.gc' || logEvent.name === 'store.notify.complete' || logEvent.name === 'store.notify.start' || logEvent.name === 'store.notify.subscription' || logEvent.name === 'store.publish' || logEvent.name === 'store.restore' || logEvent.name === 'store.snapshot') ; else {
    checkEmpty(logEvent);
  }
}

function checkEmpty(logEvent) {
  console.error('Relay: cannot decide how to log event: %s', JSON.stringify(logEvent));
}
});

var mutations = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commitMutation = commitMutation;
exports.commitMutationAsync = commitMutationAsync;

var _defineProperty2 = interopRequireDefault$1(defineProperty$2);



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * The first parameter `environment` should be from `props.relay.environment`
 * to ensure the mutation is performed in the correct environment.
 *
 * Correct usage of generated flow types for "commitMutation" function:
 *
 * import type { NamedMutation } from './__generated__/NamedMutation.graphql';
 *
 * commitMutation<NamedMutation>(...)
 */
function commitMutation(environment, config) {
  // Let's stay with our flow types for now, since they are better than relay's at the moment.
  // One example is RangeBehaviorsFunction, where relay has: [name: string]: $FlowFixMe, while
  // we have the actual allowed rangebehaviors
  // $FlowExpectedError[incompatible-call]
  // $FlowExpectedError[incompatible-variance]
  // $FlowExpectedError[prop-missing]
  return (0, reactRelay.commitMutation)(environment, config);
}

/**
 * commitMutation function wrapped in Promise
 *
 * More convenient way for the most use cases, but be aware of implications:
 * https://github.com/facebook/relay/issues/1822#issuecomment-304576683
 *
 * Notes:
 * - Promise is successfully resolved even when you get errors from server - you might still get partial data.
 * - You should also never rely on these errors. Instead, make errors part of your schema if possible.
 */
function commitMutationAsync(environment, config) {
  return new Promise(function (resolve, reject) {
    var enhancedConfig = _objectSpread(_objectSpread({}, config), {}, {
      onCompleted: function onCompleted(response, errors) {
        return resolve({
          response: response,
          errors: errors
        });
      },
      onError: function onError(error) {
        return reject(error);
      }
    });

    commitMutation(environment, enhancedConfig);
  });
}
});

var createFragmentContainer_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createFragmentContainer;





/**
 * @deprecated use `useFragment` instead
 */
function createFragmentContainer(Component, fragmentSpec) {
  // TODO: should we do a proper check here and validate the fragment spec?
  !((0, _js$1.isObjectEmpty)(fragmentSpec) === false) ? process$1.env.NODE_ENV !== "production" ? (0, _js$1.invariant)(false, 'Fragment spec of this fragment container factory cannot be empty.') : (0, _js$1.invariant)(false) : void 0;
  return (0, reactRelay.createFragmentContainer)(Component, fragmentSpec);
}
});

var createPaginationContainer_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createPaginationContainer;





/**
 * @deprecated use `usePaginationFragment` instead
 */
function createPaginationContainer(Component, fragmentSpec, connectionConfig) {
  !((0, _js$1.isObjectEmpty)(fragmentSpec) === false) ? process$1.env.NODE_ENV !== "production" ? (0, _js$1.invariant)(false, 'Fragment spec of this pagination container factory cannot be empty.') : (0, _js$1.invariant)(false) : void 0;
  return (0, reactRelay.createPaginationContainer)(Component, fragmentSpec, connectionConfig);
}
});

var createRefetchContainer_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRefetchContainer;





/**
 * @deprecated use `useRefetchableFragment` instead
 */
function createRefetchContainer(Component, fragmentSpec, refetchQuery) {
  !((0, _js$1.isObjectEmpty)(fragmentSpec) === false) ? process$1.env.NODE_ENV !== "production" ? (0, _js$1.invariant)(false, 'Fragment spec of this refetch container factory cannot be empty.') : (0, _js$1.invariant)(false) : void 0;
  return (0, reactRelay.createRefetchContainer)(Component, fragmentSpec, refetchQuery);
}
});

var LocalQueryRenderer_1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = LocalQueryRenderer;

var _defineProperty2 = interopRequireDefault$1(defineProperty$2);

var _objectWithoutProperties2 = interopRequireDefault$1(objectWithoutProperties$2);







var _createLocalEnvironment = interopRequireDefault$1(createLocalEnvironment_1);



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Please note: we are currently only wrapping this component to add it correct Flow types.
// Eventually, it can be extended with other functions like original QueryRenderer.
function LocalQueryRenderer(props) {
  var _ref2, _props$environment;

  function renderQueryRendererResponse(_ref) {
    var rendererProps = _ref.props;

    if (!rendererProps) {
      return props.onLoading ? props.onLoading() : /*#__PURE__*/(0, _jsxRuntime__default['default'].jsx)("div", {
        "data-testid": "loading",
        children: "Loading local..."
      });
    }

    !(props.onResponse !== undefined) ? process$1.env.NODE_ENV !== "production" ? (0, _js$1.invariant)(false, 'LocalQueryRenderer used default render function but "onResponse" property has not been provided.') : (0, _js$1.invariant)(false) : void 0;
    return props.onResponse(rendererProps);
  } // 1) <LQR environment={Env} /> always win
  // 2) <LQR /> checks whether we provide Environment via `RelayEnvironmentProvider`
  // 3) <LQR /> defaults to the default local environment


  var context = (0, React__default['default'].useContext)(reactRelay.ReactRelayContext);
  var environment = (_ref2 = (_props$environment = props.environment) !== null && _props$environment !== void 0 ? _props$environment : context === null || context === void 0 ? void 0 : context.environment) !== null && _ref2 !== void 0 ? _ref2 : (0, _createLocalEnvironment.default)();
  var variables = props.variables,
      rest = (0, _objectWithoutProperties2.default)(props, ["variables"]);
  return /*#__PURE__*/(0, _jsxRuntime__default['default'].jsx)(reactRelay.LocalQueryRenderer, _objectSpread({
    environment: environment,
    render: renderQueryRendererResponse,
    variables: variables !== null && variables !== void 0 ? variables : {}
  }, rest));
}
});

var QueryRenderer_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = QueryRenderer;











function QueryRenderer(props) {
  var _props$environment, _props$variables;

  function renderQueryRendererResponse(_ref) {
    var error = _ref.error,
        rendererProps = _ref.props,
        retry = _ref.retry;

    if (error) {
      if (props.onSystemError) {
        return props.onSystemError({
          error: error,
          retry: retry
        });
      }

      var publicErrorMessage = 'Error!';

      if (error instanceof fetchWithRetries_1.TimeoutError) {
        publicErrorMessage = 'Timeout error!';
      } else if (error instanceof fetchWithRetries_1.ResponseError) {
        var response = error.response;
        publicErrorMessage = (0, _js$1.sprintf)('Unsuccessful response! (%s - %s)', response.status, response.statusText); // You can get the actual response here:
        // error.response.json().then(data => console.warn(data));
      }

      return /*#__PURE__*/(0, _jsxRuntime__default['default'].jsxs)("div", {
        "data-testid": "error",
        children: [publicErrorMessage, ' ', /*#__PURE__*/(0, _jsxRuntime__default['default'].jsx)("button", {
          type: "button",
          onClick: retry,
          children: "Retry"
        })]
      });
    }

    if (rendererProps == null) {
      return props.onLoading ? props.onLoading() : /*#__PURE__*/(0, _jsxRuntime__default['default'].jsx)("div", {
        "data-testid": "loading",
        children: "Loading..."
      });
    }

    !(props.onResponse !== undefined) ? process$1.env.NODE_ENV !== "production" ? (0, _js$1.invariant)(false, 'QueryRenderer used default render function but "onResponse" property has not been provided.') : (0, _js$1.invariant)(false) : void 0;
    return props.onResponse(rendererProps);
  } // 1) <QR environment={Env} /> always win
  // 2) <QR /> checks whether we provide Environment via `RelayEnvironmentProvider`
  // 3) throw if no environment is set


  var context = (0, React__default['default'].useContext)(reactRelay.ReactRelayContext);
  var environment = (_props$environment = props.environment) !== null && _props$environment !== void 0 ? _props$environment : context === null || context === void 0 ? void 0 : context.environment;
  !(environment != null) ? process$1.env.NODE_ENV !== "production" ? (0, _js$1.invariant)(false, 'QueryRenderer: Expected to have found a Relay environment provided by a `RelayEnvironmentProvider` component or by environment property.') : (0, _js$1.invariant)(false) : void 0; // Use this to disable store GC in order to reuse already existing data between screens:
  // const disposable = environment.getStore().holdGC();
  // Relay QR itself recreates the context with our environment.
  // Relay hooks are using `useRelayEnvironment` with `ReactRelayContext` inside (so we use it as well).

  return /*#__PURE__*/(0, _jsxRuntime__default['default'].jsx)(reactRelay.QueryRenderer, {
    environment: environment,
    render: props.render !== undefined ? props.render : renderQueryRendererResponse,
    query: props.query,
    cacheConfig: props.cacheConfig,
    fetchPolicy: props.fetchPolicy,
    variables: (_props$variables = props.variables) !== null && _props$variables !== void 0 ? _props$variables : {}
  });
}
});

var requestSubscription_1$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = requestSubscription;



/**
 * The first parameter `environment` should be from `props.relay.environment`
 * to ensure the subscription is performed in the correct environment.
 */
function requestSubscription(environment, config) {
  return (0, reactRelay.requestSubscription)(environment, config);
}
});

var useLazyLoadQuery_1$1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useLazyLoadQuery;



// The Flow types should be almost identical except we allow skipping variables.
function useLazyLoadQuery(gqlQuery, variables, options) {
  return (0, reactRelay.useLazyLoadQuery)(gqlQuery, variables !== null && variables !== void 0 ? variables : {}, options);
}
});

var arrayWithHoles$1 = createCommonjsModule(function (module) {
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var iterableToArrayLimit$1 = createCommonjsModule(function (module) {
function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var arrayLikeToArray$1 = createCommonjsModule(function (module) {
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var unsupportedIterableToArray$1 = createCommonjsModule(function (module) {
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray$1(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var nonIterableRest$1 = createCommonjsModule(function (module) {
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var slicedToArray$1 = createCommonjsModule(function (module) {
function _slicedToArray(arr, i) {
  return arrayWithHoles$1(arr) || iterableToArrayLimit$1(arr, i) || unsupportedIterableToArray$1(arr, i) || nonIterableRest$1();
}

module.exports = _slicedToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var useMutation_1$1 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useMutation;

var _defineProperty2 = interopRequireDefault$1(defineProperty$2);

var _slicedToArray2 = interopRequireDefault$1(slicedToArray$1);



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Usage:
 *
 * ```ts
 * const AddCommentMutation = graphql`mutation { ... }`;
 * const [addComment, isCommentPending] = useMutation<MutationType>(AddCommentMutation);
 *
 * const disposable = addComment({ variables: { ... } });
 * ```
 */
function useMutation(mutation) {
  var _useMutation2 = (0, reactRelay.useMutation)(mutation),
      _useMutation3 = (0, _slicedToArray2.default)(_useMutation2, 2),
      commit = _useMutation3[0],
      isMutationInFlight = _useMutation3[1]; // this makes the commit more friendly in terms of DX


  var modifiedCommit = function modifiedCommit(config) {
    var _config$variables;

    return commit(_objectSpread(_objectSpread({}, config), {}, {
      variables: (_config$variables = config.variables) !== null && _config$variables !== void 0 ? _config$variables : {}
    }));
  };

  return [modifiedCommit, isMutationInFlight];
}
});

/**
 * Legacy react-relay exports.
 * Should prefer using interface defined in ./hooks.js
 */
var legacy = {
  ConnectionHandler: relayRuntime.ConnectionHandler,
  QueryRenderer: ReactRelayQueryRenderer_1,
  LocalQueryRenderer: ReactRelayLocalQueryRenderer_1,
  MutationTypes: relayRuntime.MutationTypes,
  RangeOperations: relayRuntime.RangeOperations,
  ReactRelayContext: ReactRelayContext,
  applyOptimisticMutation: relayRuntime.applyOptimisticMutation,
  commitLocalUpdate: relayRuntime.commitLocalUpdate,
  commitMutation: relayRuntime.commitMutation,
  createFragmentContainer: ReactRelayFragmentContainer.createContainer,
  createPaginationContainer: ReactRelayPaginationContainer.createContainer,
  createRefetchContainer: ReactRelayRefetchContainer.createContainer,
  fetchQuery_DEPRECATED: relayRuntime.fetchQuery_DEPRECATED,
  graphql: relayRuntime.graphql,
  readInlineData: relayRuntime.readInlineData,
  requestSubscription: relayRuntime.requestSubscription
};

/**
 * Relay v11.0.2
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var legacy$1 = legacy;

var src$2 = createCommonjsModule(function (module, exports) {



Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FetchResponseError", {
  enumerable: true,
  get: function get() {
    return fetchWithRetries_1.ResponseError;
  }
});
Object.defineProperty(exports, "FetchTimeoutError", {
  enumerable: true,
  get: function get() {
    return fetchWithRetries_1.TimeoutError;
  }
});
Object.defineProperty(exports, "createEnvironment", {
  enumerable: true,
  get: function get() {
    return _createEnvironment.default;
  }
});
Object.defineProperty(exports, "createLocalEnvironment", {
  enumerable: true,
  get: function get() {
    return _createLocalEnvironment.default;
  }
});
Object.defineProperty(exports, "createNetworkFetcher", {
  enumerable: true,
  get: function get() {
    return _createNetworkFetcher.default;
  }
});
Object.defineProperty(exports, "getDataFromRequest", {
  enumerable: true,
  get: function get() {
    return _getDataFromRequest.default;
  }
});
Object.defineProperty(exports, "RelayDebugLogger", {
  enumerable: true,
  get: function get() {
    return _RelayDebugLogger.default;
  }
});
Object.defineProperty(exports, "RelayEagerLogger", {
  enumerable: true,
  get: function get() {
    return _RelayEagerLogger.default;
  }
});
Object.defineProperty(exports, "RelayLazyLogger", {
  enumerable: true,
  get: function get() {
    return _RelayLazyLogger.default;
  }
});
Object.defineProperty(exports, "commitMutation", {
  enumerable: true,
  get: function get() {
    return mutations.commitMutation;
  }
});
Object.defineProperty(exports, "commitMutationAsync", {
  enumerable: true,
  get: function get() {
    return mutations.commitMutationAsync;
  }
});
Object.defineProperty(exports, "createFragmentContainer", {
  enumerable: true,
  get: function get() {
    return _createFragmentContainer.default;
  }
});
Object.defineProperty(exports, "createPaginationContainer", {
  enumerable: true,
  get: function get() {
    return _createPaginationContainer.default;
  }
});
Object.defineProperty(exports, "createRefetchContainer", {
  enumerable: true,
  get: function get() {
    return _createRefetchContainer.default;
  }
});
Object.defineProperty(exports, "LocalQueryRenderer", {
  enumerable: true,
  get: function get() {
    return _LocalQueryRenderer.default;
  }
});
Object.defineProperty(exports, "QueryRenderer", {
  enumerable: true,
  get: function get() {
    return _QueryRenderer.default;
  }
});
Object.defineProperty(exports, "requestSubscription", {
  enumerable: true,
  get: function get() {
    return _requestSubscription.default;
  }
});
Object.defineProperty(exports, "useLazyLoadQuery", {
  enumerable: true,
  get: function get() {
    return _useLazyLoadQuery.default;
  }
});
Object.defineProperty(exports, "useMutation", {
  enumerable: true,
  get: function get() {
    return _useMutation.default;
  }
});
Object.defineProperty(exports, "graphql", {
  enumerable: true,
  get: function get() {
    return legacy$1.graphql;
  }
});
Object.defineProperty(exports, "readInlineData", {
  enumerable: true,
  get: function get() {
    return legacy$1.readInlineData;
  }
});
Object.defineProperty(exports, "commitLocalUpdate", {
  enumerable: true,
  get: function get() {
    return legacy$1.commitLocalUpdate;
  }
});
Object.defineProperty(exports, "ConnectionHandler", {
  enumerable: true,
  get: function get() {
    return legacy$1.ConnectionHandler;
  }
});
Object.defineProperty(exports, "fetchQuery", {
  enumerable: true,
  get: function get() {
    return legacy$1.fetchQuery_DEPRECATED;
  }
});
Object.defineProperty(exports, "EntryPointContainer", {
  enumerable: true,
  get: function get() {
    return reactRelay.EntryPointContainer;
  }
});
Object.defineProperty(exports, "loadEntryPoint", {
  enumerable: true,
  get: function get() {
    return reactRelay.loadEntryPoint;
  }
});
Object.defineProperty(exports, "loadQuery", {
  enumerable: true,
  get: function get() {
    return reactRelay.loadQuery;
  }
});
Object.defineProperty(exports, "RelayEnvironmentProvider", {
  enumerable: true,
  get: function get() {
    return reactRelay.RelayEnvironmentProvider;
  }
});
Object.defineProperty(exports, "useEntryPointLoader", {
  enumerable: true,
  get: function get() {
    return reactRelay.useEntryPointLoader;
  }
});
Object.defineProperty(exports, "useFragment", {
  enumerable: true,
  get: function get() {
    return reactRelay.useFragment;
  }
});
Object.defineProperty(exports, "usePaginationFragment", {
  enumerable: true,
  get: function get() {
    return reactRelay.usePaginationFragment;
  }
});
Object.defineProperty(exports, "usePreloadedQuery", {
  enumerable: true,
  get: function get() {
    return reactRelay.usePreloadedQuery;
  }
});
Object.defineProperty(exports, "useQueryLoader", {
  enumerable: true,
  get: function get() {
    return reactRelay.useQueryLoader;
  }
});
Object.defineProperty(exports, "useRefetchableFragment", {
  enumerable: true,
  get: function get() {
    return reactRelay.useRefetchableFragment;
  }
});
Object.defineProperty(exports, "useRelayEnvironment", {
  enumerable: true,
  get: function get() {
    return reactRelay.useRelayEnvironment;
  }
});
Object.defineProperty(exports, "useSubscribeToInvalidationState", {
  enumerable: true,
  get: function get() {
    return reactRelay.useSubscribeToInvalidationState;
  }
});
Object.defineProperty(exports, "useSubscription", {
  enumerable: true,
  get: function get() {
    return reactRelay.useSubscription;
  }
});



var _createEnvironment = interopRequireDefault$1(createEnvironment_1);

var _createLocalEnvironment = interopRequireDefault$1(createLocalEnvironment_1);

var _createNetworkFetcher = interopRequireDefault$1(createNetworkFetcher_1);

var _getDataFromRequest = interopRequireDefault$1(getDataFromRequest_1);

var _RelayDebugLogger = interopRequireDefault$1(RelayDebugLogger_1);

var _RelayEagerLogger = interopRequireDefault$1(RelayEagerLogger_1);

var _RelayLazyLogger = interopRequireDefault$1(RelayLazyLogger_1);



var _createFragmentContainer = interopRequireDefault$1(createFragmentContainer_1);

var _createPaginationContainer = interopRequireDefault$1(createPaginationContainer_1);

var _createRefetchContainer = interopRequireDefault$1(createRefetchContainer_1);

var _LocalQueryRenderer = interopRequireDefault$1(LocalQueryRenderer_1);

var _QueryRenderer = interopRequireDefault$1(QueryRenderer_1);

var _requestSubscription = interopRequireDefault$1(requestSubscription_1$1);

var _useLazyLoadQuery = interopRequireDefault$1(useLazyLoadQuery_1$1);

var _useMutation = interopRequireDefault$1(useMutation_1$1);
});

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var asyncToGenerator$1 = _asyncToGenerator;

var bind = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject$2(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject$2(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge$1(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge$1(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge$1({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

var utils = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject$2,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge$1,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
var buildURL = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

var InterceptorManager_1 = InterceptorManager;

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
var transformData = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

var isCancel = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
var enhanceError = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
var createError$1 = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
var settle = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError$1(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

var cookies = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
var isAbsoluteURL = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
var combineURLs = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
var buildFullPath = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

var isURLSameOrigin = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

var xhr = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError$1('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError$1('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError$1(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = xhr;
  } else if (typeof process$1 !== 'undefined' && Object.prototype.toString.call(process$1) === '[object process]') {
    // For node use HTTP adapter
    adapter = xhr;
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

var defaults_1 = defaults;

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
var dispatchRequest = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults_1.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
var mergeConfig = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager_1(),
    response: new InterceptorManager_1()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

var Axios_1 = Axios;

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

var Cancel_1 = Cancel;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel_1(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

var CancelToken_1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
var spread = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
var isAxiosError = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios_1(defaultConfig);
  var instance = bind(Axios_1.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios_1.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults_1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios_1;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = Cancel_1;
axios.CancelToken = CancelToken_1;
axios.isCancel = isCancel;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

var axios_1 = axios;

// Allow use of default import syntax in TypeScript
var _default = axios;
axios_1.default = _default;

var axios$1 = axios_1;

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule$1(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var WHITELIST = [
	'ETIMEDOUT',
	'ECONNRESET',
	'EADDRINUSE',
	'ESOCKETTIMEDOUT',
	'ECONNREFUSED',
	'EPIPE',
	'EHOSTUNREACH',
	'EAI_AGAIN'
];

var BLACKLIST = [
	'ENOTFOUND',
	'ENETUNREACH',

	// SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950
	'UNABLE_TO_GET_ISSUER_CERT',
	'UNABLE_TO_GET_CRL',
	'UNABLE_TO_DECRYPT_CERT_SIGNATURE',
	'UNABLE_TO_DECRYPT_CRL_SIGNATURE',
	'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',
	'CERT_SIGNATURE_FAILURE',
	'CRL_SIGNATURE_FAILURE',
	'CERT_NOT_YET_VALID',
	'CERT_HAS_EXPIRED',
	'CRL_NOT_YET_VALID',
	'CRL_HAS_EXPIRED',
	'ERROR_IN_CERT_NOT_BEFORE_FIELD',
	'ERROR_IN_CERT_NOT_AFTER_FIELD',
	'ERROR_IN_CRL_LAST_UPDATE_FIELD',
	'ERROR_IN_CRL_NEXT_UPDATE_FIELD',
	'OUT_OF_MEM',
	'DEPTH_ZERO_SELF_SIGNED_CERT',
	'SELF_SIGNED_CERT_IN_CHAIN',
	'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',
	'UNABLE_TO_VERIFY_LEAF_SIGNATURE',
	'CERT_CHAIN_TOO_LONG',
	'CERT_REVOKED',
	'INVALID_CA',
	'PATH_LENGTH_EXCEEDED',
	'INVALID_PURPOSE',
	'CERT_UNTRUSTED',
	'CERT_REJECTED'
];

var isRetryAllowed = function (err) {
	if (!err || !err.code) {
		return true;
	}

	if (WHITELIST.indexOf(err.code) !== -1) {
		return true;
	}

	if (BLACKLIST.indexOf(err.code) !== -1) {
		return false;
	}

	return true;
};

var lib$2 = createCommonjsModule$1(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNetworkError = isNetworkError;
exports.isRetryableError = isRetryableError;
exports.isSafeRequestError = isSafeRequestError;
exports.isIdempotentRequestError = isIdempotentRequestError;
exports.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
exports.exponentialDelay = exponentialDelay;
exports.default = axiosRetry;



var _isRetryAllowed2 = _interopRequireDefault(isRetryAllowed);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var namespace = 'axios-retry';

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkError(error) {
  return !error.response && Boolean(error.code) && // Prevents retrying cancelled requests
  error.code !== 'ECONNABORTED' && // Prevents retrying timed out requests
  (0, _isRetryAllowed2.default)(error); // Prevents retrying unsafe errors
}

var SAFE_HTTP_METHODS = ['get', 'head', 'options'];
var IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isRetryableError(error) {
  return error.code !== 'ECONNABORTED' && (!error.response || error.response.status >= 500 && error.response.status <= 599);
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isSafeRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isIdempotentRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkOrIdempotentRequestError(error) {
  return isNetworkError(error) || isIdempotentRequestError(error);
}

/**
 * @return {number} - delay in milliseconds, always 0
 */
function noDelay() {
  return 0;
}

/**
 * @param  {number} [retryNumber=0]
 * @return {number} - delay in milliseconds
 */
function exponentialDelay() {
  var retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  var delay = Math.pow(2, retryNumber) * 100;
  var randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay
  return delay + randomSum;
}

/**
 * Initializes and returns the retry state for the given request/config
 * @param  {AxiosRequestConfig} config
 * @return {Object}
 */
function getCurrentState(config) {
  var currentState = config[namespace] || {};
  currentState.retryCount = currentState.retryCount || 0;
  config[namespace] = currentState;
  return currentState;
}

/**
 * Returns the axios-retry options for the current request
 * @param  {AxiosRequestConfig} config
 * @param  {AxiosRetryConfig} defaultOptions
 * @return {AxiosRetryConfig}
 */
function getRequestOptions(config, defaultOptions) {
  return Object.assign({}, defaultOptions, config[namespace]);
}

/**
 * @param  {Axios} axios
 * @param  {AxiosRequestConfig} config
 */
function fixConfig(axios, config) {
  if (axios.defaults.agent === config.agent) {
    delete config.agent;
  }
  if (axios.defaults.httpAgent === config.httpAgent) {
    delete config.httpAgent;
  }
  if (axios.defaults.httpsAgent === config.httpsAgent) {
    delete config.httpsAgent;
  }
}

/**
 * Adds response interceptors to an axios instance to retry requests failed due to network issues
 *
 * @example
 *
 * import axios from 'axios';
 *
 * axiosRetry(axios, { retries: 3 });
 *
 * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Exponential back-off retry delay between requests
 * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});
 *
 * // Custom retry delay
 * axiosRetry(axios, { retryDelay : (retryCount) => {
 *   return retryCount * 1000;
 * }});
 *
 * // Also works with custom axios instances
 * const client = axios.create({ baseURL: 'http://example.com' });
 * axiosRetry(client, { retries: 3 });
 *
 * client.get('/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Allows request-specific configuration
 * client
 *   .get('/test', {
 *     'axios-retry': {
 *       retries: 0
 *     }
 *   })
 *   .catch(error => { // The first request fails
 *     error !== undefined
 *   });
 *
 * @param {Axios} axios An axios instance (the axios object or one created from axios.create)
 * @param {Object} [defaultOptions]
 * @param {number} [defaultOptions.retries=3] Number of retries
 * @param {boolean} [defaultOptions.shouldResetTimeout=false]
 *        Defines if the timeout should be reset between retries
 * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]
 *        A function to determine if the error can be retried
 * @param {Function} [defaultOptions.retryDelay=noDelay]
 *        A function to determine the delay between retry requests
 */
function axiosRetry(axios, defaultOptions) {
  axios.interceptors.request.use(function (config) {
    var currentState = getCurrentState(config);
    currentState.lastRequestTime = Date.now();
    return config;
  });

  axios.interceptors.response.use(null, function (error) {
    var config = error.config;

    // If we have no information to retry the request
    if (!config) {
      return Promise.reject(error);
    }

    var _getRequestOptions = getRequestOptions(config, defaultOptions),
        _getRequestOptions$re = _getRequestOptions.retries,
        retries = _getRequestOptions$re === undefined ? 3 : _getRequestOptions$re,
        _getRequestOptions$re2 = _getRequestOptions.retryCondition,
        retryCondition = _getRequestOptions$re2 === undefined ? isNetworkOrIdempotentRequestError : _getRequestOptions$re2,
        _getRequestOptions$re3 = _getRequestOptions.retryDelay,
        retryDelay = _getRequestOptions$re3 === undefined ? noDelay : _getRequestOptions$re3,
        _getRequestOptions$sh = _getRequestOptions.shouldResetTimeout,
        shouldResetTimeout = _getRequestOptions$sh === undefined ? false : _getRequestOptions$sh;

    var currentState = getCurrentState(config);

    var shouldRetry = retryCondition(error) && currentState.retryCount < retries;

    if (shouldRetry) {
      currentState.retryCount += 1;
      var delay = retryDelay(currentState.retryCount, error);

      // Axios fails merging this configuration to the default configuration because it has an issue
      // with circular structures: https://github.com/mzabriskie/axios/issues/370
      fixConfig(axios, config);

      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {
        var lastRequestDuration = Date.now() - currentState.lastRequestTime;
        // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)
        config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);
      }

      config.transformRequest = [function (data) {
        return data;
      }];

      return new Promise(function (resolve) {
        return setTimeout(function () {
          return resolve(axios(config));
        }, delay);
      });
    }

    return Promise.reject(error);
  });
}

// Compatibility with CommonJS
axiosRetry.isNetworkError = isNetworkError;
axiosRetry.isSafeRequestError = isSafeRequestError;
axiosRetry.isIdempotentRequestError = isIdempotentRequestError;
axiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
axiosRetry.exponentialDelay = exponentialDelay;
axiosRetry.isRetryableError = isRetryableError;

});

unwrapExports(lib$2);
var lib_1 = lib$2.isNetworkError;
var lib_2 = lib$2.isRetryableError;
var lib_3 = lib$2.isSafeRequestError;
var lib_4 = lib$2.isIdempotentRequestError;
var lib_5 = lib$2.isNetworkOrIdempotentRequestError;
var lib_6 = lib$2.exponentialDelay;

var axiosRetry = lib$2.default;

var DEFAULT_RETRIES$1 = 2;
var DEFAULT_RETRY_DELAY_MS = 1500;
var axCached$1 = null; // For testing purpose only

function getCachedInstance$1(config) {
  if (axCached$1 === null) {
    axCached$1 = axios$1.create({
      withCredentials: true
    });
    axiosRetry(axCached$1, config);
  }

  return axCached$1;
}

function isGQLQuery(operationKind) {
  return operationKind === 'query';
}

function isNetworkOrRetryableError(error) {
  // Axios generics will be part of 1.0.0 release - https://github.com/axios/axios/pull/1964
  if (!isGQLQuery(error.config.operationKind)) {
    return false;
  }

  return axiosRetry.isNetworkError(error) || axiosRetry.isRetryableError(error);
}

function gqlLinearDelay() {
  var retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return retryNumber * DEFAULT_RETRY_DELAY_MS;
}

var axiosRetryConfig = {
  retryCondition: isNetworkOrRetryableError,
  retries: DEFAULT_RETRIES$1,
  retryDelay: gqlLinearDelay
};

/**
 * Adds response interceptors to an axios instance to retry requests failed due to network issues.
 * If the axios instance is not passed, a new one is created and cached within this package.
 *
 * PLEASE NOTE that this method should be used purely for GQL requests.
 */
function gqlAxiosRetry() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      ax = _ref.ax,
      _ref$config = _ref.config,
      config = _ref$config === void 0 ? axiosRetryConfig : _ref$config;

  if (ax) {
    axiosRetry(ax, config);
    return ax;
  }

  return getCachedInstance$1(config);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck;

var setPrototypeOf$2 = createCommonjsModule(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
});

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf$2(subClass, superClass);
}

var inherits$2 = _inherits;

var _typeof_1$2 = createCommonjsModule(function (module) {
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof_1$2(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

var possibleConstructorReturn$2 = _possibleConstructorReturn;

var getPrototypeOf$2 = createCommonjsModule(function (module) {
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
});

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

var isNativeFunction$2 = _isNativeFunction;

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

var isNativeReflectConstruct$2 = _isNativeReflectConstruct;

var construct$2 = createCommonjsModule(function (module) {
function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct$2()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf$2(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
});

var wrapNativeSuper$2 = createCommonjsModule(function (module) {
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction$2(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct$2(Class, arguments, getPrototypeOf$2(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf$2(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
});

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = getPrototypeOf$2(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf$2(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn$2(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var NetworkError = /*#__PURE__*/function (_Error) {
  inherits$2(NetworkError, _Error);

  var _super = _createSuper(NetworkError);

  function NetworkError() {
    classCallCheck(this, NetworkError);

    return _super.apply(this, arguments);
  }

  return NetworkError;
}( /*#__PURE__*/wrapNativeSuper$2(Error));

var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

var decodeUriComponent = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};

var splitOnFirst = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};

var queryString = createCommonjsModule(function (module, exports) {




const isNullOrUndefined = value => value === null || value === undefined;

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[', index, ']'].join('')];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
				];
			};

		case 'bracket':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[]'].join('')];
				}

				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
			};

		case 'comma':
		case 'separator':
			return key => (result, value) => {
				if (value === null || value === undefined || value.length === 0) {
					return result;
				}

				if (result.length === 0) {
					return [[encode(key, options), '=', encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};

		default:
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, encode(key, options)];
				}

				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.split('').indexOf(options.arrayFormatSeparator) > -1;
				const newValue = isArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeUriComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(input, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof input !== 'string') {
		return ret;
	}

	input = input.trim().replace(/^[?#&]/, '');

	if (!input) {
		return ret;
	}

	for (const param of input.split('&')) {
		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (const key of Object.keys(ret)) {
		const value = ret[key];
		if (typeof value === 'object' && value !== null) {
			for (const k of Object.keys(value)) {
				value[k] = parseValue(value[k], options);
			}
		} else {
			ret[key] = parseValue(value, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (input, options) => {
	options = Object.assign({
		decode: true
	}, options);

	const [url, hash] = splitOnFirst(input, '#');

	return Object.assign(
		{
			url: url.split('?')[0] || '',
			query: parse(extract(input), options)
		},
		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
	);
};

exports.stringifyUrl = (input, options) => {
	options = Object.assign({
		encode: true,
		strict: true
	}, options);

	const url = removeHash(input.url).split('?')[0] || '';
	const queryFromUrl = exports.extract(input.url);
	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

	const query = Object.assign(parsedQueryFromUrl, input.query);
	let queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = `?${queryString}`;
	}

	let hash = getHash(input.url);
	if (input.fragmentIdentifier) {
		hash = `#${encode(input.fragmentIdentifier, options)}`;
	}

	return `${url}${queryString}${hash}`;
};
});

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types
function objectFromEntries(iter) {
  var obj = {};

  var _iterator = _createForOfIteratorHelper$1(iter),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var pair = _step.value;

      if (Object(pair) !== pair) {
        throw new TypeError('iterable for fromEntries should yield objects');
      } // Consistency with Map: contract is that entry has "0" and "1" keys, not
      // that it is an array or iterable.


      var key = pair['0'],
          val = pair['1'];
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: val
      });
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return obj;
}

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var getCookie = function getCookie(name) {
  var value = "; ".concat(document.cookie);
  var parts = value.split("; ".concat(name, "="));

  if (parts.length !== 2) {
    return '';
  }

  var lastPart = parts.pop();

  if (!lastPart) {
    return '';
  }

  return lastPart.split(';').shift();
}; // eslint-disable-next-line @typescript-eslint/ban-types


var getUrl = function getUrl(url, optionalParams) {
  var params = _objectSpread$3(_objectSpread$3({}, optionalParams), {}, {
    session_token: getCookie('pipe-session-token'),
    strict_mode: true
  });

  var stringifiedParams = queryString.stringify(params);
  return "".concat(url, "?").concat(stringifiedParams);
}; // eslint-disable-next-line @typescript-eslint/ban-types


// eslint-disable-next-line @typescript-eslint/ban-types
var isFunction$1 = function isFunction(x) {
  return Object.prototype.toString.call(x) === '[object Function]';
};

var getMaterializedHeaders = function getMaterializedHeaders(headers) {
  return objectFromEntries(Object.entries(headers).map(function (_ref) {
    var _ref2 = slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    return [key, isFunction$1(value) ? value() : value];
  }));
}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


var getAxiosResponse = /*#__PURE__*/function () {
  var _ref4 = asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref3) {
    var ax, query, variables, cancelToken, headers, operationKind;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            ax = _ref3.ax, query = _ref3.query, variables = _ref3.variables, cancelToken = _ref3.cancelToken, headers = _ref3.headers, operationKind = _ref3.operationKind;
            return _context.abrupt("return", ax.post(getUrl('/leads-graphql/'), {
              query: query,
              variables: variables
            }, {
              cancelToken: cancelToken,
              headers: getMaterializedHeaders(headers !== null && headers !== void 0 ? headers : {}),
              operationKind: operationKind
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getAxiosResponse(_x) {
    return _ref4.apply(this, arguments);
  };
}();

var fetchFactory = /*#__PURE__*/function () {
  var _ref2 = asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
    var cancelToken, sink, onError, request, variables, headers, ax, response, responseData, _response, _responseData, errorMessages;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            cancelToken = _ref.cancelToken, sink = _ref.sink, onError = _ref.onError, request = _ref.request, variables = _ref.variables, headers = _ref.headers;
            ax = gqlAxiosRetry();
            _context.prev = 2;
            _context.next = 5;
            return getAxiosResponse({
              ax: ax,
              query: request.text,
              variables: variables,
              cancelToken: cancelToken,
              headers: headers,
              operationKind: request.operationKind
            });

          case 5:
            response = _context.sent;
            responseData = response.data; // Relay is currently quite opinionated and recommends to either try to render the data or
            // halt the application. It's a smart decisions since these errors are not for the application
            // users. We conveniently follow this recommendation and always try to render the data.

            if ('errors' in responseData && Array.isArray(responseData.errors)) {
              onError && onError(responseData.errors);
            } // Sink.next sends the response to the QueryRenderer (no errors) or into `onCompleted` for
            // mutations (including the errors in a second argument).


            sink.next(responseData);
            _context.next = 17;
            break;

          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](2);

            if (!axios$1.isCancel(_context.t0)) {
              _context.next = 15;
              break;
            }

            return _context.abrupt("return");

          case 15:
            _response = _context.t0.response; // https://github.com/axios/axios#handling-errors

            if (_response) {
              // The request was made and the server responded with a status code that falls out of the range of 2xx.
              // Sink.error sends the errors to the `error` property in QueryRenderers or into `onError` callbacks.
              _responseData = _response.data;
              errorMessages = [];

              if ('errors' in _responseData && Array.isArray(_responseData.errors)) {
                onError && onError(_responseData.errors);

                _responseData.errors.map(function (error) {
                  errorMessages.push(error.message);
                });
              }

              sink.error(new Error(JSON.stringify(errorMessages, null, 2)));
            } else {
              sink.error(new NetworkError(_context.t0));
            }

          case 17:
            _context.prev = 17;
            sink.complete();
            return _context.finish(17);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 11, 17, 20]]);
  }));

  return function fetchFactory(_x) {
    return _ref2.apply(this, arguments);
  };
}();

var createFetchFunction = function createFetchFunction(_ref3) {
  var onError = _ref3.onError,
      headers = _ref3.headers;
  var CancelToken = axios$1.CancelToken;
  return function (request, variables, cacheConfig, uploadables) {
    return relayRuntime.Observable.create(function (sink) {
      var cancelSource = CancelToken.source();
      fetchFactory({
        cancelToken: cancelSource.token,
        sink: sink,
        onError: onError,
        headers: headers,
        request: request,
        variables: variables,
        cacheConfig: cacheConfig,
        uploadables: uploadables
      });
      return function () {
        cancelSource.cancel('axios cleanup');
      };
    });
  };
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
var createDevTools = function createDevTools() {
  if (process.env.NODE_ENV === 'development' && window.__RELAY_DEVTOOLS_HOOK__ === undefined && window.__RELAY__ === undefined) {
    window.__RELAY_DEVTOOLS_HOOK__ = {
      registerEnvironment: function registerEnvironment(environment) {
        window.__RELAY__ = {
          store: function store() {
            var dataID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var source = environment.getStore().getSource();

            if (dataID === null) {
              return source.toJSON();
            }

            return source.get(dataID);
          }
        };
      }
    };
  }
};

/**
 * This Environment factory should be used only once in the application and every consequent user
 * should use the instance passed by props OR via `useEnvironment`. It is because this environment
 * can change during the application lifetime (based on user session for example).
 *
 * See: https://relay.dev/docs/en/quick-start-guide#relay-environment
 */

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
var createRelayEnvironment = function createRelayEnvironment(_ref) {
  var store = _ref.store,
      onError = _ref.onError,
      fetchHeaders = _ref.fetchHeaders,
      subscribe = _ref.subscribe,
      handlerProvider = _ref.handlerProvider,
      operationTracker = _ref.operationTracker;
  createDevTools();
  return new relayRuntime.Environment({
    log: process.env.NODE_ENV === 'development' ? src$2.RelayEagerLogger : null,
    network: relayRuntime.Network.create(createFetchFunction({
      onError: onError,
      headers: fetchHeaders
    }), subscribe),
    store: store,
    handlerProvider: handlerProvider,
    operationTracker: operationTracker
  });
};

function executeQuery(_x) {
  return _executeQuery.apply(this, arguments);
}

function _executeQuery() {
  _executeQuery = asyncToGenerator$1( /*#__PURE__*/regeneratorRuntime.mark(function _callee(query) {
    var ax;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            ax = axios$1.create({
              withCredentials: true
            });
            return _context.abrupt("return", getAxiosResponse({
              ax: ax,
              query: query,
              variables: []
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _executeQuery.apply(this, arguments);
}

exports.CenteredLoader = CenteredLoader;
exports.ConnectionHandler = relayRuntime.ConnectionHandler;
exports.DeclarativeMutationConfig = reactRelay.DeclarativeMutationConfig;
exports.Disposable = relayRuntime.Disposable;
exports.Environment = reactRelay.Environment;
exports.FragmentRefs = relayRuntime.FragmentRefs;
exports.GraphQLResponse = relayRuntime.GraphQLResponse;
exports.GraphQLTaggedNode = reactRelay.GraphQLTaggedNode;
exports.IEnvironment = relayRuntime.IEnvironment;
exports.MutationParameters = relayRuntime.MutationParameters;
exports.NetworkError = NetworkError;
exports.Observable = relayRuntime.Observable;
exports.OperationDescriptor = reactRelay.OperationDescriptor;
exports.OperationType = relayRuntime.OperationType;
exports.QueryRenderer = QueryRenderer;
exports.QueryRendererSilent = QueryRendererSilent;
exports.ROOT_ID = relayRuntime.ROOT_ID;
exports.RecordProxy = relayRuntime.RecordProxy;
exports.RecordSource = relayRuntime.RecordSource;
exports.RecordSourceSelectorProxy = relayRuntime.RecordSourceSelectorProxy;
exports.RelayEnvironmentProvider = reactRelay.RelayEnvironmentProvider;
exports.RelayObservable = RelayObservable_1.RelayObservable;
exports.RelayPaginationProp = reactRelay.RelayPaginationProp;
exports.RelayRefetchProp = reactRelay.RelayRefetchProp;
exports.RequestParameters = relayRuntime.RequestParameters;
exports.SelectorStoreUpdater = relayRuntime.SelectorStoreUpdater;
exports.Store = relayRuntime.Store;
exports.TestQueryRenderer = TestQueryRenderer;
exports.Variables = relayRuntime.Variables;
exports.commitLocalUpdate = reactRelay.commitLocalUpdate;
exports.commitMutation = reactRelay.commitMutation;
exports.convert = RelayDeclarativeMutationConfig.convert;
exports.createFragmentContainer = reactRelay.createFragmentContainer;
exports.createOperationDescriptor = relayRuntime.createOperationDescriptor;
exports.createPaginationContainer = reactRelay.createPaginationContainer;
exports.createRefetchContainer = reactRelay.createRefetchContainer;
exports.createRelayEnvironment = createRelayEnvironment;
exports.createRelayStore = createRelayStore;
exports.executeQuery = executeQuery;
exports.fetchQuery = reactRelay.fetchQuery;
exports.generateUniqueClientID = relayRuntime.generateUniqueClientID;
exports.getRelayHandleKey = relayRuntime.getRelayHandleKey;
exports.getRequest = relayRuntime.getRequest;
exports.getStableStorageKey = RelayStoreUtils_1.getStableStorageKey;
exports.graphql = reactRelay.graphql;
exports.readInlineData = reactRelay.readInlineData;
exports.requestSubscription = reactRelay.requestSubscription;
exports.useEntryPointLoader = reactRelay.useEntryPointLoader;
exports.useFragment = reactRelay.useFragment;
exports.useLazyLoadQuery = reactRelay.useLazyLoadQuery;
exports.useMutation = useMutation$1;
exports.usePaginationFragment = reactRelay.usePaginationFragment;
exports.usePreloadedQuery = reactRelay.usePreloadedQuery;
exports.useQueryLoader = reactRelay.useQueryLoader;
exports.useRefetchableFragment = reactRelay.useRefetchableFragment;
exports.useRelayEnvironment = reactRelay.useRelayEnvironment;
exports.useSubscription = useSubscription$1;
//# sourceMappingURL=index.js.map
