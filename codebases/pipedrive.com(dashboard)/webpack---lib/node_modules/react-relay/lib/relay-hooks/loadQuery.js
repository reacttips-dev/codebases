/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @emails oncall+relay
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var React = require('react');

var invariant = require('invariant');

var warning = require("fbjs/lib/warning");

var _require = require('relay-runtime'),
    PreloadableQueryRegistry = _require.PreloadableQueryRegistry,
    ReplaySubject = _require.ReplaySubject,
    createOperationDescriptor = _require.createOperationDescriptor,
    getRequest = _require.getRequest,
    getRequestIdentifier = _require.getRequestIdentifier,
    Observable = _require.Observable,
    RelayFeatureFlags = _require.RelayFeatureFlags,
    fetchQueryDeduped = _require.__internal.fetchQueryDeduped;

var RenderDispatcher = null;
var fetchKey = 100001;

function useTrackLoadQueryInRender() {
  if (RenderDispatcher === null) {
    var _React$__SECRET_INTER, _React$__SECRET_INTER2;

    // Flow does not know of React internals (rightly so), but we need to
    // ensure here that this function isn't called inside render.
    RenderDispatcher = // $FlowFixMe[prop-missing]
    (_React$__SECRET_INTER = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER === void 0 ? void 0 : (_React$__SECRET_INTER2 = _React$__SECRET_INTER.ReactCurrentDispatcher) === null || _React$__SECRET_INTER2 === void 0 ? void 0 : _React$__SECRET_INTER2.current;
  }
}

function loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {
  var _React$__SECRET_INTER3, _React$__SECRET_INTER4, _options$__nameForWar, _options$fetchPolicy;

  // This code ensures that we don't call loadQuery during render.
  var CurrentDispatcher = // $FlowFixMe[prop-missing]
  (_React$__SECRET_INTER3 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER3 === void 0 ? void 0 : (_React$__SECRET_INTER4 = _React$__SECRET_INTER3.ReactCurrentDispatcher) === null || _React$__SECRET_INTER4 === void 0 ? void 0 : _React$__SECRET_INTER4.current;
  process.env.NODE_ENV !== "production" ? warning(RenderDispatcher == null || CurrentDispatcher !== RenderDispatcher, 'Relay: `%s` should not be called inside a React render function.', (_options$__nameForWar = options === null || options === void 0 ? void 0 : options.__nameForWarning) !== null && _options$__nameForWar !== void 0 ? _options$__nameForWar : 'loadQuery') : void 0; // Every time you call loadQuery, we will generate a new fetchKey.
  // This will ensure that every query reference that is created and
  // passed to usePreloadedQuery is independently evaluated,
  // even if they are for the same query/variables.
  // Specifically, we want to avoid a case where we try to refetch a
  // query by calling loadQuery a second time, and have the Suspense
  // cache in usePreloadedQuery reuse the cached result instead of
  // re-evaluating the new query ref and triggering a refetch if
  // necessary.

  fetchKey++;
  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';
  var networkCacheConfig = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {
    force: true
  }); // executeWithNetworkSource will retain and execute an operation
  // against the Relay store, given an Observable that would provide
  // the network events for the operation.

  var retainReference;
  var didExecuteNetworkSource = false;

  var executeWithNetworkSource = function executeWithNetworkSource(operation, networkObservable) {
    didExecuteNetworkSource = true;
    return environment.executeWithSource({
      operation: operation,
      source: networkObservable
    });
  }; // N.B. For loadQuery, we unconventionally want to return an Observable
  // that isn't lazily executed, meaning that we don't want to wait
  // until the returned Observable is subscribed to to actually start
  // fetching and executing an operation; i.e. we want to execute the
  // operation eagerly, when loadQuery is called.
  // For this reason, we use an intermediate executionSubject which
  // allows us to capture the events that occur during the eager execution
  // of the operation, and then replay them to the Observable we
  // ultimately return.


  var executionSubject = new ReplaySubject();
  var returnedObservable = Observable.create(function (sink) {
    return executionSubject.subscribe(sink);
  });
  var unsubscribeFromNetworkRequest;
  var networkError = null; // makeNetworkRequest will immediately start a raw network request if
  // one isn't already in flight and return an Observable that when
  // subscribed to will replay the network events that have occured so far,
  // as well as subsequent events.

  var didMakeNetworkRequest = false;

  var makeNetworkRequest = function makeNetworkRequest(params) {
    // N.B. this function is called synchronously or not at all
    // didMakeNetworkRequest is safe to rely on in the returned value
    // Even if the request gets deduped below, we still wan't to return an
    // observable that provides the replayed network events for the query,
    // so we set this to true before deduping, to guarantee that the
    // `source` observable is returned.
    didMakeNetworkRequest = true;
    var observable;
    var subject = new ReplaySubject();

    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {
      // Here, we are calling fetchQueryDeduped at the network layer level,
      // which ensures that only a single network request is active for a given
      // (environment, identifier) pair.
      // Since network requests can be started /before/ we have the query ast
      // necessary to process the results, we need to dedupe the raw requests
      // separately from deduping the operation execution; specifically,
      // if `loadQuery` is called multiple times before the query ast is available,
      // we still want the network request to be deduped.
      // - If a duplicate active network request is found, it will return an
      // Observable that replays the events of the already active request.
      // - If no duplicate active network request is found, it will call the fetchFn
      // to start the request, and return an Observable that will replay
      // the events from the network request.
      // We provide an extra key to the identifier to distinguish deduping
      // of raw network requests vs deduping of operation executions.
      var identifier = 'raw-network-request-' + getRequestIdentifier(params, variables);
      observable = fetchQueryDeduped(environment, identifier, function () {
        var network = environment.getNetwork();
        return network.execute(params, variables, networkCacheConfig);
      });
    } else {
      var network = environment.getNetwork();
      observable = network.execute(params, variables, networkCacheConfig);
    }

    var _observable$subscribe = observable.subscribe({
      error: function error(err) {
        networkError = err;
        subject.error(err);
      },
      next: function next(data) {
        subject.next(data);
      },
      complete: function complete() {
        subject.complete();
      }
    }),
        unsubscribe = _observable$subscribe.unsubscribe;

    unsubscribeFromNetworkRequest = unsubscribe;
    return Observable.create(function (sink) {
      var subjectSubscription = subject.subscribe(sink);
      return function () {
        subjectSubscription.unsubscribe();
        unsubscribeFromNetworkRequest();
      };
    });
  };

  var unsubscribeFromExecution;

  var executeDeduped = function executeDeduped(operation, fetchFn) {
    if (RelayFeatureFlags.ENABLE_LOAD_QUERY_REQUEST_DEDUPING === true) {
      // N.B. at this point, if we're calling execute with a query ast (OperationDescriptor),
      // we are guaranteed to have started a network request. We set this to
      // true here as well since `makeNetworkRequest` might get skipped in the case
      // where the query ast is already available and the query executions get deduped.
      // Even if the execution gets deduped below, we still wan't to return
      // an observable that provides the replayed network events for the query,
      // so we set this to true before deduping, to guarantee that the `source`
      // observable is returned.
      didMakeNetworkRequest = true;
    } // Here, we are calling fetchQueryDeduped, which ensures that only
    // a single operation is active for a given (environment, identifier) pair,
    // and also tracks the active state of the operation, which is necessary
    // for our Suspense infra to later be able to suspend (or not) on
    // active operations. Even though we already dedupe raw network requests,
    // we also need to dedupe and keep track operation execution for our Suspense
    // infra, and we also want to avoid processing responses more than once, for
    // the cases where `loadQuery` might be called multiple times after the query ast
    // is available.
    // - If a duplicate active operation is found, it will return an
    // Observable that replays the events of the already active operation.
    // - If no duplicate active operation is found, it will call the fetchFn
    // to execute the operation, and return an Observable that will provide
    // the events for executing the operation.


    var _fetchQueryDeduped$su = fetchQueryDeduped(environment, operation.request.identifier, fetchFn).subscribe({
      error: function error(err) {
        executionSubject.error(err);
      },
      next: function next(data) {
        executionSubject.next(data);
      },
      complete: function complete() {
        executionSubject.complete();
      }
    });

    unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;
  };

  var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {
    var operation = createOperationDescriptor(concreteRequest, variables, networkCacheConfig);
    retainReference = environment.retain(operation);

    if (fetchPolicy === 'store-only') {
      return;
    } // N.B. If the fetch policy allows fulfillment from the store but the
    // environment already has the data for that operation cached in the store,
    // then we do nothing.


    var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';

    if (shouldFetch) {
      executeDeduped(operation, function () {
        // N.B. Since we have the operation synchronously available here,
        // we can immediately fetch and execute the operation.
        var networkObservable = makeNetworkRequest(concreteRequest.params);
        var executeObservable = executeWithNetworkSource(operation, networkObservable);
        return executeObservable;
      });
    }
  };

  var params;
  var cancelOnLoadCallback;
  var queryId;

  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {
    var preloadableConcreteRequest = preloadableRequest;
    params = preloadableConcreteRequest.params;
    var _params = params;
    queryId = _params.id;
    !(queryId !== null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : invariant(false) : void 0;

    var _module = PreloadableQueryRegistry.get(queryId);

    if (_module != null) {
      checkAvailabilityAndExecute(_module);
    } else {
      // If the module isn't synchronously available, we launch the
      // network request immediately if the fetchPolicy might produce
      // a network fetch, regardless of the state of the store cache. We
      // do this because we can't check if a query is cached without the
      // ast, and we know that if we don't have the query ast
      // available, then this query could've never been written to the
      // store in the first place, so it couldn't have been cached.
      var networkObservable = fetchPolicy === 'store-only' ? null : makeNetworkRequest(params);

      var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad( // $FlowFixMe[incompatible-call]
      queryId, function (preloadedModule) {
        cancelOnLoadCallback();
        var operation = createOperationDescriptor(preloadedModule, variables, networkCacheConfig);
        retainReference = environment.retain(operation);

        if (networkObservable != null) {
          executeDeduped(operation, function () {
            return executeWithNetworkSource(operation, networkObservable);
          });
        }
      });

      cancelOnLoadCallback = _PreloadableQueryRegi.dispose;
    }
  } else {
    var graphQlTaggedNode = preloadableRequest;
    var request = getRequest(graphQlTaggedNode);
    params = request.params;
    queryId = params.cacheID != null ? params.cacheID : params.id;
    checkAvailabilityAndExecute(request);
  }

  var isDisposed = false;
  return {
    kind: 'PreloadedQuery',
    environment: environment,
    environmentProviderOptions: environmentProviderOptions,
    dispose: function dispose() {
      if (isDisposed) {
        return;
      }

      if (didExecuteNetworkSource) {
        unsubscribeFromExecution && unsubscribeFromExecution();
      } else {
        unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();
      }

      retainReference && retainReference.dispose();
      cancelOnLoadCallback && cancelOnLoadCallback();
      isDisposed = true;
    },
    fetchKey: fetchKey,
    id: queryId,

    // $FlowFixMe[unsafe-getters-setters] - this has no side effects
    get isDisposed() {
      return isDisposed;
    },

    // $FlowFixMe[unsafe-getters-setters] - this has no side effects
    get networkError() {
      return networkError;
    },

    name: params.name,
    networkCacheConfig: networkCacheConfig,
    fetchPolicy: fetchPolicy,
    source: didMakeNetworkRequest ? returnedObservable : undefined,
    variables: variables
  };
}

module.exports = {
  loadQuery: loadQuery,
  useTrackLoadQueryInRender: useTrackLoadQueryInRender
};