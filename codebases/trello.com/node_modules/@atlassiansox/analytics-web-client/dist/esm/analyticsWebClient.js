import { __assign, __read, __spread } from "tslib";
import PPromise from 'promise-polyfill';
import Analytics from '@segment/analytics.js-core/lib/analytics';
import { XID, XIDItemType } from '@atlassian/atl-cross-domain-tracking/dist/esm';
import SegmentIO from './analytics.js-integration-segmentio';
import BeforeSendIntegration from './beforeSendIntegration';
import UIViewedEvent from './uiViewedEvent';
import ApdexEvent from './apdexEvent';
import PageVisibility from './pageVisibility';
import TabTracking from './tabTracking';
import SessionTracking from './sessionTracking';
import TaskSessionStore from './taskSessionStore';
import OriginTracing from './originTracing';
import { envType, eventType, originType, platformType, tenantType, isType, objectValues, } from './analyticsWebTypes';
import { buildScreenEvent, buildActionName, buildActionEvent, buildContext, } from './eventBuilder';
import { validateScreenEvent, validateTrackEvent, validateUIEvent, validateOperationalEvent, validateIdentifyEvent, validatePlatform, validateContainers, } from './eventValidation';
import { defaultHistoryReplaceFn } from './urlUtils';
import TestingCache from './testingCache';
import wrapCallback from './wrapCallback';
import createGetter from './createGetter';
import SafeSessionStorage from './storage/SafeSessionStorage';
import EventDelayQueue from './eventDelayQueue';
var PROD_HOST = 'as.atlassian.com/api/v1';
var STARGATE_PROD_HOST = 'api-private.atlassian.com/gasv3/api/v1';
var STAGING_HOST = 'as.staging.atl-paas.net/api/v1';
var STARGATE_STAGING_HOST = 'api-private.stg.atlassian.com/gasv3/api/v1';
var ALLOWED_TENANTED_HOSTS = [
    'atlassian.net',
    'jira.com',
    'jira-dev.com',
    'admin.atlassian.com',
    'admin.stg.atlassian.com',
];
var TENANTED_HOST_PATH = '/gateway/api/gasv3/api/v1';
var LAST_SCREEN_EVENT_STORAGE_KEY = 'last.screen.event';
var XID_TIMEOUT = 5000;
var MAX_DELAY_TIMEOUT = 10000;
var AnalyticsWebClient = /** @class */ (function () {
    function AnalyticsWebClient(productInfo, settings) {
        var _this = this;
        if (productInfo === void 0) { productInfo = {}; }
        if (settings === void 0) { settings = {}; }
        this._useStargate = function (useStargate) {
            if (useStargate == null) {
                return true;
            }
            return useStargate;
        };
        this._selectHost = function (_a) {
            var useStargate = _a.useStargate, env = _a.env;
            if (!useStargate) {
                return (env === envType.PROD ? PROD_HOST : STAGING_HOST);
            }
            if (_this._isTenantedHost()) {
                return window.location.host + TENANTED_HOST_PATH;
            }
            return (env === envType.PROD ? STARGATE_PROD_HOST : STARGATE_STAGING_HOST);
        };
        this._isTenantedHost = function () { return ALLOWED_TENANTED_HOSTS
            .filter(function (host) { return _this._endsWith(window.location.host, host); }).length > 0; };
        this._endsWith = function (str, suffix) { return str.indexOf(suffix, str.length - suffix.length) !== -1; };
        this._changeInternalUserId = function (userId, anonymousId) {
            // Segment library workaround to change userId without triggering an identify call.
            if (_this._analytics.user().id() !== userId) {
                _this._analytics.user().id(userId);
            }
            if (anonymousId) {
                _this._analytics.user().anonymousId(anonymousId);
            }
        };
        this._createSubproductGetter = function (subproduct) { return createGetter(subproduct, 'Cannot get subproduct from the callback. Proceeding without it.'); };
        this._createEmbeddedProductGetter = function (embeddedProduct) { return createGetter(embeddedProduct, 'Cannot get embeddedProduct from the callback. Proceeding without it.'); };
        this._getLastScreenEvent = function () {
            try {
                return JSON.parse(_this._safeSessionStorage.getItem(LAST_SCREEN_EVENT_STORAGE_KEY));
            }
            catch (err) {
                _this._safeSessionStorage.removeItem(LAST_SCREEN_EVENT_STORAGE_KEY);
                return null;
            }
        };
        this._setLastScreenEvent = function (event) {
            _this._safeSessionStorage.setItem(LAST_SCREEN_EVENT_STORAGE_KEY, JSON.stringify({
                name: event.name,
                attributes: event.attributes,
            }));
        };
        this._shouldEventBeDelayed = function (event) {
            // TODO: this is a temporary restriction for the purposes of the Track All Changes project
            // The delay mechanism has a chance of event loss, which we can only accept for our own data at this point.
            // Once the delay queue implementation has been improved and measured to confirm that it is reliable enough,
            // then we will be able to open it up for other products to use by removing this check.
            if (!event.tags || event.tags.indexOf('measurement') === -1) {
                return false;
            }
            var isEventHighPriority = event.highPriority !== false; // defaults to true if excluded
            return _this._isDelayingLowPriorityEvents
                && !isEventHighPriority;
        };
        this._fireEvent = function (identifier, builtEvent, context, callback) {
            switch (builtEvent.eventType) {
                case eventType.UI:
                case eventType.OPERATIONAL:
                case eventType.TRACK:
                    return _this._analytics.track(identifier, builtEvent, context, callback);
                case eventType.SCREEN:
                    return _this._analytics.page(identifier, builtEvent, context, callback);
                case eventType.IDENTIFY:
                    return _this._analytics.identify(identifier, builtEvent, context, callback);
                default:
                    throw new Error("No handler has been defined for events of type " + builtEvent.eventType);
            }
        };
        this._fireDelayedEvent = function (identifier, builtEvent, context, userInfo) {
            try {
                // User information can change while the delay period is active, so we need to restore the values that
                // were active when the event was originally fired.
                _this._changeInternalUserId(userInfo.userId, userInfo.anonymousId);
                builtEvent.tags = __spread((builtEvent.tags || []), ['sentWithDelay']);
                // The callbacks for delayed events are fired immediately, so there is nothing to pass through for this argument.
                _this._fireEvent(identifier, builtEvent, context, undefined);
            }
            finally {
                _this._changeInternalUserId(_this._userInfo.userId, _this._userInfo.anonymousId);
            }
        };
        this._delayEvent = function (identifier, builtEvent, context, userInfo, callback) {
            _this._delayQueue.push(identifier, builtEvent, context, userInfo);
            // Fire the callback immediately, as we can consider the event successfully processed at this point
            if (callback)
                callback();
        };
        this._processEvent = function (identifier, builtEvent, context, callback) {
            _this._testingCache.saveEvent(builtEvent);
            if (_this._shouldEventBeDelayed(builtEvent)) {
                _this._delayEvent(identifier, builtEvent, context, _this._userInfo, callback);
            }
            else {
                _this._fireEvent(identifier, builtEvent, context, callback);
            }
        };
        this.setEmbeddedProduct = function (embeddedProduct) {
            _this._productInfo.embeddedProduct = _this._createEmbeddedProductGetter(embeddedProduct);
            _this.resetUIViewedTimers();
        };
        this.clearEmbeddedProduct = function () {
            _this._productInfo.embeddedProduct = _this._createEmbeddedProductGetter(null);
        };
        this.setSubproduct = function (subproduct) {
            _this._productInfo.subproduct = _this._createSubproductGetter(subproduct);
            _this.resetUIViewedTimers();
        };
        /**
         * Calling this function in the intialisation of the client in product
         * captures specified 'origin tracing' URL params and fires a single origin landed event
         * <p>
         * This function expects a mapping between the keys for any URL parameters
         *  that should be captured and removed for origin tracing
         * Multiple parameters may be captured simultaneously if multiple key: handler function pairs are provided
         * Each handler function should return an object with two items
         * a) 'originTracingAttributes' - an object that will be added to the 'origin landed' event's attributes under 'originTracing
         * b) 'taskSessionId' (optional) - an Id string that will be added to the tasksessions for any event that fires from the tab, with the key
         *    matching the URL parameter, for the purpose of attributing subsequent analytics event to the origin land.
         * </p>
         * The general use case for this feature is for allowing attributation of user behaviour to a out of product or cross product link,
         * e.g. from a share or email
         *
         * An example calling this function using an external decoding library, with taskSessionId specified to persist
         * analyticsWebClient.setOriginTracingHandlers({
              atlOrigin: encodedOrigin => {
                  const { id, product } = OriginTracing.fromEncoded(encodedOrigin);
                  return { originTracingAttributes: {'id': id, 'product': product}, taskSessionId: id };
              },
          });
         *
         * @param  {Object} originParamHandlerMapping a dictionary of mappings between origin url param keys and handler functions
         * @this {AnalyticsWebClient}
         */
        this.setOriginTracingHandlers = function (originParamHandlerMapping) {
            var capturedOriginTraces = _this.originTracing.handleOriginParameters(originParamHandlerMapping, _this._historyReplaceFn);
            Object.keys(capturedOriginTraces).forEach(function (x) {
                if (typeof capturedOriginTraces[x].taskSessionId !== 'undefined') {
                    _this.task.createTaskSessionWithProvidedId(x, capturedOriginTraces[x].taskSessionId);
                }
            });
            var originAttributes = {};
            Object.keys(capturedOriginTraces).forEach(function (x) {
                if (capturedOriginTraces[x].originTracingAttributes) {
                    originAttributes[x] = capturedOriginTraces[x].originTracingAttributes;
                }
                else {
                    // eslint-disable-next-line no-console
                    console.warn("Handling method for origin parameter " + x + " has not returned any attributes");
                }
            });
            if (Object.keys(capturedOriginTraces).length > 0) {
                _this.sendOperationalEvent({
                    action: 'landed',
                    actionSubject: 'origin',
                    source: 'webClient',
                    attributes: { originTracesLanded: originAttributes },
                }, function () { });
            }
        };
        this.setTenantInfo = function (tenantIdType, tenantId) {
            if (!tenantIdType) {
                throw new Error('Missing tenantIdType');
            }
            if (tenantIdType !== tenantType.NONE && !tenantId) {
                throw new Error('Missing tenantId');
            }
            if (!isType(tenantType, tenantIdType)) {
                throw new Error("Invalid tenantIdType '" + tenantIdType + "', " +
                    ("must be an tenantType: [" + objectValues(tenantType) + "]"));
            }
            _this._tenantInfo = {
                tenantIdType: tenantIdType,
                tenantId: tenantId,
            };
        };
        this.clearTenantInfo = function () {
            _this._tenantInfo = {};
        };
        this.setOrgInfo = function (orgId) {
            if (!orgId) {
                throw new Error('Missing orgId');
            }
            _this._orgInfo = {
                orgId: orgId,
            };
        };
        this.clearOrgInfo = function () {
            _this._orgInfo = {};
        };
        this.setUserInfo = function (userIdType, userId) {
            validateIdentifyEvent(userIdType, userId);
            _this._changeInternalUserId(userId);
            _this._userInfo = {
                userIdType: userIdType,
                userId: userId,
                anonymousId: _this._analytics.user().anonymousId(),
            };
        };
        this.clearUserInfo = function () {
            _this._changeInternalUserId(null);
            _this._userInfo = {
                anonymousId: _this._analytics.user().anonymousId(),
            };
        };
        this.setUIViewedAttributes = function (uiViewedAttributes) {
            if (!uiViewedAttributes) {
                throw new Error('Missing uiViewedAttributes');
            }
            if (typeof uiViewedAttributes !== 'object' || Array.isArray(uiViewedAttributes)) {
                throw new Error('Invalid uiViewedAttributes type, should be a non array object');
            }
            _this._uiViewedAttributes = __assign({}, uiViewedAttributes);
        };
        this.clearUIViewedAttributes = function () {
            _this._uiViewedAttributes = {};
        };
        this.sendIdentifyEvent = function (userIdType, userId, callback) {
            _this.setUserInfo(userIdType, userId);
            var builtEvent = {
                userIdType: userIdType,
                eventType: eventType.IDENTIFY,
            };
            _this._processEvent(userId, builtEvent, _this._context, callback);
        };
        /**
         * @deprecated
         * please use {@link sendScreenEvent instead)
         */
        this.sendPageEvent = function (name, callback) {
            _this.sendScreenEvent(name, callback);
        };
        /**
         * send screen event
         * @param event The event / For retrocompatibility event name is still supported here.
         * @param callback
         * @param attributes. Deprecated, will get ignored if using an event object as first param.
         */
        this.sendScreenEvent = function (event, callback, attributes) {
            var screenName;
            var screenAttributes;
            var screenContainers;
            var screenTags;
            if (typeof event === 'object') {
                /* This is for retrocompatibility */
                screenName = event.name;
                screenAttributes = event.attributes;
                screenContainers = event.containers;
                screenTags = event.tags;
            }
            else {
                screenName = event;
                screenAttributes = attributes;
            }
            validateScreenEvent(screenName);
            validateContainers(screenContainers);
            var builtEvent = buildScreenEvent(_this._productInfo, _this._tenantInfo, _this._userInfo, screenAttributes, event.nonPrivacySafeAttributes, screenTags, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo, screenContainers);
            var builtEventWithName = __assign({ name: screenName }, builtEvent);
            _this._setLastScreenEvent(builtEventWithName);
            _this._processEvent(screenName, builtEvent, _this._context, wrapCallback(callback, builtEventWithName));
        };
        this.sendTrackEvent = function (event, callback) {
            validateTrackEvent(event);
            var builtEvent = buildActionEvent(_this._productInfo, _this._tenantInfo, _this._userInfo, event, eventType.TRACK, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo);
            _this._processEvent(buildActionName(event), builtEvent, _this._context, wrapCallback(callback, builtEvent));
        };
        this.sendUIEvent = function (event, callback) {
            validateUIEvent(event);
            var builtEvent = buildActionEvent(_this._productInfo, _this._tenantInfo, _this._userInfo, event, eventType.UI, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo);
            _this._processEvent(buildActionName(event), builtEvent, _this._context, wrapCallback(callback, builtEvent));
        };
        this.sendOperationalEvent = function (event, callback) {
            validateOperationalEvent(event);
            var builtEvent = buildActionEvent(_this._productInfo, _this._tenantInfo, _this._userInfo, event, eventType.OPERATIONAL, _this._tabTracking.getCurrentTabId(), _this._sessionTracking.getCurrentSessionId(), _this.task.getAllTaskSessions(), _this._orgInfo);
            _this._processEvent(buildActionName(event), builtEvent, _this._context, wrapCallback(callback, builtEvent));
        };
        this.startUIViewedEvent = function (callback) {
            _this.stopUIViewedEvent();
            _this._uiViewedEvent = new UIViewedEvent(_this._productInfo, function () { return ({
                embeddedProduct: _this._productInfo.embeddedProduct(),
                subproduct: _this._productInfo.subproduct(),
                tenantIdType: _this._tenantInfo.tenantIdType,
                tenantId: _this._tenantInfo.tenantId,
                userId: _this._userInfo.userId,
                lastScreenEvent: _this._getLastScreenEvent(),
                attributes: _this._uiViewedAttributes,
            }); }, function (event) { return _this.sendUIEvent(event, callback); });
            _this._uiViewedEvent.start();
        };
        this.stopUIViewedEvent = function () {
            if (_this._uiViewedEvent) {
                _this._uiViewedEvent.stop();
                _this._uiViewedEvent = null;
            }
        };
        this.resetUIViewedTimers = function () {
            if (_this._uiViewedEvent) {
                _this._uiViewedEvent.resetTimers();
            }
        };
        this.startApdexEvent = function (apdexEvent) {
            _this._apdexEvent.start(apdexEvent);
        };
        this.getApdexStart = function (apdexEvent) { return _this._apdexEvent.getStart(apdexEvent); };
        this.stopApdexEvent = function (apdexEvent, callback) {
            _this._apdexEvent.stop(apdexEvent, callback);
        };
        this.startLowPriorityEventDelay = function (timeout) {
            if (timeout !== undefined && (isNaN(timeout) || timeout <= 0)) {
                throw new Error("Invalid timeout period: " + timeout + ", must be a number greater than 0");
            }
            if (_this._delayTimeout) {
                clearTimeout(_this._delayTimeout);
            }
            var delayTimeoutPeriod = timeout ? Math.min(timeout, MAX_DELAY_TIMEOUT) : MAX_DELAY_TIMEOUT;
            _this._delayTimeout = setTimeout(function () { return _this.stopLowPriorityEventDelay(); }, delayTimeoutPeriod);
            // If the queue is still flushing from a previous delay period, then we should cancel that flush
            // to stop it from negatively impacting the performance of the new critical section
            _this._delayQueue.cancelFlush();
            _this._isDelayingLowPriorityEvents = true;
        };
        this.stopLowPriorityEventDelay = function () {
            if (_this._delayTimeout) {
                clearTimeout(_this._delayTimeout);
                _this._delayTimeout = null;
            }
            _this._delayQueue.startFlush();
            _this._isDelayingLowPriorityEvents = false;
        };
        this.onEvent = function (analyticsId, analyticsData) {
            if (!analyticsData) {
                throw new Error('Missing analyticsData');
            }
            if (!analyticsData.eventType) {
                throw new Error('Missing analyticsData.eventType');
            }
            if (!isType(eventType, analyticsData.eventType)) {
                throw new Error("Invalid analyticsData.eventType '" + analyticsData.eventType + "', " +
                    ("must be an eventType: [" + objectValues(eventType) + "]"));
            }
            if (analyticsData.eventType === eventType.TRACK) {
                _this.sendTrackEvent(analyticsData);
            }
            else if (analyticsData.eventType === eventType.UI) {
                _this.sendUIEvent(analyticsData);
            }
            else if (analyticsData.eventType === eventType.OPERATIONAL) {
                _this.sendOperationalEvent(analyticsData);
            }
            else if (analyticsData.eventType === eventType.SCREEN) {
                _this.sendScreenEvent(analyticsData.name, null, analyticsData.attributes);
            }
            else if (analyticsData.eventType === eventType.IDENTIFY) {
                _this.sendIdentifyEvent(analyticsData.userIdType, analyticsData.userId);
            }
        };
        if (!productInfo) {
            throw new Error('Missing productInfo');
        }
        if (!productInfo.env) {
            throw new Error('Missing productInfo.env');
        }
        if (!productInfo.product) {
            throw new Error('Missing productInfo.product');
        }
        if (!isType(envType, productInfo.env)) {
            throw new Error("Invalid productInfo.env '" + productInfo.env + "', " +
                ("must be an envType: [" + objectValues(envType) + "]"));
        }
        if (!productInfo.origin) {
            productInfo.origin = originType.WEB;
        }
        else if (!isType(originType, productInfo.origin)) {
            throw new Error("Invalid productInfo.origin '" + productInfo.origin + "', " +
                ("must be an originType: [" + objectValues(originType) + "]"));
        }
        if (!productInfo.platform) {
            productInfo.platform =
                productInfo.origin === originType.WEB ? platformType.WEB : platformType.DESKTOP;
        }
        else {
            validatePlatform(productInfo);
        }
        productInfo.embeddedProduct = this._createEmbeddedProductGetter(productInfo.embeddedProduct);
        productInfo.subproduct = this._createSubproductGetter(productInfo.subproduct);
        var analytics = new Analytics();
        this._productInfo = __assign({}, productInfo);
        this._tenantInfo = {};
        this._orgInfo = {};
        this._userInfo = {
            anonymousId: analytics.user().anonymousId(),
        };
        this._uiViewedAttributes = {};
        this._context = buildContext(this._productInfo);
        this._safeSessionStorage = new SafeSessionStorage();
        var useStargate = this._useStargate(settings.useStargate);
        var maxRetryAttempts = settings.maxRetryAttempts || 4;
        var minRetryDelay = settings.minRetryDelay || 1000;
        var xidPromiseGetter = function () {
            if (settings.xidConsent) {
                var timeoutXidCallback_1 = function () { return [
                    { type: XIDItemType.XC, state: "TIMEOUT" /* TIMEOUT */ },
                    { type: XIDItemType.UID, state: "TIMEOUT" /* TIMEOUT */ },
                ]; };
                var unknownXidCallback_1 = function () { return [
                    { type: XIDItemType.XC, state: "UNKNOWN" /* UNKNOWN */ },
                    { type: XIDItemType.UID, state: "UNKNOWN" /* UNKNOWN */ },
                ]; };
                var P = Promise || PPromise;
                return P.race([
                    new XID(productInfo.env, XID_TIMEOUT)
                        .getXidCallbackForPromise()
                        .catch(function () { return unknownXidCallback_1; }),
                    new P(function (resolve) {
                        setTimeout(function () { return resolve(timeoutXidCallback_1); }, XID_TIMEOUT);
                    }),
                ]);
            }
            return undefined;
        };
        analytics.use(BeforeSendIntegration);
        analytics.use(SegmentIO);
        analytics.init({
            BeforeSend: {},
            'Segment.io': {
                apiKey: settings.apiKey || '',
                apiHost: settings.apiHost || this._selectHost({ useStargate: useStargate, env: productInfo.env }),
                retryQueue: true,
                retryQueuePrefix: "awc-" + productInfo.env,
                addBundledMetadata: true,
                unbundledIntegrations: ['Amplitude'],
                retryQueueOptions: {
                    maxRetryDelay: 60000,
                    minRetryDelay: minRetryDelay,
                    backoffFactor: 2,
                    maxAttempts: maxRetryAttempts,
                    maxItems: 100,
                },
                xidPromiseGetter: xidPromiseGetter,
            },
        }, {
            cookie: {
                secure: window.location.protocol === 'https:',
            },
            user: {
                // Stop the userId from persisting even after the user has logged out
                persist: false,
                // Stop the userId from being loaded from cookies set by other Segment clients
                cookie: {},
                // Stop the userId from being loaded from localStorage set by other Segment clients
                localStorage: {},
                localStorageFallbackDisabled: true,
            },
        });
        this._analytics = analytics;
        this._pageVisibility = new PageVisibility();
        this._tabTracking = new TabTracking();
        this._sessionTracking = new SessionTracking({
            sessionExpiryTime: settings.sessionExpiryTime,
        });
        this.task = new TaskSessionStore();
        this.originTracing = new OriginTracing();
        // Init Apdex
        this._apdexEvent = new ApdexEvent(this.sendOperationalEvent, this._pageVisibility);
        this._historyReplaceFn = typeof settings.historyReplaceFn === 'function'
            ? settings.historyReplaceFn
            : defaultHistoryReplaceFn;
        this._delayQueue = new EventDelayQueue(this._fireDelayedEvent, settings.delayQueueCompressors);
        this._testingCache = new TestingCache();
    }
    return AnalyticsWebClient;
}());
export default AnalyticsWebClient;
