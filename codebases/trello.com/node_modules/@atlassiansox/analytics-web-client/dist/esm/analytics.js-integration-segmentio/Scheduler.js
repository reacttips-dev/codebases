var SCHEDULER_OPTIONS_DEFAULT = {
    minRetryDelay: 1000,
    maxRetryDelay: 30000,
    backoffFactor: 2,
    backoffJitter: 0,
    waitInterval: 500,
};
var QUEUED_SCHEDULE_TYPES = {
    NONE: 'none',
    IMMEDIATE: 'immediate',
    WAIT: 'wait',
};
var Scheduler = /** @class */ (function () {
    function Scheduler(retryOptions, callback) {
        var _this = this;
        this.schedule = function (_a) {
            var _b = (_a === void 0 ? { immediate: false } : _a).immediate, immediate = _b === void 0 ? false : _b;
            if (_this.operationInFlight) {
                if (immediate) {
                    _this.queuedSchedule = QUEUED_SCHEDULE_TYPES.IMMEDIATE;
                }
                else if (_this.queuedSchedule !== QUEUED_SCHEDULE_TYPES.IMMEDIATE) {
                    _this.queuedSchedule = QUEUED_SCHEDULE_TYPES.WAIT;
                }
                // Only run immediately if we have no failures
            }
            else if (immediate && _this.failureCount === 0) {
                _this._clearTimeout();
                _this._run();
                // Backoff
            }
            else if (_this.failureCount > 0 && _this.scheduledTimeout === null) {
                _this.scheduledTimeout = window.setTimeout(_this._run, _this._calculateBackoff());
                // Schedule as normal
            }
            else if (_this.scheduledTimeout === null) {
                _this.scheduledTimeout = window.setTimeout(_this._run, _this.options.waitInterval);
            }
        };
        this.stop = function () {
            _this._clearTimeout();
            _this.queuedSchedule = QUEUED_SCHEDULE_TYPES.NONE;
        };
        this.getFailureCount = function () { return _this.failureCount; };
        this._clearTimeout = function () {
            if (_this.scheduledTimeout !== null) {
                window.clearTimeout(_this.scheduledTimeout);
                _this.scheduledTimeout = null;
            }
        };
        this._run = function () {
            _this.operationInFlight = true;
            _this._clearTimeout();
            try {
                _this.callback(_this._done);
            }
            catch (err) {
                _this._done(err);
            }
        };
        this._done = function (err) {
            _this.operationInFlight = false;
            if (err) {
                _this.failureCount++;
                _this._clearTimeout();
            }
            else {
                _this.failureCount = 0;
            }
            _this._processQueuedSchedule();
        };
        this._processQueuedSchedule = function () {
            if (_this.queuedSchedule !== QUEUED_SCHEDULE_TYPES.NONE) {
                var immediate = _this.queuedSchedule === QUEUED_SCHEDULE_TYPES.IMMEDIATE;
                _this.queuedSchedule = QUEUED_SCHEDULE_TYPES.NONE;
                _this.schedule({ immediate: immediate });
            }
        };
        this._calculateBackoff = function () {
            var _a = _this.options, minRetryDelay = _a.minRetryDelay, maxRetryDelay = _a.maxRetryDelay, backoffFactor = _a.backoffFactor, backoffJitter = _a.backoffJitter;
            var ms = minRetryDelay * (Math.pow(backoffFactor, _this.failureCount));
            if (backoffJitter) {
                var rand = Math.random();
                var deviation = Math.floor(rand * backoffJitter * ms);
                if (Math.floor(rand * 10) < 5) {
                    ms -= deviation;
                }
                else {
                    ms += deviation;
                }
            }
            return Number(Math.min(ms, maxRetryDelay).toPrecision(1));
        };
        this.options = {
            minRetryDelay: retryOptions.minRetryDelay || SCHEDULER_OPTIONS_DEFAULT.minRetryDelay,
            maxRetryDelay: retryOptions.maxRetryDelay || SCHEDULER_OPTIONS_DEFAULT.maxRetryDelay,
            backoffFactor: retryOptions.backoffFactor || SCHEDULER_OPTIONS_DEFAULT.backoffFactor,
            backoffJitter: retryOptions.backoffJitter || SCHEDULER_OPTIONS_DEFAULT.backoffJitter,
            waitInterval: retryOptions.waitInterval || SCHEDULER_OPTIONS_DEFAULT.waitInterval,
        };
        this.scheduledTimeout = null;
        this.failureCount = 0;
        this.callback = callback;
        this.operationInFlight = false;
        this.queuedSchedule = QUEUED_SCHEDULE_TYPES.NONE;
    }
    return Scheduler;
}());
export default Scheduler;
