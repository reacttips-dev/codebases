"use strict";
/*
(The MIT License)

Copyright (c) 2015 Segment.io <friends@segment.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/**
 * Module dependencies.
 */
var ads = require('@segment/ad-params');
var clone = require('component-clone');
var cookie = require('component-cookie');
var extend = require('@ndhoule/extend');
var integration = require('@segment/analytics.js-integration');
var json = require('json3');
var keys = require('@ndhoule/keys');
var localstorage = require('yields-store');
var md5 = require('spark-md5').hash;
var protocol = require('@segment/protocol');
var send = require('@segment/send-json');
var topDomain = require('@segment/top-domain');
var utm = require('@segment/utm-params');
var uuid = require('uuid').v4;
var BatchableQueue = require('./BatchableQueue').default;
var purgeOrphans = require('./purgeOrphanedQueues').default;
/**
 * Cookie options
 */
var cookieOptions = {
    // 1 year
    maxage: 31536000000,
    secure: window.location.protocol === 'https:',
    path: '/',
};
/**
 * Segment messages can be a maximum of 32kb.
 */
var MAX_SIZE = 32 * 1000;
/**
 * Queue options
 *
 * Attempt with exponential backoff for upto 10 times.
 * Backoff periods are: 1s, 2s, 4s, 8s, 16s, 32s, 64s, 128s (~2m), 256s (~4m),
 * 512s (~8.5m) and 1024s (~17m).
 */
var defaultQueueOptions = {
    maxRetryDelay: 60000,
    minRetryDelay: 1000,
    backoffFactor: 2,
    maxAttempts: 10,
    maxItems: 100,
};
/**
 * Expose `Segment` integration.
 */
var Segment = integration('Segment.io')
    .option('apiKey', '')
    .option('apiScheme', 'https')
    .option('apiHost', 'api.segment.io/v1')
    .option('crossDomainIdServers', [])
    .option('retryQueue', true)
    .option('retryQueuePrefix', 'awc')
    .option('addBundledMetadata', false)
    .option('unbundledIntegrations', [])
    .option('retryQueueOptions', defaultQueueOptions)
    .option('requestTimeout', 10 * 1000);
exports = Segment;
module.exports = Segment;
/**
 * Get the store.
 *
 * @return {Function}
 */
exports.storage = function () {
    return protocol() === 'file:' || protocol() === 'chrome-extension:' ? localstorage : cookie;
};
/**
 * Expose global for testing.
 */
exports.global = window;
/**
 * Send the given `obj` and `headers` to `url` with the specified `timeout` and
 * `fn(err, req)`. Exported for testing.
 *
 * @param {String} url
 * @param {Object} obj
 * @param {Object} headers
 * @param {long} timeout
 * @param {Function} fn
 * @api private
 */
exports.sendJsonWithTimeout = function (url, obj, headers, timeout, fn) {
    // only proceed with our new code path when cors is supported. this is
    // unlikely to happen in production, but we're being safe to preserve backward
    // compatibility.
    if (send.type !== 'xhr') {
        send(url, obj, headers, fn);
        return;
    }
    var req = new XMLHttpRequest();
    function done() {
        if (req.readyState === 4) {
            // Fail on 429 and 5xx HTTP errors
            if (req.status === 429 || req.status === 0 || (req.status >= 500 && req.status < 600)) {
                fn(new Error("HTTP Error " + req.status + " (" + (req.status === 0 ? 'Network error' : req.statusText) + ")"));
            }
            else {
                fn(null, req);
            }
        }
    }
    req.onerror = fn;
    req.onreadystatechange = done;
    req.withCredentials = true;
    req.open('POST', url, true);
    req.timeout = timeout;
    req.ontimeout = fn;
    // TODO: Remove this eslint disable
    // eslint-disable-next-line guard-for-in
    Object.entries(headers).forEach(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        req.setRequestHeader(key, value);
    });
    req.send(json.stringify(obj));
};
Segment.prototype.attachXid = function (item, xidCallback) {
    if (xidCallback && xidCallback instanceof Function) {
        if (item && item.msg && item.msg.properties &&
            ['screen', 'ui', 'operational', 'track'].indexOf(item.msg.properties.eventType) > -1) {
            var xid = xidCallback();
            if (xid && Array.isArray(xid)) {
                item.msg.properties.xid = xid;
            }
        }
        if (item && item.msg && item.msg.traits && item.msg.traits.userIdType && item.msg.type === 'identify') {
            var xid = xidCallback();
            if (xid && Array.isArray(xid)) {
                item.msg.traits.xid = xid;
            }
        }
    }
    return item;
};
Segment.prototype.attachXids = function (items) {
    var _this = this;
    if (this._xidPromiseCallback) {
        return this._xidPromiseCallback
            .then(function (xidCallback) {
            if (Array.isArray(items)) {
                return items.map(function (item) { return _this.attachXid(item, xidCallback); });
            }
            return _this.attachXid(items, xidCallback);
        }).catch(function () { return items; });
    }
    return items;
};
Segment.prototype.proccessBatchItems = function (originalItems, done) {
    var _this = this;
    var self = this;
    var itemsDiscardedByRetry = this._lsqueue.getDiscardCounter();
    var itemsDiscardedByOverflow = this._lsqueue.getOverflowCounter();
    var httpRetryCount = this._lsqueue.getGlobalRetryCount();
    var duplicateEventCount = this._lsqueue.getDuplicateCounter();
    var localstorageDuplicateCount = this._lsqueue.getLocalStorageDuplicateCounter();
    var process = function (items) {
        var sentAt = new Date().toISOString();
        var batchItems = items.map(function (item) {
            item.msg.sentAt = sentAt;
            return item.msg;
        });
        var batchObj = {
            batch: batchItems,
            sentAt: sentAt,
            metadata: {
                itemsDiscardedByRetry: itemsDiscardedByRetry,
                itemsDiscardedByOverflow: itemsDiscardedByOverflow,
                httpRetryCount: httpRetryCount,
                duplicateEventCount: duplicateEventCount,
                localstorageDuplicateCount: localstorageDuplicateCount,
            },
        };
        var url = _this.options.apiScheme + "://" + _this.options.apiHost + "/batch";
        var headers = { 'Content-Type': 'text/plain' };
        // send with 10s timeout
        return Segment.sendJsonWithTimeout(url, batchObj, headers, _this.options.requestTimeout, function (err, res) {
            self.debug('sent %O, received %O', batchObj, [err, res]);
            if (err)
                return done(err);
            return done(null, res);
        });
    };
    if (this._xidPromiseCallback) {
        return this.attachXids(originalItems).then(function (items) {
            process(items);
        });
    }
    return process(originalItems);
};
/**
 * Initialize.
 *
 * https://github.com/segmentio/segmentio/blob/master/modules/segmentjs/segment.js/v1/segment.js
 *
 * @api public
 */
Segment.prototype.initialize = function () {
    var self = this;
    if (this.options.retryQueue) {
        this._lsqueue = new BatchableQueue(this.options.retryQueuePrefix, this.options.retryQueueOptions, this.proccessBatchItems.bind(this));
        this._lsqueue.start();
    }
    if (this.options.xidPromiseGetter) {
        this._xidPromiseCallback = this.options.xidPromiseGetter();
    }
    this.ready();
    this.analytics.on('invoke', function (msg) {
        var action = msg.action();
        var listener = "on" + msg.action();
        self.debug('%s %o', action, msg);
        if (self[listener])
            self[listener](msg);
        self.ready();
    });
    // Migrate from old cross domain id cookie names
    if (this.cookie('segment_cross_domain_id')) {
        this.cookie('seg_xid', this.cookie('segment_cross_domain_id'));
        this.cookie('seg_xid_fd', this.cookie('segment_cross_domain_id_from_domain'));
        this.cookie('seg_xid_ts', this.cookie('segment_cross_domain_id_timestamp'));
        this.cookie('segment_cross_domain_id', null);
        this.cookie('segment_cross_domain_id_from_domain', null);
        this.cookie('segment_cross_domain_id_timestamp', null);
    }
    // At this moment we intentionally do not want events to be queued while we retrieve the `crossDomainId`
    // so `.ready` will get called right away and we'll try to figure out `crossDomainId`
    // separately
    if (this.options.crossDomainIdServers && this.options.crossDomainIdServers.length > 0) {
        this.retrieveCrossDomainId();
    }
    purgeOrphans(this.options.retryQueuePrefix);
};
/**
 * Loaded.
 *
 * @api private
 * @return {boolean}
 */
Segment.prototype.loaded = function () {
    return true;
};
/**
 * Page.
 *
 * @api public
 * @param {Page} page
 */
Segment.prototype.onpage = function (page) {
    this.enqueue('/p', page.json());
};
/**
 * Identify.
 *
 * @api public
 * @param {Identify} identify
 */
Segment.prototype.onidentify = function (identify) {
    this.enqueue('/i', identify.json());
};
/**
 * Group.
 *
 * @api public
 * @param {Group} group
 */
Segment.prototype.ongroup = function (group) {
    this.enqueue('/g', group.json());
};
/**
 * ontrack.
 *
 * TODO: Document this.
 *
 * @api private
 * @param {Track} track
 */
Segment.prototype.ontrack = function (track) {
    var trackJSON = track.json();
    // TODO: figure out why we need traits.
    delete trackJSON.traits;
    this.enqueue('/t', trackJSON);
};
/**
 * Alias.
 *
 * @api public
 * @param {Alias} alias
 */
Segment.prototype.onalias = function (alias) {
    var aliasJSON = alias.json();
    var user = this.analytics.user();
    aliasJSON.previousId = aliasJSON.previousId || aliasJSON.from || user.id() || user.anonymousId();
    aliasJSON.userId = aliasJSON.userId || aliasJSON.to;
    delete aliasJSON.from;
    delete aliasJSON.to;
    this.enqueue('/a', aliasJSON);
};
/**
 * Normalize the given `msg`.
 *
 * @api private
 * @param {Object} msg
 */
Segment.prototype.normalize = function (msg) {
    this.debug('normalize %o', msg);
    var user = this.analytics.user();
    var global = exports.global;
    var query = global.location.search;
    msg.context = msg.context || msg.options || {};
    var ctx = msg.context;
    delete msg.options;
    msg.writeKey = this.options.apiKey;
    ctx.userAgent = navigator.userAgent;
    if (!ctx.library)
        ctx.library = { name: 'analytics.js', version: this.analytics.VERSION };
    var crossDomainId = this.cookie('seg_xid');
    if (crossDomainId) {
        if (!ctx.traits) {
            ctx.traits = { crossDomainId: crossDomainId };
        }
        else if (!ctx.traits.crossDomainId) {
            ctx.traits.crossDomainId = crossDomainId;
        }
    }
    // if user provides campaign via context, do not overwrite with UTM qs param
    if (query && !ctx.campaign) {
        ctx.campaign = utm(query);
    }
    this.referrerId(query, ctx);
    msg.userId = msg.userId || user.id();
    msg.anonymousId = user.anonymousId();
    msg.sentAt = new Date();
    // Add _metadata.
    var failedInitializations = this.analytics.failedInitializations || [];
    /* eslint-disable no-underscore-dangle */
    if (failedInitializations.length > 0) {
        msg._metadata = { failedInitializations: failedInitializations };
    }
    if (this.options.addBundledMetadata) {
        var bundled = keys(this.analytics.Integrations);
        msg._metadata = msg._metadata || {};
        msg._metadata.bundled = bundled;
        msg._metadata.unbundled = this.options.unbundledIntegrations;
    }
    /* eslint-enable no-underscore-dangle */
    // add some randomness to the messageId checksum
    msg.messageId = "ajs-" + md5(json.stringify(msg) + uuid());
    this.debug('normalized %o', msg);
    this.ampId(ctx);
    return msg;
};
/**
 * Add amp id if it exists.
 *
 * @param {Object} ctx
 */
Segment.prototype.ampId = function (ctx) {
    var ampId = this.cookie('segment_amp_id');
    if (ampId)
        ctx.amp = { id: ampId };
};
/**
 * Send `obj` to `path`.
 *
 * @api private
 * @param {string} path
 * @param {Object} obj
 * @param {Function} fn
 */
Segment.prototype.enqueue = function (path, message, fn) {
    var url = this.options.apiScheme + "://" + this.options.apiHost + path;
    var headers = { 'Content-Type': 'text/plain' };
    var msg = this.normalize(message);
    // Print a log statement when messages exceed the maximum size. In the future,
    // we may consider dropping this event on the client entirely.
    if (json.stringify(msg).length > MAX_SIZE) {
        this.debug('message must be less than 32kb %O', msg);
    }
    this.debug('enqueueing %O', msg);
    var self = this;
    if (this.options.retryQueue) {
        this._lsqueue.addItem({
            url: url,
            headers: headers,
            msg: msg,
        });
    }
    else {
        // eslint-disable-next-line consistent-return
        send(url, msg, headers, function (err, res) {
            self.debug('sent %O, received %O', msg, [err, res]);
            if (fn) {
                if (err)
                    return fn(err);
                fn(null, res);
            }
        });
    }
};
/**
 * Gets/sets cookies on the appropriate domain.
 *
 * @api private
 * @param {string} name
 * @param {*} val
 */
// eslint-disable-next-line consistent-return
Segment.prototype.cookie = function (name, val) {
    var store = Segment.storage();
    if (arguments.length === 1)
        return store(name);
    var global = exports.global;
    var href = global.location.href;
    var domain = "." + topDomain(href);
    if (domain === '.')
        domain = '';
    this.debug('store domain %s -> %s', href, domain);
    var opts = clone(cookieOptions);
    opts.domain = domain;
    this.debug('store %s, %s, %o', name, val, opts);
    store(name, val, opts);
    // eslint-disable-next-line consistent-return
    if (store(name))
        return;
    delete opts.domain;
    this.debug('fallback store %s, %s, %o', name, val, opts);
    store(name, val, opts);
};
/**
 * Add referrerId to context.
 *
 * TODO: remove.
 *
 * @api private
 * @param {Object} query
 * @param {Object} ctx
 */
Segment.prototype.referrerId = function (query, ctx) {
    var stored = this.cookie('s:context.referrer');
    var ad;
    if (stored)
        stored = json.parse(stored);
    if (query)
        ad = ads(query);
    ad = ad || stored;
    if (!ad)
        return;
    ctx.referrer = extend(ctx.referrer || {}, ad);
    this.cookie('s:context.referrer', json.stringify(ad));
};
/**
 * getTld
 * Get domain.com from subdomain.domain.com, etc.
 * @param {string} domain
 * @return {string} tld
 */
function getTld(domain) {
    return domain.split('.').splice(-2).join('.');
}
/**
 * getJson
 * @param {string} url
 * @param {function} callback => err, json
 */
function getJson(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.withCredentials = true;
    xhr.onreadystatechange = function () {
        if (xhr.readyState === XMLHttpRequest.DONE) {
            if (xhr.status >= 200 && xhr.status < 300) {
                callback(null, xhr.responseText ? json.parse(xhr.responseText) : null);
            }
            else {
                callback(xhr.statusText || 'Unknown Error', null);
            }
        }
    };
    xhr.send();
}
/**
 * getCrossDomainId
 * @param {Array} domain
 * @param {string} writeKey
 * @param {function} callback => err, {domain, id}
 */
function getCrossDomainIdFromSingleServer(domain, writeKey, callback) {
    var endpoint = "https://" + domain + "/v1/id/" + writeKey;
    getJson(endpoint, function (err, res) {
        if (err) {
            callback(err, null);
        }
        else {
            callback(null, {
                domain: domain,
                id: (res && res.id) || null,
            });
        }
    });
}
/**
 * getCrossDomainIdFromServers
 * @param {Array} domains
 * @param {string} writeKey
 * @param {function} callback => err, {domain, id}
 */
function getCrossDomainIdFromServerList(domains, writeKey, callback) {
    // Should not happen but special case
    if (domains.length === 0) {
        callback(null, null);
    }
    var crossDomainIdFound = false;
    var finishedRequests = 0;
    var error = null;
    domains.forEach(function (domain) {
        getCrossDomainIdFromSingleServer(domain, writeKey, function (err, res) {
            finishedRequests++;
            if (err) {
                // if request against a particular domain fails, we won't early exit
                // but rather wait and see if requests to other domains succeed
                error = err;
            }
            else if (res && res.id && !crossDomainIdFound) {
                // If we found an xid from any of the servers, we'll just early exit and callback
                crossDomainIdFound = true;
                callback(null, res);
            }
            if (finishedRequests === domains.length && !crossDomainIdFound) {
                // Error is non-null if we encountered an issue, otherwise error will be null
                // meaning that no domains in the list has an xid for current user
                callback(error, null);
            }
        });
    });
}
/**
 * retrieveCrossDomainId.
 *
 * @api private
 * @param {function) callback => err, {crossDomainId, fromServer, timestamp}
 */
Segment.prototype.retrieveCrossDomainId = function (callback) {
    if (!this.options.crossDomainIdServers) {
        if (callback) {
            callback('crossDomainId not enabled', null);
        }
        return;
    }
    if (!this.cookie('seg_xid')) {
        var self_1 = this;
        var writeKey = this.options.apiKey;
        // Exclude the current domain from the list of servers we're querying
        var currentTld_1 = getTld(window.location.hostname);
        var domains_1 = [];
        this.options.crossDomainIdServers.forEach(function (domain) {
            if (getTld(domain) !== currentTld_1) {
                domains_1.push(domain);
            }
        });
        getCrossDomainIdFromServerList(domains_1, writeKey, function (err, res) {
            if (err) {
                // We optimize for no conflicting xid as much as possible. So bail out if there is an
                // error and we cannot be sure that xid does not exist on any other domains
                if (callback) {
                    callback(err, null);
                }
                return;
            }
            var crossDomainId = null;
            var fromDomain = null;
            if (res) {
                crossDomainId = res.id;
                fromDomain = res.domain;
            }
            else {
                crossDomainId = uuid();
                fromDomain = window.location.hostname;
            }
            var currentTimeMillis = (new Date()).getTime();
            self_1.cookie('seg_xid', crossDomainId);
            // Not actively used. Saving for future conflict resolution purposes
            self_1.cookie('seg_xid_fd', fromDomain);
            self_1.cookie('seg_xid_ts', currentTimeMillis);
            self_1.analytics.identify({
                crossDomainId: crossDomainId,
            });
            if (callback) {
                callback(null, {
                    crossDomainId: crossDomainId,
                    fromDomain: fromDomain,
                    timestamp: currentTimeMillis,
                });
            }
        });
    }
};
