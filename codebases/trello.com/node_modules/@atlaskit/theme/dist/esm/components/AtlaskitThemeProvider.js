import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import styled, { ThemeProvider } from 'styled-components';
import exenv from 'exenv';
import * as colors from '../colors';
import { CHANNEL, DEFAULT_THEME_MODE } from '../constants'; // For forward-compat until everything is upgraded.

import Theme from './Theme';

function getStylesheetResetCSS(backgroundColor) {
  return "\n    body { background: ".concat(backgroundColor, "; }\n  ");
}

function buildThemeState(mode) {
  return {
    theme: _defineProperty({}, CHANNEL, {
      mode: mode
    })
  };
}

var LegacyReset = styled.div(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  background-color: ", ";\n  color: ", ";\n\n  a {\n    color: ", ";\n  }\n  a:hover {\n    color: ", ";\n  }\n  a:active {\n    color: ", ";\n  }\n  a:focus {\n    outline-color: ", ";\n  }\n  h1 {\n    color: ", ";\n  }\n  h2 {\n    color: ", ";\n  }\n  h3 {\n    color: ", ";\n  }\n  h4 {\n    color: ", ";\n  }\n  h5 {\n    color: ", ";\n  }\n  h6 {\n    color: ", ";\n  }\n  small {\n    color: ", ";\n  }\n"])), function (p) {
  return p.background;
}, colors.text, colors.link, colors.linkHover, colors.linkActive, colors.linkOutline, colors.heading, colors.heading, colors.heading, colors.heading, colors.heading, colors.subtleHeading, colors.subtleText);

var AtlaskitThemeProvider = /*#__PURE__*/function (_Component) {
  _inherits(AtlaskitThemeProvider, _Component);

  var _super = _createSuper(AtlaskitThemeProvider);

  function AtlaskitThemeProvider(props) {
    var _this;

    _classCallCheck(this, AtlaskitThemeProvider);

    _this = _super.call(this, props);
    _this.state = buildThemeState(props.mode);
    _this.themeFnMap = {
      dark: function dark() {
        return {
          mode: _this.state.theme[CHANNEL].mode
        };
      },
      light: function light() {
        return {
          mode: _this.state.theme[CHANNEL].mode
        };
      }
    };
    return _this;
  }

  _createClass(AtlaskitThemeProvider, [{
    key: "getChildContext",
    value: function getChildContext() {
      return {
        hasAtlaskitThemeProvider: true
      };
    }
  }, {
    key: "UNSAFE_componentWillMount",
    value: function UNSAFE_componentWillMount() {
      if (!this.context.hasAtlaskitThemeProvider && exenv.canUseDOM) {
        var css = getStylesheetResetCSS(this.props.background(this.state));
        this.stylesheet = document.createElement('style');
        this.stylesheet.type = 'text/css';
        this.stylesheet.innerHTML = css;

        if (document && document.head) {
          document.head.appendChild(this.stylesheet);
        }
      }
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(newProps) {
      if (newProps.mode !== this.props.mode) {
        var newThemeState = buildThemeState(newProps.mode);

        if (this.stylesheet) {
          var css = getStylesheetResetCSS(newProps.background(newThemeState));
          this.stylesheet.innerHTML = css;
        }

        this.setState(newThemeState);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.stylesheet && document && document.head) {
        document.head.removeChild(this.stylesheet);
        delete this.stylesheet;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children;
      var theme = this.state.theme;
      return (
        /*#__PURE__*/

        /* Wrapping the new provider around the old one provides forward
        compatibility when using the old provider for styled components. This
        allows us to use components converted to use the new API with consumers
        using the old provider along side components that may still be using the
        old theming API. */
        React.createElement(Theme.Provider, {
          value: this.themeFnMap[this.props.mode]
        }, /*#__PURE__*/React.createElement(ThemeProvider, {
          theme: theme
        }, /*#__PURE__*/React.createElement(LegacyReset, {
          background: this.props.background
        }, children)))
      );
    }
  }]);

  return AtlaskitThemeProvider;
}(Component);

_defineProperty(AtlaskitThemeProvider, "defaultProps", {
  mode: DEFAULT_THEME_MODE,
  background: colors.background
});

_defineProperty(AtlaskitThemeProvider, "childContextTypes", {
  hasAtlaskitThemeProvider: PropTypes.bool
});

_defineProperty(AtlaskitThemeProvider, "contextTypes", {
  hasAtlaskitThemeProvider: PropTypes.bool
});

export { AtlaskitThemeProvider as default };