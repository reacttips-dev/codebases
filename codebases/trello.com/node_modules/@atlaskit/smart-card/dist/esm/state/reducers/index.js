import _defineProperty from "@babel/runtime/helpers/defineProperty";

var _cardReducerMap;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import * as actions from '../actions/constants';
import { getStatus } from '../helpers';
var cardReducerMap = (_cardReducerMap = {}, _defineProperty(_cardReducerMap, actions.ACTION_PENDING, function (_state, _ref) {
  var type = _ref.type;
  return {
    status: type,
    lastUpdatedAt: Date.now()
  };
}), _defineProperty(_cardReducerMap, actions.ACTION_RESOLVING, function (state, _ref2) {
  var type = _ref2.type;
  return _objectSpread(_objectSpread({}, state), {}, {
    status: type
  });
}), _defineProperty(_cardReducerMap, actions.ACTION_RESOLVED, function (state, _ref3) {
  var type = _ref3.type,
      payload = _ref3.payload;
  var nextDetails = payload;

  var nextState = _objectSpread({}, state);

  if (nextDetails) {
    nextState.status = getStatus(nextDetails);
    nextState.details = nextDetails;
  } else {
    // Keep the pre-existing data in the store. If there
    // is no data, the UI should handle this gracefully.
    nextState.status = type;
  }

  nextState.lastUpdatedAt = Date.now();
  return nextState;
}), _defineProperty(_cardReducerMap, actions.ACTION_ERROR, function (state, _ref4) {
  var type = _ref4.type,
      error = _ref4.error;
  return _objectSpread(_objectSpread({}, state), {}, {
    status: type,
    error: error
  });
}), _defineProperty(_cardReducerMap, actions.ACTION_ERROR_FALLBACK, function (state, _ref5) {
  var type = _ref5.type,
      error = _ref5.error;
  return _objectSpread(_objectSpread({}, state), {}, {
    status: type,
    error: error
  });
}), _cardReducerMap);
export var cardReducer = function cardReducer(state, action) {
  if (cardReducerMap[action.type]) {
    var cardState = state[action.url]; // Card may have reached the same state on account of multiple of the same
    // URL being present in an editor session. E.g. page with N links to one resource.

    var hasSameStatus = cardState && cardState.status === action.type; // Card needs to be refreshed. In this case, we ignore the same status pragma which
    // is described above - this forces a rerender for all links of the same status.

    var hasExpired = action.hasExpired;

    if (!hasExpired && hasSameStatus) {
      return state;
    } else {
      var nextState = cardReducerMap[action.type](cardState, action);
      return _objectSpread(_objectSpread({}, state), {}, _defineProperty({}, action.url, nextState));
    }
  }

  return state;
};