'use strict';

var _defineProperty = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/createClass");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _require = require('url'),
    fileURLToPath = _require.fileURLToPath,
    pathToFileURL = _require.pathToFileURL;

var _require2 = require('path'),
    resolve = _require2.resolve,
    isAbsolute = _require2.isAbsolute;

var _require3 = require('source-map'),
    SourceMapConsumer = _require3.SourceMapConsumer,
    SourceMapGenerator = _require3.SourceMapGenerator;

var _require4 = require('nanoid/non-secure'),
    nanoid = _require4.nanoid;

var terminalHighlight = require('./terminal-highlight');

var CssSyntaxError = require('./css-syntax-error');

var PreviousMap = require('./previous-map');

var fromOffsetCache = Symbol('fromOffset cache');
var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
var pathAvailable = Boolean(resolve && isAbsolute);

var Input = /*#__PURE__*/function () {
  function Input(css) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Input);

    if (css === null || typeof css === 'undefined' || typeof css === 'object' && !css.toString) {
      throw new Error("PostCSS received ".concat(css, " instead of CSS string"));
    }

    this.css = css.toString();

    if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }

    if (opts.from) {
      if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve(opts.from);
      }
    }

    if (pathAvailable && sourceMapAvailable) {
      var map = new PreviousMap(this.css, opts);

      if (map.text) {
        this.map = map;
        var file = map.consumer().file;
        if (!this.file && file) this.file = this.mapResolve(file);
      }
    }

    if (!this.file) {
      this.id = '<input css ' + nanoid(6) + '>';
    }

    if (this.map) this.map.file = this.from;
  }

  _createClass(Input, [{
    key: "fromOffset",
    value: function fromOffset(offset) {
      var lastLine, lineToIndex;

      if (!this[fromOffsetCache]) {
        var lines = this.css.split('\n');
        lineToIndex = new Array(lines.length);
        var prevIndex = 0;

        for (var i = 0, l = lines.length; i < l; i++) {
          lineToIndex[i] = prevIndex;
          prevIndex += lines[i].length + 1;
        }

        this[fromOffsetCache] = lineToIndex;
      } else {
        lineToIndex = this[fromOffsetCache];
      }

      lastLine = lineToIndex[lineToIndex.length - 1];
      var min = 0;

      if (offset >= lastLine) {
        min = lineToIndex.length - 1;
      } else {
        var max = lineToIndex.length - 2;
        var mid;

        while (min < max) {
          mid = min + (max - min >> 1);

          if (offset < lineToIndex[mid]) {
            max = mid - 1;
          } else if (offset >= lineToIndex[mid + 1]) {
            min = mid + 1;
          } else {
            min = mid;
            break;
          }
        }
      }

      return {
        line: min + 1,
        col: offset - lineToIndex[min] + 1
      };
    }
  }, {
    key: "error",
    value: function error(message, line, column) {
      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var result;

      if (!column) {
        var pos = this.fromOffset(line);
        line = pos.line;
        column = pos.col;
      }

      var origin = this.origin(line, column);

      if (origin) {
        result = new CssSyntaxError(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
      } else {
        result = new CssSyntaxError(message, line, column, this.css, this.file, opts.plugin);
      }

      result.input = {
        line: line,
        column: column,
        source: this.css
      };

      if (this.file) {
        if (pathToFileURL) {
          result.input.url = pathToFileURL(this.file).toString();
        }

        result.input.file = this.file;
      }

      return result;
    }
  }, {
    key: "origin",
    value: function origin(line, column) {
      if (!this.map) return false;
      var consumer = this.map.consumer();
      var from = consumer.originalPositionFor({
        line: line,
        column: column
      });
      if (!from.source) return false;
      var fromUrl;

      if (isAbsolute(from.source)) {
        fromUrl = pathToFileURL(from.source);
      } else {
        fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));
      }

      var result = {
        url: fromUrl.toString(),
        line: from.line,
        column: from.column
      };

      if (fromUrl.protocol === 'file:') {
        if (fileURLToPath) {
          result.file = fileURLToPath(fromUrl);
        } else {
          // istanbul ignore next
          throw new Error("file: protocol is not available in this PostCSS build");
        }
      }

      var source = consumer.sourceContentFor(from.source);
      if (source) result.source = source;
      return result;
    }
  }, {
    key: "mapResolve",
    value: function mapResolve(file) {
      if (/^\w+:\/\//.test(file)) {
        return file;
      }

      return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file);
    }
  }, {
    key: "from",
    get: function get() {
      return this.file || this.id;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {};

      for (var _i = 0, _arr = ['hasBOM', 'css', 'file', 'id']; _i < _arr.length; _i++) {
        var name = _arr[_i];

        if (this[name] != null) {
          json[name] = this[name];
        }
      }

      if (this.map) {
        json.map = _objectSpread({}, this.map);

        if (json.map.consumerCache) {
          json.map.consumerCache = undefined;
        }
      }

      return json;
    }
  }]);

  return Input;
}();

module.exports = Input;
Input.default = Input;

if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input);
}