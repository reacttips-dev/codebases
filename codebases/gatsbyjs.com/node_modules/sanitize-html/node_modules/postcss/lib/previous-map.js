'use strict';

var _classCallCheck = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/createClass");

var _require = require('fs'),
    existsSync = _require.existsSync,
    readFileSync = _require.readFileSync;

var _require2 = require('path'),
    dirname = _require2.dirname,
    join = _require2.join;

var _require3 = require('source-map'),
    SourceMapConsumer = _require3.SourceMapConsumer,
    SourceMapGenerator = _require3.SourceMapGenerator;

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString();
  } else {
    // istanbul ignore next
    return window.atob(str);
  }
}

var PreviousMap = /*#__PURE__*/function () {
  function PreviousMap(css, opts) {
    _classCallCheck(this, PreviousMap);

    if (opts.map === false) return;
    this.loadAnnotation(css);
    this.inline = this.startWith(this.annotation, 'data:');
    var prev = opts.map ? opts.map.prev : undefined;
    var text = this.loadMap(opts.from, prev);

    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }

    if (this.mapFile) this.root = dirname(this.mapFile);
    if (text) this.text = text;
  }

  _createClass(PreviousMap, [{
    key: "consumer",
    value: function consumer() {
      if (!this.consumerCache) {
        this.consumerCache = new SourceMapConsumer(this.text);
      }

      return this.consumerCache;
    }
  }, {
    key: "withContent",
    value: function withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }, {
    key: "startWith",
    value: function startWith(string, start) {
      if (!string) return false;
      return string.substr(0, start.length) === start;
    }
  }, {
    key: "getAnnotationURL",
    value: function getAnnotationURL(sourceMapString) {
      return sourceMapString.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
    }
  }, {
    key: "loadAnnotation",
    value: function loadAnnotation(css) {
      var annotations = css.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);

      if (annotations && annotations.length > 0) {
        // Locate the last sourceMappingURL to avoid picking up
        // sourceMappingURLs from comments, strings, etc.
        var lastAnnotation = annotations[annotations.length - 1];

        if (lastAnnotation) {
          this.annotation = this.getAnnotationURL(lastAnnotation);
        }
      }
    }
  }, {
    key: "decodeInline",
    value: function decodeInline(text) {
      var baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
      var baseUri = /^data:application\/json;base64,/;
      var charsetUri = /^data:application\/json;charset=utf-?8,/;
      var uri = /^data:application\/json,/;

      if (charsetUri.test(text) || uri.test(text)) {
        return decodeURIComponent(text.substr(RegExp.lastMatch.length));
      }

      if (baseCharsetUri.test(text) || baseUri.test(text)) {
        return fromBase64(text.substr(RegExp.lastMatch.length));
      }

      var encoding = text.match(/data:application\/json;([^,]+),/)[1];
      throw new Error('Unsupported source map encoding ' + encoding);
    }
  }, {
    key: "loadFile",
    value: function loadFile(path) {
      this.root = dirname(path);

      if (existsSync(path)) {
        this.mapFile = path;
        return readFileSync(path, 'utf-8').toString().trim();
      }
    }
  }, {
    key: "loadMap",
    value: function loadMap(file, prev) {
      if (prev === false) return false;

      if (prev) {
        if (typeof prev === 'string') {
          return prev;
        } else if (typeof prev === 'function') {
          var prevPath = prev(file);

          if (prevPath) {
            var map = this.loadFile(prevPath);

            if (!map) {
              throw new Error('Unable to load previous source map: ' + prevPath.toString());
            }

            return map;
          }
        } else if (prev instanceof SourceMapConsumer) {
          return SourceMapGenerator.fromSourceMap(prev).toString();
        } else if (prev instanceof SourceMapGenerator) {
          return prev.toString();
        } else if (this.isMap(prev)) {
          return JSON.stringify(prev);
        } else {
          throw new Error('Unsupported previous source map format: ' + prev.toString());
        }
      } else if (this.inline) {
        return this.decodeInline(this.annotation);
      } else if (this.annotation) {
        var _map = this.annotation;
        if (file) _map = join(dirname(file), _map);
        return this.loadFile(_map);
      }
    }
  }, {
    key: "isMap",
    value: function isMap(map) {
      if (typeof map !== 'object') return false;
      return typeof map.mappings === 'string' || typeof map._mappings === 'string' || Array.isArray(map.sections);
    }
  }]);

  return PreviousMap;
}();

module.exports = PreviousMap;
PreviousMap.default = PreviousMap;