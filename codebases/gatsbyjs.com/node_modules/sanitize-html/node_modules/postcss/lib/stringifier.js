'use strict';

var _classCallCheck = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/createClass");

var DEFAULT_RAW = {
  colon: ': ',
  indent: '    ',
  beforeDecl: '\n',
  beforeRule: '\n',
  beforeOpen: ' ',
  beforeClose: '\n',
  beforeComment: '\n',
  after: '\n',
  emptyBody: '',
  commentLeft: ' ',
  commentRight: ' ',
  semicolon: false
};

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}

var Stringifier = /*#__PURE__*/function () {
  function Stringifier(builder) {
    _classCallCheck(this, Stringifier);

    this.builder = builder;
  }

  _createClass(Stringifier, [{
    key: "stringify",
    value: function stringify(node, semicolon) {
      /* istanbul ignore if */
      if (!this[node.type]) {
        throw new Error('Unknown AST node type ' + node.type + '. ' + 'Maybe you need to change PostCSS stringifier.');
      }

      this[node.type](node, semicolon);
    }
  }, {
    key: "root",
    value: function root(node) {
      this.body(node);
      if (node.raws.after) this.builder(node.raws.after);
    }
  }, {
    key: "comment",
    value: function comment(node) {
      var left = this.raw(node, 'left', 'commentLeft');
      var right = this.raw(node, 'right', 'commentRight');
      this.builder('/*' + left + node.text + right + '*/', node);
    }
  }, {
    key: "decl",
    value: function decl(node, semicolon) {
      var between = this.raw(node, 'between', 'colon');
      var string = node.prop + between + this.rawValue(node, 'value');

      if (node.important) {
        string += node.raws.important || ' !important';
      }

      if (semicolon) string += ';';
      this.builder(string, node);
    }
  }, {
    key: "rule",
    value: function rule(node) {
      this.block(node, this.rawValue(node, 'selector'));

      if (node.raws.ownSemicolon) {
        this.builder(node.raws.ownSemicolon, node, 'end');
      }
    }
  }, {
    key: "atrule",
    value: function atrule(node, semicolon) {
      var name = '@' + node.name;
      var params = node.params ? this.rawValue(node, 'params') : '';

      if (typeof node.raws.afterName !== 'undefined') {
        name += node.raws.afterName;
      } else if (params) {
        name += ' ';
      }

      if (node.nodes) {
        this.block(node, name + params);
      } else {
        var end = (node.raws.between || '') + (semicolon ? ';' : '');
        this.builder(name + params + end, node);
      }
    }
  }, {
    key: "body",
    value: function body(node) {
      var last = node.nodes.length - 1;

      while (last > 0) {
        if (node.nodes[last].type !== 'comment') break;
        last -= 1;
      }

      var semicolon = this.raw(node, 'semicolon');

      for (var i = 0; i < node.nodes.length; i++) {
        var child = node.nodes[i];
        var before = this.raw(child, 'before');
        if (before) this.builder(before);
        this.stringify(child, last !== i || semicolon);
      }
    }
  }, {
    key: "block",
    value: function block(node, start) {
      var between = this.raw(node, 'between', 'beforeOpen');
      this.builder(start + between + '{', node, 'start');
      var after;

      if (node.nodes && node.nodes.length) {
        this.body(node);
        after = this.raw(node, 'after');
      } else {
        after = this.raw(node, 'after', 'emptyBody');
      }

      if (after) this.builder(after);
      this.builder('}', node, 'end');
    }
  }, {
    key: "raw",
    value: function raw(node, own, detect) {
      var value;
      if (!detect) detect = own; // Already had

      if (own) {
        value = node.raws[own];
        if (typeof value !== 'undefined') return value;
      }

      var parent = node.parent; // Hack for first rule in CSS

      if (detect === 'before') {
        if (!parent || parent.type === 'root' && parent.first === node) {
          return '';
        }
      } // Floating child without parent


      if (!parent) return DEFAULT_RAW[detect]; // Detect style by other nodes

      var root = node.root();
      if (!root.rawCache) root.rawCache = {};

      if (typeof root.rawCache[detect] !== 'undefined') {
        return root.rawCache[detect];
      }

      if (detect === 'before' || detect === 'after') {
        return this.beforeAfter(node, detect);
      } else {
        var method = 'raw' + capitalize(detect);

        if (this[method]) {
          value = this[method](root, node);
        } else {
          root.walk(function (i) {
            value = i.raws[own];
            if (typeof value !== 'undefined') return false;
          });
        }
      }

      if (typeof value === 'undefined') value = DEFAULT_RAW[detect];
      root.rawCache[detect] = value;
      return value;
    }
  }, {
    key: "rawSemicolon",
    value: function rawSemicolon(root) {
      var value;
      root.walk(function (i) {
        if (i.nodes && i.nodes.length && i.last.type === 'decl') {
          value = i.raws.semicolon;
          if (typeof value !== 'undefined') return false;
        }
      });
      return value;
    }
  }, {
    key: "rawEmptyBody",
    value: function rawEmptyBody(root) {
      var value;
      root.walk(function (i) {
        if (i.nodes && i.nodes.length === 0) {
          value = i.raws.after;
          if (typeof value !== 'undefined') return false;
        }
      });
      return value;
    }
  }, {
    key: "rawIndent",
    value: function rawIndent(root) {
      if (root.raws.indent) return root.raws.indent;
      var value;
      root.walk(function (i) {
        var p = i.parent;

        if (p && p !== root && p.parent && p.parent === root) {
          if (typeof i.raws.before !== 'undefined') {
            var parts = i.raws.before.split('\n');
            value = parts[parts.length - 1];
            value = value.replace(/\S/g, '');
            return false;
          }
        }
      });
      return value;
    }
  }, {
    key: "rawBeforeComment",
    value: function rawBeforeComment(root, node) {
      var value;
      root.walkComments(function (i) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before;

          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      });

      if (typeof value === 'undefined') {
        value = this.raw(node, null, 'beforeDecl');
      } else if (value) {
        value = value.replace(/\S/g, '');
      }

      return value;
    }
  }, {
    key: "rawBeforeDecl",
    value: function rawBeforeDecl(root, node) {
      var value;
      root.walkDecls(function (i) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before;

          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      });

      if (typeof value === 'undefined') {
        value = this.raw(node, null, 'beforeRule');
      } else if (value) {
        value = value.replace(/\S/g, '');
      }

      return value;
    }
  }, {
    key: "rawBeforeRule",
    value: function rawBeforeRule(root) {
      var value;
      root.walk(function (i) {
        if (i.nodes && (i.parent !== root || root.first !== i)) {
          if (typeof i.raws.before !== 'undefined') {
            value = i.raws.before;

            if (value.includes('\n')) {
              value = value.replace(/[^\n]+$/, '');
            }

            return false;
          }
        }
      });
      if (value) value = value.replace(/\S/g, '');
      return value;
    }
  }, {
    key: "rawBeforeClose",
    value: function rawBeforeClose(root) {
      var value;
      root.walk(function (i) {
        if (i.nodes && i.nodes.length > 0) {
          if (typeof i.raws.after !== 'undefined') {
            value = i.raws.after;

            if (value.includes('\n')) {
              value = value.replace(/[^\n]+$/, '');
            }

            return false;
          }
        }
      });
      if (value) value = value.replace(/\S/g, '');
      return value;
    }
  }, {
    key: "rawBeforeOpen",
    value: function rawBeforeOpen(root) {
      var value;
      root.walk(function (i) {
        if (i.type !== 'decl') {
          value = i.raws.between;
          if (typeof value !== 'undefined') return false;
        }
      });
      return value;
    }
  }, {
    key: "rawColon",
    value: function rawColon(root) {
      var value;
      root.walkDecls(function (i) {
        if (typeof i.raws.between !== 'undefined') {
          value = i.raws.between.replace(/[^\s:]/g, '');
          return false;
        }
      });
      return value;
    }
  }, {
    key: "beforeAfter",
    value: function beforeAfter(node, detect) {
      var value;

      if (node.type === 'decl') {
        value = this.raw(node, null, 'beforeDecl');
      } else if (node.type === 'comment') {
        value = this.raw(node, null, 'beforeComment');
      } else if (detect === 'before') {
        value = this.raw(node, null, 'beforeRule');
      } else {
        value = this.raw(node, null, 'beforeClose');
      }

      var buf = node.parent;
      var depth = 0;

      while (buf && buf.type !== 'root') {
        depth += 1;
        buf = buf.parent;
      }

      if (value.includes('\n')) {
        var indent = this.raw(node, null, 'indent');

        if (indent.length) {
          for (var step = 0; step < depth; step++) {
            value += indent;
          }
        }
      }

      return value;
    }
  }, {
    key: "rawValue",
    value: function rawValue(node, prop) {
      var value = node[prop];
      var raw = node.raws[prop];

      if (raw && raw.value === value) {
        return raw.raw;
      }

      return value;
    }
  }]);

  return Stringifier;
}();

module.exports = Stringifier;