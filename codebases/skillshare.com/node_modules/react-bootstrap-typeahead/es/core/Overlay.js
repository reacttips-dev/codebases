import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import PropTypes from 'prop-types';
import { Popper } from 'react-popper';
import { noop } from '../utils';
var propTypes = {
  /**
   * Specify menu alignment. The default value is `justify`, which makes the
   * menu as wide as the input and truncates long values. Specifying `left`
   * or `right` will align the menu to that side and the width will be
   * determined by the length of menu item values.
   */
  align: PropTypes.oneOf(['justify', 'left', 'right']),
  children: PropTypes.func.isRequired,

  /**
   * Specify whether the menu should appear above the input.
   */
  dropup: PropTypes.bool,

  /**
   * Whether or not to automatically adjust the position of the menu when it
   * reaches the viewport boundaries.
   */
  flip: PropTypes.bool,

  /* eslint-disable-line react/no-unused-prop-types */
  isMenuShown: PropTypes.bool,

  /**
   * Invoked when menu visibility changes.
   */
  onMenuToggle: PropTypes.func,
  positionFixed: PropTypes.bool,

  /* eslint-disable-next-line react/forbid-prop-types */
  referenceElement: PropTypes.object
};
var defaultProps = {
  align: 'justify',
  dropup: false,
  flip: false,
  isMenuShown: false,
  onMenuToggle: noop,
  positionFixed: false
};

function getModifiers(_ref) {
  var align = _ref.align,
      flip = _ref.flip;
  return {
    computeStyles: {
      enabled: true,
      fn: function fn(data) {
        // Use the following condition instead of `align === 'justify'` since
        // it allows the component to fall back to justifying the menu width
        // even when `align` is undefined.
        if (align !== 'right' && align !== 'left') {
          // Set the popper width to match the target width.

          /* eslint-disable-next-line no-param-reassign */
          data.styles.width = data.offsets.reference.width;
        }

        return data;
      }
    },
    flip: {
      enabled: flip
    },
    preventOverflow: {
      escapeWithReference: true
    }
  };
}

var Overlay =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Overlay, _React$Component);

  function Overlay() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Overlay.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props = this.props,
        isMenuShown = _this$props.isMenuShown,
        onMenuToggle = _this$props.onMenuToggle;

    if (isMenuShown !== prevProps.isMenuShown) {
      onMenuToggle(isMenuShown);
    }
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        align = _this$props2.align,
        children = _this$props2.children,
        dropup = _this$props2.dropup,
        isMenuShown = _this$props2.isMenuShown,
        positionFixed = _this$props2.positionFixed,
        referenceElement = _this$props2.referenceElement;

    if (!isMenuShown) {
      return null;
    }

    var xPlacement = align === 'right' ? 'end' : 'start';
    var yPlacement = dropup ? 'top' : 'bottom';
    return React.createElement(Popper, {
      modifiers: getModifiers(this.props),
      placement: yPlacement + "-" + xPlacement,
      positionFixed: positionFixed,
      referenceElement: referenceElement
    }, function (_ref2) {
      var ref = _ref2.ref,
          props = _objectWithoutPropertiesLoose(_ref2, ["ref"]);

      return children(_extends({}, props, {
        innerRef: ref,
        inputHeight: referenceElement ? referenceElement.offsetHeight : 0
      }));
    });
  };

  return Overlay;
}(React.Component);

_defineProperty(Overlay, "propTypes", propTypes);

_defineProperty(Overlay, "defaultProps", defaultProps);

export default Overlay;