"use strict";

var icannTrie = require("../lists/icann.complete");

var privateTrie = require("../lists/private.complete");

var normalize = require("./normalize.js");

var lookUp = require("./tries/lookUp"); // eslint-disable-next-line


var urlParts = /^(:?\/\/|https?:\/\/)?([^/]*@)?(.+?)(:\d{2,5})?([/?].*)?$/; // 1 = protocol, 2 = auth, 3 = domain, 4 = port, 5 = path

var dot = /\./g;
var emptyArr = [];

function matchTld(domain, options) {
  // for potentially unrecognized tlds, try matching against custom tlds
  if (options.customTlds) {
    // try matching against a built regexp of custom tlds
    var tld = domain.match(options.customTlds);

    if (tld !== null) {
      return tld[0];
    }
  }

  var tries = (options.privateTlds ? [privateTrie] : emptyArr).concat(icannTrie);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = tries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var trie = _step.value;

      var _tld = lookUp(trie, domain);

      if (_tld !== null) {
        return "." + _tld;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}
/* eslint-disable jsdoc/no-undefined-types */

/**
 * Removes all unnecessary parts of the domain (e.g. protocol, auth, port, path, query)
 * and parses the remaining domain. The returned object contains the properties 'subdomain', 'domain' and 'tld'.
 *
 * Since the top-level domain is handled differently by every country, this function only
 * supports all tlds listed in src/build/tld.txt.
 *
 * If the given url is not valid or isn't supported by the tld.txt, this function returns null.
 *
 * @param {string} url
 * @param {Object} [options]
 * @param {Array<string>|RegExp} [options.customTlds]
 * @param {boolean} [options.privateTlds]
 * @returns {Object|null}
 */


function parseDomain(url, options) {
  var normalizedUrl = normalize.url(url);
  var tld = null;
  var urlSplit;
  var domain;

  if (normalizedUrl === null) {
    return null;
  }

  var normalizedOptions = normalize.options(options); // urlSplit can't be null because urlParts will always match at the third capture

  urlSplit = normalizedUrl.match(urlParts);
  domain = urlSplit[3]; // domain will now be something like sub.domain.example.com

  tld = matchTld(domain, normalizedOptions);

  if (tld === null) {
    return null;
  } // remove tld and split by dot


  urlSplit = domain.slice(0, -tld.length).split(dot);

  if (tld.charAt(0) === ".") {
    // removes the remaining dot, if present (added to handle localhost)
    tld = tld.slice(1);
  }

  domain = urlSplit.pop();
  var subdomain = urlSplit.join(".");
  return {
    tld: tld,
    domain: domain,
    subdomain: subdomain
  };
}

module.exports = parseDomain;